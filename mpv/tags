!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABORT	telnet.h	59;"	d
ACT3_ASSASSIN	emlen.h	511;"	d
ACT3_BATTLEMAGE	emlen.h	533;"	d
ACT3_DISABLED	emlen.h	530;"	d
ACT3_ELEMENTAL	emlen.h	526;"	d
ACT3_FOLLOW	emlen.h	522;"	d
ACT3_GUARD_DOOR	emlen.h	502;"	d
ACT3_GUARD_DOOR_EVIL	emlen.h	514;"	d
ACT3_GUARD_DOOR_GOOD	emlen.h	513;"	d
ACT3_GUARD_ITEM	emlen.h	501;"	d
ACT3_GUARD_MOB	emlen.h	503;"	d
ACT3_HEALER	emlen.h	508;"	d
ACT3_KILL_EVIL	emlen.h	516;"	d
ACT3_KILL_GOOD	emlen.h	515;"	d
ACT3_MAPPING	emlen.h	529;"	d
ACT3_MARAUDER	emlen.h	534;"	d
ACT3_MUTE	emlen.h	520;"	d
ACT3_MYSTICS	emlen.h	531;"	d
ACT3_NECROMANCER	emlen.h	524;"	d
ACT3_PALADIN	emlen.h	518;"	d
ACT3_RANGER	emlen.h	510;"	d
ACT3_REGENERATE	emlen.h	523;"	d
ACT3_RIDE	emlen.h	521;"	d
ACT3_SHAMAN	emlen.h	504;"	d
ACT3_SLEEP	emlen.h	528;"	d
ACT3_TATICS	emlen.h	535;"	d
ACT3_THIEFG	emlen.h	507;"	d
ACT3_TINKER	emlen.h	505;"	d
ACT3_WARRIOR	emlen.h	506;"	d
ACT3_WIZARD	emlen.h	509;"	d
ACT4_FASTHUNT	emlen.h	538;"	d
ACT4_KILLALLONE	emlen.h	541;"	d
ACT4_KILLALLTWO	emlen.h	542;"	d
ACT4_KILLMEVIL	emlen.h	543;"	d
ACT4_KILLMGOOD	emlen.h	544;"	d
ACT4_MOBSWITCH	emlen.h	537;"	d
ACT4_SOLOYELL	emlen.h	539;"	d
ACT4_STAYOFFROAD	emlen.h	540;"	d
ACTION_OFF	emlen.h	2108;"	d
ACT_AGGRESSIVE	emlen.h	459;"	d
ACT_ANGRY	emlen.h	475;"	d
ACT_ASSISTALL	emlen.h	499;"	d
ACT_ASSISTONE	emlen.h	495;"	d
ACT_ASSISTTWO	emlen.h	496;"	d
ACT_ATTITUDE	emlen.h	494;"	d
ACT_BANK_TELLER	emlen.h	479;"	d
ACT_KILLGLADIATOR	emlen.h	492;"	d
ACT_MOUNTABLE	emlen.h	474;"	d
ACT_NONE	emlen.h	2973;"	d
ACT_PET	emlen.h	468;"	d
ACT_PRACTICE	emlen.h	470;"	d
ACT_RANGER	emlen.h	498;"	d
ACT_RESCUEONE	emlen.h	490;"	d
ACT_RESCUETWO	emlen.h	491;"	d
ACT_REST	emlen.h	497;"	d
ACT_SCAVENGER	emlen.h	458;"	d
ACT_SCRAMBLE	emlen.h	473;"	d
ACT_SENTINEL	emlen.h	457;"	d
ACT_SLEEPAGGRO	emlen.h	493;"	d
ACT_STAY_AREA	emlen.h	460;"	d
ACT_STAY_SECTOR	emlen.h	477;"	d
ACT_UNTOUCHABLE	emlen.h	469;"	d
ACT_UNVAL	emlen.h	471;"	d
ACT_WIMPY	emlen.h	461;"	d
ADDHIT	dam.c	/^ADDHIT (CHAR_DATA * ch, int i)$/;"	f
ADDMOVE	dam.c	/^ADDMOVE (CHAR_DATA * ch, int i)$/;"	f
ADD_PROF	emlen.h	2437;"	d
AFFECT_DATA	emlen.h	/^typedef struct affect_data AFFECT_DATA;$/;"	t	typeref:struct:affect_data
AFFECT_NONE	emlen.h	2980;"	d
AFF_AWARENESS	emlen.h	584;"	d
AFF_BLIND	emlen.h	550;"	d
AFF_BREATH_WATER	emlen.h	580;"	d
AFF_CHARM	emlen.h	589;"	d
AFF_CURSE	emlen.h	560;"	d
AFF_DETECT_EVIL	emlen.h	552;"	d
AFF_DETECT_GOOD	emlen.h	586;"	d
AFF_DETECT_HIDDEN	emlen.h	555;"	d
AFF_DETECT_INVIS	emlen.h	553;"	d
AFF_FLYING	emlen.h	573;"	d
AFF_HIDE	emlen.h	571;"	d
AFF_INFRARED	emlen.h	559;"	d
AFF_INVISIBLE	emlen.h	551;"	d
AFF_MINDSHIELD	emlen.h	554;"	d
AFF_NOCHARM	emlen.h	587;"	d
AFF_PASS_DOOR	emlen.h	574;"	d
AFF_POISON	emlen.h	562;"	d
AFF_PROTECT	emlen.h	568;"	d
AFF_PROT_EVIL	emlen.h	581;"	d
AFF_PROT_GOOD	emlen.h	582;"	d
AFF_REGENERATE	emlen.h	558;"	d
AFF_SAFETY	emlen.h	588;"	d
AFF_SANCTUARY	emlen.h	557;"	d
AFF_SLEEP	emlen.h	572;"	d
AFF_SLOW	emlen.h	575;"	d
AFF_SNEAK	emlen.h	570;"	d
AFF_SPEED	emlen.h	579;"	d
AFF_WOUND	emlen.h	585;"	d
AGGRO_UPDATE	emlen.h	3141;"	d
ALIEN	emlen.h	3062;"	d
ALIGN	emlen.h	2894;"	d
ALLOW_INTERRUPTIONS	mob.h	23;"	d
ALLOW_INTERRUPTIONS	object.h	21;"	d
ALLOW_INTERRUPTIONS	room.h	18;"	d
ALLOW_UNMOTIVATED_PK	emlen.h	3039;"	d
ALL_UPD	emlen.h	3144;"	d
AO	telnet.h	52;"	d
APPLY_AC	emlen.h	785;"	d
APPLY_BACKSTAB_DAMAGE	emlen.h	797;"	d
APPLY_CON	emlen.h	781;"	d
APPLY_DAMROLL	emlen.h	787;"	d
APPLY_DEX	emlen.h	778;"	d
APPLY_HEAL_BONUS	emlen.h	799;"	d
APPLY_HIDE	emlen.h	796;"	d
APPLY_HIT	emlen.h	782;"	d
APPLY_HITROLL	emlen.h	786;"	d
APPLY_INT	emlen.h	779;"	d
APPLY_KICK_DAMAGE	emlen.h	794;"	d
APPLY_MAGIC_DAMAGE	emlen.h	798;"	d
APPLY_MANA	emlen.h	784;"	d
APPLY_MOVE	emlen.h	783;"	d
APPLY_NONE	emlen.h	776;"	d
APPLY_RESIST_SUMMON	emlen.h	793;"	d
APPLY_SAVING_THROW	emlen.h	788;"	d
APPLY_SNEAK	emlen.h	795;"	d
APPLY_STR	emlen.h	777;"	d
APPLY_WIS	emlen.h	780;"	d
ARC	armor.c	8;"	d	file:
ARCHMAGE	emlen.h	965;"	d
AREA_ADDED	emlen.h	2972;"	d
AREA_CHANGED	emlen.h	2971;"	d
AREA_DATA	emlen.h	/^typedef struct area_data AREA_DATA;$/;"	t	typeref:struct:area_data
AREA_LIST	emlen.h	1161;"	d
AREA_NONE	emlen.h	2969;"	d
ARENA_SIZE	emlen.h	617;"	d
ARENA_WAIT_TICK	emlen.h	614;"	d
ARMS	dam.c	84;"	d	file:
ASK_MAP	comm.c	49;"	d	file:
ATTACH_TO_MOB	mob.h	9;"	d
ATTACH_TO_OBJ	object.h	7;"	d
ATTACH_TO_ROOM	room.h	6;"	d
AUTH	emlen.h	985;"	d
AUTHTYPE_CNT	telnet.h	265;"	d
AUTHTYPE_KERBEROS_V4	telnet.h	261;"	d
AUTHTYPE_KERBEROS_V5	telnet.h	262;"	d
AUTHTYPE_MINK	telnet.h	264;"	d
AUTHTYPE_NAME	telnet.h	278;"	d
AUTHTYPE_NAME_OK	telnet.h	277;"	d
AUTHTYPE_NULL	telnet.h	260;"	d
AUTHTYPE_SPX	telnet.h	263;"	d
AUTHTYPE_TEST	telnet.h	267;"	d
AUTH_HOW_MASK	telnet.h	258;"	d
AUTH_HOW_MUTUAL	telnet.h	257;"	d
AUTH_HOW_ONE_WAY	telnet.h	256;"	d
AUTH_WHO_CLIENT	telnet.h	249;"	d
AUTH_WHO_MASK	telnet.h	251;"	d
AUTH_WHO_SERVER	telnet.h	250;"	d
AWARDSKILL	emlen.h	3112;"	d
AWARDTP	emlen.h	3105;"	d
AWARDTPS	emlen.h	3106;"	d
AWARDXP	emlen.h	3104;"	d
AYT	telnet.h	51;"	d
BAN_DATA	emlen.h	/^typedef struct ban_data BAN_DATA;$/;"	t	typeref:struct:ban_data
BATTLEGROUND_END_VNUM	emlen.h	143;"	d
BATTLEGROUND_START_VNUM	emlen.h	142;"	d
BEING_RIDDEN	emlen.h	3059;"	d
BFS_ALREADY_THERE	ar.c	123;"	d	file:
BFS_ERROR	ar.c	122;"	d	file:
BFS_NO_PATH	ar.c	124;"	d	file:
BID_DATA	emlen.h	/^typedef struct bid_data BID_DATA;$/;"	t	typeref:struct:bid_data
BLACK	emlen.h	412;"	d
BLIST	emlen.h	/^typedef struct b_list BLIST;$/;"	t	typeref:struct:b_list
BLUE	emlen.h	416;"	d
BODY	dam.c	86;"	d	file:
BOLD	emlen.h	439;"	d
BREAK	telnet.h	54;"	d
BUILDERS_CAN_GIVE	emlen.h	3036;"	d
B_BLACK	emlen.h	421;"	d
B_BLUE	emlen.h	425;"	d
B_CYAN	emlen.h	427;"	d
B_GREEN	emlen.h	423;"	d
B_GREY	emlen.h	428;"	d
B_PURPLE	emlen.h	426;"	d
B_RED	emlen.h	422;"	d
B_YELLOW	emlen.h	424;"	d
CALCULATE_HEAD	db2.c	1125;"	d	file:
CAN_DROP_ITEMS_IN_ARENA	emlen.h	3031;"	d
CAN_DROP_ITEMS_IN_BGROUND	emlen.h	3033;"	d
CAN_FILL_LIGHT_WHILE_LIT	emlen.h	3037;"	d
CAN_GIVE_ITEMS_IN_ARENA	emlen.h	3032;"	d
CAN_GIVE_ITEMS_IN_BGROUND	emlen.h	3034;"	d
CAN_GO	draw.c	1309;"	d	file:
CAN_GO	draw.c	1310;"	d	file:
CAN_GO	draw.c	1358;"	d	file:
CAN_GO	draw.c	1359;"	d	file:
CAN_GO	draw.c	20;"	d	file:
CAN_GO	draw.c	298;"	d	file:
CAN_GO	draw.c	299;"	d	file:
CAN_GO	draw.c	346;"	d	file:
CAN_GO	draw.c	347;"	d	file:
CAN_GO	draw.c	841;"	d	file:
CAN_GO	draw.c	842;"	d	file:
CAN_GO	draw.c	890;"	d	file:
CAN_GO	draw.c	891;"	d	file:
CAN_LEARN	emlen.h	2438;"	d
CAN_WEAR	emlen.h	2942;"	d
CED_DATA	emlen.h	/^typedef struct ced CED_DATA;$/;"	t	typeref:struct:ced
CHALLENGE	emlen.h	2158;"	d
CHANNEL	emlen.h	/^typedef struct channel_type CHANNEL;$/;"	t	typeref:struct:channel_type
CHANNEL_AUCTION	emlen.h	1097;"	d
CHANNEL_CHAT	emlen.h	1098;"	d
CHANNEL_CLANTALK	emlen.h	1099;"	d
CHANNEL_GODTALK	emlen.h	1103;"	d
CHANNEL_IMMTALK	emlen.h	1100;"	d
CHANNEL_NOTIFY	emlen.h	1101;"	d
CHANNEL_YELL	emlen.h	1102;"	d
CHAR_DATA	emlen.h	/^typedef struct char_data CHAR_DATA;$/;"	t	typeref:struct:char_data
CHAR_MODE	emlen.h	2109;"	d
CHAR_OBJ_SIZE	emlen.h	2920;"	d
CHAR_ONLY_UPD	emlen.h	3135;"	d
CHAR_UPDATE	emlen.h	3139;"	d
CHEAP_RECALL	emlen.h	968;"	d
CHECK_CHAR	fgt.c	10;"	d	file:
CHECK_COMBAT	emlen.h	2194;"	d
CHECK_ENTER_ROOM	emlen.h	2191;"	d
CHECK_GIVEN_OBJ	emlen.h	2193;"	d
CHECK_INTEGRITY	mob.h	21;"	d
CHECK_INTEGRITY	object.h	19;"	d
CHECK_INTEGRITY	room.h	16;"	d
CHECK_MOVE	emlen.h	2192;"	d
CHECK_SAY	emlen.h	2196;"	d
CHECK_SHORT_TICK	emlen.h	2197;"	d
CHECK_SOCIAL	emlen.h	2198;"	d
CHECK_TELL	emlen.h	2195;"	d
CHR_FUNCTION	emlen.h	/^typedef void CHR_FUNCTION (CHAR_DATA *, CHAR_DATA *, char *argy);$/;"	t
CLANWAR	emlen.h	/^typedef struct clanwar CLANWAR;$/;"	t	typeref:struct:clanwar
CLAN_DATA	emlen.h	/^typedef struct clan_data CLAN_DATA;$/;"	t	typeref:struct:clan_data
CLOSESOCKET	comm.c	14;"	d	file:
CLOSESOCKET	comm.c	26;"	d	file:
CLREOL	emlen.h	431;"	d
CLRSCR	emlen.h	430;"	d
CODE	script.h	/^typedef struct code_segment CODE;	\/* Holds trigger code *\/$/;"	t	typeref:struct:code_segment
COINS	emlen.h	3107;"	d
COLOR_CHAT	emlen.h	161;"	d
COLOR_CLANTALK	emlen.h	162;"	d
COLOR_GODTALK	emlen.h	167;"	d
COLOR_IMMTALK	emlen.h	163;"	d
COLOR_SAY	emlen.h	165;"	d
COLOR_TELL	emlen.h	166;"	d
COLOR_YELL	emlen.h	164;"	d
COMBAT_FIELD	emlen.h	/^typedef struct combat_field COMBAT_FIELD;$/;"	t	typeref:struct:combat_field
COMMAND	emlen.h	/^typedef struct cmd_type COMMAND;$/;"	t	typeref:struct:cmd_type
COND_DRUNK	emlen.h	976;"	d
COND_FULL	emlen.h	977;"	d
COND_STARVING	emlen.h	979;"	d
COND_THIRST	emlen.h	978;"	d
CONSTITUTION	emlen.h	3047;"	d
CONTAINS	emlen.h	3111;"	d
CONT_CLOSEABLE	emlen.h	688;"	d
CONT_CLOSED	emlen.h	690;"	d
CONT_LOCKED	emlen.h	691;"	d
CONT_PICKPROOF	emlen.h	689;"	d
CON_AEDITOR	emlen.h	324;"	d
CON_ASK_MENU	emlen.h	317;"	d
CON_CEDITOR	emlen.h	328;"	d
CON_CHANNELD	emlen.h	320;"	d
CON_CONFIRM_NEW_NAME	emlen.h	308;"	d
CON_CONFIRM_NEW_PASSWORD	emlen.h	310;"	d
CON_CONFIRM_NEW_RACE	emlen.h	313;"	d
CON_CONFIRM_ROLL	emlen.h	315;"	d
CON_FSEDITOR	emlen.h	329;"	d
CON_GET_NEW_ANSI	emlen.h	316;"	d
CON_GET_NEW_PASSWORD	emlen.h	309;"	d
CON_GET_NEW_RACE	emlen.h	312;"	d
CON_GET_NEW_SEX	emlen.h	311;"	d
CON_GET_OLD_PASSWORD	emlen.h	307;"	d
CON_GET_PAGELEN	emlen.h	319;"	d
CON_GODMENU	emlen.h	332;"	d
CON_HEDITOR	emlen.h	33;"	d
CON_I	emlen.h	45;"	d
CON_MEDITOR	emlen.h	326;"	d
CON_OEDITOR	emlen.h	327;"	d
CON_PEDITOR	emlen.h	330;"	d
CON_PLAYING	emlen.h	305;"	d
CON_READ_CHANGES	emlen.h	322;"	d
CON_READ_MOTD	emlen.h	314;"	d
CON_REDITOR	emlen.h	325;"	d
CON_RWHO	emlen.h	321;"	d
CON_SCRIPTEDITOR	emlen.h	334;"	d
CON_SEDITOR	emlen.h	331;"	d
CON_SHELL	emlen.h	335;"	d
CON_SHOW_TITLE	emlen.h	318;"	d
CON_SOCEDIT	emlen.h	333;"	d
CON_STATE_ONE	emlen.h	306;"	d
COOL_SKILL_ARCHMAGE	emlen.h	954;"	d
COOL_SKILL_CHEAP_RECALL	emlen.h	957;"	d
COOL_SKILL_MARTIAL_ARTIST	emlen.h	953;"	d
COOL_SKILL_NO_HUNGER	emlen.h	955;"	d
COOL_SKILL_NO_PKILL	emlen.h	959;"	d
COOL_SKILL_NO_THIRST	emlen.h	956;"	d
COOL_SKILL_VIEW_MOBS	emlen.h	958;"	d
COST_ASSASSIN	emlen.h	1035;"	d
COST_BATTLEMAGE	emlen.h	1038;"	d
COST_ELEMENTAL	emlen.h	1037;"	d
COST_HEALER	emlen.h	1032;"	d
COST_MARAUDER	emlen.h	1039;"	d
COST_MYSTICS	emlen.h	1042;"	d
COST_NECROMANCER	emlen.h	1040;"	d
COST_PALADIN	emlen.h	1036;"	d
COST_RANGER	emlen.h	1034;"	d
COST_SHAMAN	emlen.h	1043;"	d
COST_TATICS	emlen.h	1041;"	d
COST_THIEFG	emlen.h	1031;"	d
COST_TINKER	emlen.h	1029;"	d
COST_WARRIOR	emlen.h	1030;"	d
COST_WIZARD	emlen.h	1033;"	d
CREATEOBJ	emlen.h	3109;"	d
CTRL_R	remort.c	7;"	d	file:
CYAN	emlen.h	418;"	d
DAM_MSG	emlen.h	/^typedef struct dammsg_data DAM_MSG;$/;"	t	typeref:struct:dammsg_data
DAM_STRUCT	emlen.h	/^typedef struct damages_struct DAM_STRUCT;$/;"	t	typeref:struct:damages_struct
DEBUG	shell.c	35;"	d	file:
DEFINE_COMMAND	emlen.h	2988;"	d
DELAY_CHAR	emlen.h	3073;"	d
DELAY_SCRIPT	mob.h	18;"	d
DELAY_SCRIPT	object.h	16;"	d
DELAY_SCRIPT	room.h	13;"	d
DESCRIPTED	emlen.h	2790;"	d
DESCRIPTION_DATA	emlen.h	/^typedef struct extra_descr_data DESCRIPTION_DATA;$/;"	t	typeref:struct:extra_descr_data
DESCRIPTOR_DATA	emlen.h	/^typedef struct descriptor_data DESCRIPTOR_DATA;$/;"	t	typeref:struct:descriptor_data
DESTROY	emlen.h	3102;"	d
DESTROY_OBJECT	emlen.h	2508;"	d
DESTROY_RANDOM_OBJECT	emlen.h	2509;"	d
DEXTERITY	emlen.h	3046;"	d
DEX_I	emlen.h	44;"	d
DIMPLEFLAG_ONE	mob_101.c	3;"	d	file:
DIMPLEFLAG_ONE	mob_1029.c	3;"	d	file:
DIR_DOWN	emlen.h	866;"	d
DIR_EAST	emlen.h	862;"	d
DIR_MAX	emlen.h	2974;"	d
DIR_NORTH	emlen.h	861;"	d
DIR_SOUTH	emlen.h	863;"	d
DIR_UP	emlen.h	865;"	d
DIR_WEST	emlen.h	864;"	d
DM	telnet.h	55;"	d
DO	telnet.h	44;"	d
DONT	telnet.h	43;"	d
DONT_ALLOW_INTERRUPTIONS	mob.h	22;"	d
DONT_ALLOW_INTERRUPTIONS	object.h	20;"	d
DONT_ALLOW_INTERRUPTIONS	room.h	17;"	d
DOOR_DATA	emlen.h	/^typedef struct door_data DOOR_DATA;$/;"	t	typeref:struct:door_data
DOWNARROW	emlen.h	433;"	d
DO_COMMAND	emlen.h	/^typedef void DO_COMMAND (CHAR_DATA *, char *);$/;"	t
DO_TELL	emlen.h	3076;"	d
DSAY	emlen.h	3074;"	d
DSC	emlen.h	2167;"	d
DTELL	emlen.h	3078;"	d
EC	telnet.h	50;"	d
EL	telnet.h	49;"	d
ENCRYPT_CNT	telnet.h	292;"	d
ENCRYPT_DEC_KEYID	telnet.h	291;"	d
ENCRYPT_ENC_KEYID	telnet.h	290;"	d
ENCRYPT_END	telnet.h	287;"	d
ENCRYPT_IS	telnet.h	283;"	d
ENCRYPT_NAME	telnet.h	315;"	d
ENCRYPT_NAME_OK	telnet.h	314;"	d
ENCRYPT_REPLY	telnet.h	285;"	d
ENCRYPT_REQEND	telnet.h	289;"	d
ENCRYPT_REQSTART	telnet.h	288;"	d
ENCRYPT_START	telnet.h	286;"	d
ENCRYPT_SUPPORT	telnet.h	284;"	d
ENCTYPE_ANY	telnet.h	294;"	d
ENCTYPE_CNT	telnet.h	297;"	d
ENCTYPE_DES_CFB64	telnet.h	295;"	d
ENCTYPE_DES_OFB64	telnet.h	296;"	d
ENCTYPE_NAME	telnet.h	318;"	d
ENCTYPE_NAME_OK	telnet.h	317;"	d
ENDMARKER	channels.c	20;"	d	file:
END_FUNCTION	mob.h	14;"	d
END_FUNCTION	object.h	12;"	d
END_FUNCTION	room.h	11;"	d
ENV_ESC	telnet.h	239;"	d
ENV_USERVAR	telnet.h	240;"	d
EOR	telnet.h	58;"	d
EXECUTE_COMMAND	emlen.h	3099;"	d
EXIT_DATA	emlen.h	/^typedef struct exit_data EXIT_DATA;$/;"	t	typeref:struct:exit_data
EXTRA_NONE	emlen.h	2976;"	d
EX_BASHPROOF	emlen.h	877;"	d
EX_CLOSED	emlen.h	874;"	d
EX_HIDDEN	emlen.h	878;"	d
EX_ISDOOR	emlen.h	873;"	d
EX_LOCKED	emlen.h	875;"	d
EX_NONE	emlen.h	2977;"	d
EX_PICKPROOF	emlen.h	876;"	d
EX_RESET	emlen.h	879;"	d
FALSE	emlen.h	26;"	d
FD_SETSIZE	comm.c	11;"	d	file:
FGT	emlen.h	/^typedef struct fight_data FGT;$/;"	t	typeref:struct:fight_data
FIELD_TICK_WAIT	combat.c	24;"	d	file:
FIGHTING	emlen.h	2886;"	d
FIGHT_LOOP	emlen.h	3134;"	d
FIGHT_UPD	emlen.h	3137;"	d
FIND_EXP	emlen.h	2909;"	d
FIND_EXP	emlen.h	2913;"	d
FIND_TPS	emlen.h	2910;"	d
FIND_TPS	emlen.h	2912;"	d
FIRSTDICE	emlen.h	2916;"	d
FIXIT	emlen.h	4100;"	d
FLAG	emlen.h	3101;"	d
FLASH	emlen.h	440;"	d
FLEE	emlen.h	3072;"	d
FNDELAY	comm.c	1238;"	d	file:
FNDELAY	comm.c	1321;"	d	file:
FNDELAY	mush.h	13;"	d
FORCE_LEVEL	aw.c	/^int FORCE_LEVEL;$/;"	v
FP_BLEEDING	emlen.h	230;"	d
FP_CHOKE_1	emlen.h	226;"	d
FP_CHOKE_2	emlen.h	227;"	d
FP_CHOKE_3	emlen.h	228;"	d
FP_PUNCHING	emlen.h	232;"	d
FP_STUNNED	emlen.h	229;"	d
FP_TOO_HEAVY	emlen.h	231;"	d
FURN_EXIT	emlen.h	701;"	d
F_AGGRESSIVE	emlen.h	219;"	d
F_BITE	emlen.h	216;"	d
F_CHOKE	emlen.h	217;"	d
F_ELBOW	emlen.h	214;"	d
F_GROUND	emlen.h	221;"	d
F_HEADBUTT	emlen.h	212;"	d
F_JUJI	emlen.h	213;"	d
F_KNEE	emlen.h	215;"	d
F_POWER	emlen.h	220;"	d
GA	telnet.h	48;"	d
GAVE_RING	mob_1514.c	4;"	d	file:
GAVE_RING	mob_2013.c	4;"	d	file:
GENERIC	dam.c	83;"	d	file:
GET_AC	emlen.h	2898;"	d
GET_DAMROLL	look.c	/^GET_DAMROLL (CHAR_DATA * ch)$/;"	f
GET_DMROLL	emlen.h	2900;"	d
GET_GUILD_STAT	char.c	/^ int GET_GUILD_STAT ( CHAR_DATA * ch, int num )$/;"	f
GET_HITROLL	look.c	/^GET_HITROLL (CHAR_DATA * ch)$/;"	f
GET_HTROLL	emlen.h	2899;"	d
GET_OBJ_SIZE	emlen.h	2933;"	d
GIVECOINS	emlen.h	3108;"	d
GIVEITEM	emlen.h	3110;"	d
GNOME_WIZARD_RING_QUEST	mob_1514.c	5;"	d	file:
GNOME_WIZARD_RING_QUEST	mob_2013.c	5;"	d	file:
GOT_DIMPLE_ANSWER	mob_101.c	4;"	d	file:
GOT_DIMPLE_ANSWER	mob_1029.c	4;"	d	file:
GREEN	emlen.h	414;"	d
GREY	emlen.h	419;"	d
GUILD_ASSASSIN	emlen.h	998;"	d
GUILD_BATTLEMAGE	emlen.h	1003;"	d
GUILD_ELEMENTAL	emlen.h	1001;"	d
GUILD_HEALER	emlen.h	995;"	d
GUILD_MARAUDER	emlen.h	1004;"	d
GUILD_MYSTICS	emlen.h	1002;"	d
GUILD_NECROMANCER	emlen.h	1000;"	d
GUILD_PALADIN	emlen.h	999;"	d
GUILD_RANGER	emlen.h	997;"	d
GUILD_SHAMAN	emlen.h	991;"	d
GUILD_TATICS	emlen.h	1005;"	d
GUILD_THIEFG	emlen.h	994;"	d
GUILD_TINKER	emlen.h	992;"	d
GUILD_WARRIOR	emlen.h	993;"	d
GUILD_WIZARD	emlen.h	996;"	d
HASH_MAX	emlen.h	127;"	d
HAS_ARMS_DEXTERITY_IMPLANT	emlen.h	2406;"	d
HAS_ARMS_STRENGTH_IMPLANT	emlen.h	2401;"	d
HAS_BODY_ARMOR_IMPLANT	emlen.h	2411;"	d
HAS_BODY_STRENGTH_IMPLANT	emlen.h	2404;"	d
HAS_FEET_IMPLANT	emlen.h	2409;"	d
HAS_HANDS_ARMOR_IMPLANT	emlen.h	2410;"	d
HAS_HANDS_STRENGTH_IMPLANT	emlen.h	2403;"	d
HAS_HEAD_BRAIN_IMPLANT	emlen.h	2408;"	d
HAS_LEGS_RUNNING_IMPLANT	emlen.h	2407;"	d
HAS_LEGS_STRENGTH_IMPLANT	emlen.h	2402;"	d
HAS_TALKED_TO_WIZARD	mob_1514.c	3;"	d	file:
HAS_TALKED_TO_WIZARD	mob_2013.c	3;"	d	file:
HEAD	dam.c	85;"	d	file:
HELP_DATA	emlen.h	/^typedef struct help_data HELP_DATA;$/;"	t	typeref:struct:help_data
HE_SHE	emlen.h	2876;"	d
HIM_HER	emlen.h	2880;"	d
HIS_HER	emlen.h	2878;"	d
HOMEPOS	emlen.h	437;"	d
HOST_DIR	emlen.h	1157;"	d
HP_MAX	emlen.h	3050;"	d
HP_NOW	emlen.h	3049;"	d
HUMANOID	emlen.h	3063;"	d
HUNTING	emlen.h	1937;"	d
IAC	telnet.h	42;"	d
IMPLANT_ARMS	emlen.h	2394;"	d
IMPLANT_BODY	emlen.h	2399;"	d
IMPLANT_FEET	emlen.h	2397;"	d
IMPLANT_HANDS	emlen.h	2398;"	d
IMPLANT_HEAD	emlen.h	2396;"	d
IMPLANT_LEGS	emlen.h	2395;"	d
INDOORS_MAP	hnd.c	989;"	d	file:
INTEGER	emlen.h	3088;"	d
INTELLIGENCE	emlen.h	3044;"	d
INTERPRETTED	emlen.h	3142;"	d
INT_I	emlen.h	42;"	d
INVERSE	emlen.h	441;"	d
IN_BATTLE	emlen.h	2155;"	d
IN_BATTLEGROUND	emlen.h	3061;"	d
IN_BOAT	emlen.h	3065;"	d
IN_SUN	emlen.h	2882;"	d
IP	telnet.h	53;"	d
ISMOB	emlen.h	2105;"	d
IS_AFFECTED	emlen.h	2892;"	d
IS_AFFECTED_EXTRA	emlen.h	2893;"	d
IS_AUTUMN	emlen.h	3117;"	d
IS_AWAKE	emlen.h	2887;"	d
IS_BUILDER	emlen.h	1930;"	d
IS_CLEARSKY	emlen.h	3119;"	d
IS_CLOSED	emlen.h	2863;"	d
IS_CLOUDY	emlen.h	3120;"	d
IS_CORPSE_MOB	fgt.c	/^IS_CORPSE_MOB (CHAR_DATA * ch)$/;"	f
IS_DAY	emlen.h	3123;"	d
IS_EVIL	emlen.h	2896;"	d
IS_FIGHTING	emlen.h	3060;"	d
IS_GOD	emlen.h	2891;"	d
IS_GOOD	emlen.h	2895;"	d
IS_IMMORTAL	emlen.h	2890;"	d
IS_IN_AGGRO_LIST	emlen.h	2107;"	d
IS_IN_BOAT	emlen.h	1922;"	d
IS_IN_BOAT	emlen.h	1924;"	d
IS_IN_FIGHTING_LIST	emlen.h	2106;"	d
IS_IN_MELEE	emlen.h	2946;"	d
IS_IN_MELEE	emlen.h	2952;"	d
IS_JAVA	emlen.h	4099;"	d
IS_LIT	emlen.h	2959;"	d
IS_MARKED	ar.c	149;"	d	file:
IS_MARKED	emlen.h	2861;"	d
IS_MOB	emlen.h	2888;"	d
IS_NEUTRAL	emlen.h	2897;"	d
IS_NIGHT	emlen.h	3122;"	d
IS_OBJ_STAT	emlen.h	2943;"	d
IS_OUTSIDE	emlen.h	2902;"	d
IS_PLAYER	emlen.h	2889;"	d
IS_PROF	emlen.h	2436;"	d
IS_RAINING	emlen.h	3118;"	d
IS_REAL_GOD	emlen.h	2944;"	d
IS_RIDING	emlen.h	3058;"	d
IS_SET	emlen.h	2847;"	d
IS_SPRING	emlen.h	3115;"	d
IS_STORM	emlen.h	3121;"	d
IS_SUMMER	emlen.h	3116;"	d
IS_WINTER	emlen.h	3114;"	d
ITEMCOLOR	emlen.h	449;"	d
ITEM_AMMO	emlen.h	638;"	d
ITEM_ANTI_EVIL	emlen.h	715;"	d
ITEM_ANTI_GOOD	emlen.h	714;"	d
ITEM_ANTI_NEUTRAL	emlen.h	716;"	d
ITEM_ARMOR	emlen.h	640;"	d
ITEM_BLOOD	emlen.h	658;"	d
ITEM_BOAT	emlen.h	664;"	d
ITEM_BOOK	emlen.h	642;"	d
ITEM_CHECK	emlen.h	/^typedef struct item_check ITEM_CHECK;$/;"	t	typeref:struct:item_check
ITEM_CLIMBABLE	emlen.h	659;"	d
ITEM_CONCUSSION	emlen.h	728;"	d
ITEM_CONTAINER	emlen.h	645;"	d
ITEM_CORPSE_NPC	emlen.h	652;"	d
ITEM_CORPSE_PC	emlen.h	653;"	d
ITEM_DRINK_CON	emlen.h	647;"	d
ITEM_EVIL	emlen.h	709;"	d
ITEM_FLOATING	emlen.h	765;"	d
ITEM_FOOD	emlen.h	649;"	d
ITEM_FOUNTAIN	emlen.h	654;"	d
ITEM_FURNITURE	emlen.h	643;"	d
ITEM_GEM	emlen.h	650;"	d
ITEM_GLOW	emlen.h	707;"	d
ITEM_GOOD	emlen.h	710;"	d
ITEM_HEAVY_SLASH	emlen.h	730;"	d
ITEM_HOLD	emlen.h	759;"	d
ITEM_HUM	emlen.h	708;"	d
ITEM_INVENTORY	emlen.h	718;"	d
ITEM_INVIS	emlen.h	711;"	d
ITEM_KEY	emlen.h	648;"	d
ITEM_LANCE	emlen.h	734;"	d
ITEM_LIGHT	emlen.h	632;"	d
ITEM_LIGHT_SLASH	emlen.h	733;"	d
ITEM_LIST	emlen.h	657;"	d
ITEM_MAGIC	emlen.h	712;"	d
ITEM_MAP	emlen.h	662;"	d
ITEM_MAX	emlen.h	666;"	d
ITEM_NODROP	emlen.h	713;"	d
ITEM_NONE	emlen.h	2979;"	d
ITEM_NOPKILL	emlen.h	738;"	d
ITEM_NOREMOVE	emlen.h	717;"	d
ITEM_NOSAVE	emlen.h	719;"	d
ITEM_NOSTORE	emlen.h	737;"	d
ITEM_PIERCE	emlen.h	726;"	d
ITEM_PILL	emlen.h	655;"	d
ITEM_POTION	emlen.h	641;"	d
ITEM_RANGED_WEAPON	emlen.h	637;"	d
ITEM_REPELLANT	emlen.h	665;"	d
ITEM_SAVE	emlen.h	736;"	d
ITEM_SCALABLE	emlen.h	660;"	d
ITEM_SCALE_DEV	emlen.h	661;"	d
ITEM_SCROLL	emlen.h	633;"	d
ITEM_SLASHING	emlen.h	727;"	d
ITEM_STAFF	emlen.h	635;"	d
ITEM_TAKE	emlen.h	744;"	d
ITEM_THROWN	emlen.h	646;"	d
ITEM_TICKET	emlen.h	663;"	d
ITEM_TOOL	emlen.h	656;"	d
ITEM_TRASH	emlen.h	644;"	d
ITEM_TREASURE	emlen.h	639;"	d
ITEM_UNSEEN	emlen.h	720;"	d
ITEM_VEHICLE	emlen.h	651;"	d
ITEM_WAND	emlen.h	634;"	d
ITEM_WEAPON	emlen.h	636;"	d
ITEM_WEAR_ABOUT	emlen.h	754;"	d
ITEM_WEAR_ANKLE	emlen.h	767;"	d
ITEM_WEAR_ARMS	emlen.h	752;"	d
ITEM_WEAR_BACK	emlen.h	770;"	d
ITEM_WEAR_BELT	emlen.h	757;"	d
ITEM_WEAR_BODY	emlen.h	747;"	d
ITEM_WEAR_EAR1	emlen.h	766;"	d
ITEM_WEAR_ELBOW	emlen.h	769;"	d
ITEM_WEAR_EYEPATCH	emlen.h	772;"	d
ITEM_WEAR_FACE	emlen.h	764;"	d
ITEM_WEAR_FEET	emlen.h	750;"	d
ITEM_WEAR_FINGER	emlen.h	745;"	d
ITEM_WEAR_HANDS	emlen.h	751;"	d
ITEM_WEAR_HEAD	emlen.h	748;"	d
ITEM_WEAR_KNEE	emlen.h	768;"	d
ITEM_WEAR_LEGS	emlen.h	749;"	d
ITEM_WEAR_NECK	emlen.h	746;"	d
ITEM_WEAR_NONE	emlen.h	2978;"	d
ITEM_WEAR_SHIELD	emlen.h	753;"	d
ITEM_WEAR_SHOULDER	emlen.h	763;"	d
ITEM_WEAR_TATTOO	emlen.h	771;"	d
ITEM_WEAR_WAIST	emlen.h	755;"	d
ITEM_WEAR_WRIST	emlen.h	756;"	d
ITEM_WHIP	emlen.h	729;"	d
ITEM_WIELD	emlen.h	758;"	d
I_ARMOR	emlen.h	/^typedef struct item_armor I_ARMOR;$/;"	t	typeref:struct:item_armor
I_BLOOD	emlen.h	/^typedef struct item_blood I_BLOOD;$/;"	t	typeref:struct:item_blood
I_BOOK	emlen.h	/^typedef struct item_book I_BOOK;$/;"	t	typeref:struct:item_book
I_CLIMBABLE	emlen.h	/^typedef struct item_climbable I_CLIMBABLE;$/;"	t	typeref:struct:item_climbable
I_CONTAINER	emlen.h	/^typedef struct item_container I_CONTAINER;$/;"	t	typeref:struct:item_container
I_DRINK	emlen.h	/^typedef struct item_drink_container I_DRINK;$/;"	t	typeref:struct:item_drink_container
I_FOOD	emlen.h	/^typedef struct item_food I_FOOD;$/;"	t	typeref:struct:item_food
I_FOUNTAIN	emlen.h	/^typedef struct item_fountain I_FOUNTAIN;$/;"	t	typeref:struct:item_fountain
I_FURNITURE	emlen.h	/^typedef struct item_furniture I_FURNITURE;$/;"	t	typeref:struct:item_furniture
I_GEM	emlen.h	/^typedef struct item_gem I_GEM;$/;"	t	typeref:struct:item_gem
I_LIGHT	emlen.h	/^typedef struct item_light I_LIGHT;$/;"	t	typeref:struct:item_light
I_POTION	emlen.h	/^typedef struct item_potion I_POTION;$/;"	t	typeref:struct:item_potion
I_SPRAY	emlen.h	/^typedef struct item_spray I_SPRAY;$/;"	t	typeref:struct:item_spray
I_TOOL	emlen.h	/^typedef struct item_tool I_TOOL;$/;"	t	typeref:struct:item_tool
I_VEHICLE	emlen.h	/^typedef struct item_vehicle I_VEHICLE;$/;"	t	typeref:struct:item_vehicle
I_WAND	emlen.h	/^typedef struct item_wand I_WAND;$/;"	t	typeref:struct:item_wand
I_WEAPON	emlen.h	/^typedef struct item_weapon I_WEAPON;$/;"	t	typeref:struct:item_weapon
KEY	db2.c	1289;"	d	file:
KEY	db2.c	1292;"	d	file:
KEY	sedit.c	11;"	d	file:
KEY	sv.c	1233;"	d	file:
KEY	sv.c	1235;"	d	file:
K_CHAR	emlen.h	672;"	d
K_OBJ	emlen.h	671;"	d
K_OBJECT	emlen.h	670;"	d
K_PC	emlen.h	674;"	d
K_ROOM	emlen.h	673;"	d
LD	emlen.h	2161;"	d
LEADER	emlen.h	2839;"	d
LEFTARROW	emlen.h	436;"	d
LEGS	dam.c	87;"	d	file:
LEVEL	emlen.h	2841;"	d
LEVEL_ASSASSIN	emlen.h	1016;"	d
LEVEL_BATTLEMAGE	emlen.h	1019;"	d
LEVEL_BUILDER	emlen.h	176;"	d
LEVEL_ELEMENTAL	emlen.h	1018;"	d
LEVEL_HEALER	emlen.h	1013;"	d
LEVEL_IMMORTAL	emlen.h	177;"	d
LEVEL_MARAUDER	emlen.h	1020;"	d
LEVEL_MYSTICS	emlen.h	1022;"	d
LEVEL_NECROMANCER	emlen.h	1021;"	d
LEVEL_PALADIN	emlen.h	1017;"	d
LEVEL_RANGER	emlen.h	1015;"	d
LEVEL_SHAMAN	emlen.h	1024;"	d
LEVEL_TATICS	emlen.h	1023;"	d
LEVEL_THIEFG	emlen.h	1012;"	d
LEVEL_TINKER	emlen.h	1010;"	d
LEVEL_WARRIOR	emlen.h	1011;"	d
LEVEL_WIZARD	emlen.h	1014;"	d
LFLOW_OFF	telnet.h	153;"	d
LFLOW_ON	telnet.h	154;"	d
LFLOW_RESTART_ANY	telnet.h	155;"	d
LFLOW_RESTART_XON	telnet.h	156;"	d
LIGHT_FILLABLE	emlen.h	693;"	d
LIGHT_LIT	emlen.h	692;"	d
LIMITED_DATA	emlen.h	/^typedef struct limited_data LIMITED_DATA;$/;"	t	typeref:struct:limited_data
LIQ_MAX	emlen.h	2477;"	d
LIQ_WATER	emlen.h	2476;"	d
LM_FORWARDMASK	telnet.h	163;"	d
LM_MODE	telnet.h	162;"	d
LM_SLC	telnet.h	164;"	d
LOG_ALWAYS	emlen.h	2984;"	d
LOG_LEVEL	db2.c	/^int LOG_LEVEL = LEVEL_IMMORTAL;$/;"	v
LOG_NEVER	emlen.h	2985;"	d
LOG_NORMAL	emlen.h	2986;"	d
LOOP	emlen.h	3130;"	d
LOWER	emlen.h	2845;"	d
MANANOW	emlen.h	2918;"	d
MANA_AIR	emlen.h	1135;"	d
MANA_ANY	emlen.h	1132;"	d
MANA_DEATH	emlen.h	1138;"	d
MANA_EARTH	emlen.h	1134;"	d
MANA_FIRE	emlen.h	1136;"	d
MANA_NONE	emlen.h	1133;"	d
MANA_WATER	emlen.h	1137;"	d
MAP_INROOM	emlen.h	681;"	d
MAP_INSIDE	emlen.h	680;"	d
MARK	ar.c	147;"	d	file:
MARK	emlen.h	2859;"	d
MARK_CHAR_DEBUG	emlen.h	3025;"	d
MARK_CHUNK	mob.h	19;"	d
MARK_CHUNK	object.h	17;"	d
MARK_CHUNK	room.h	14;"	d
MARK_DEBUG	emlen.h	3024;"	d
MARTIAL_ARTIST	emlen.h	964;"	d
MASTER	emlen.h	2838;"	d
MASTER	emlen.h	2885;"	d
MAXALIAS	emlen.h	407;"	d
MAXHIT	dam.c	/^MAXHIT (CHAR_DATA * ch)$/;"	f
MAXMANA	dam.c	/^void MAXMANA(CHAR_DATA *ch) {$/;"	f
MAXMOVE	dam.c	/^MAXMOVE (CHAR_DATA * ch)$/;"	f
MAXST	emlen.h	155;"	d
MAXX	draw.c	13;"	d	file:
MAXX	draw.c	15;"	d	file:
MAX_ATTACK	emlen.h	401;"	d
MAX_ATTACK_TYPES	emlen.h	402;"	d
MAX_BOARDS	note.c	18;"	d	file:
MAX_CLAN	emlen.h	154;"	d
MAX_CLAN_STORAGE	emlen.h	152;"	d
MAX_COLORS	emlen.h	150;"	d
MAX_CON	comm.c	2759;"	d	file:
MAX_DEX	comm.c	2763;"	d	file:
MAX_DIR	emlen.h	867;"	d
MAX_HOST	emlen.h	149;"	d
MAX_I	emlen.h	46;"	d
MAX_INPUT_LENGTH	emlen.h	133;"	d
MAX_INT	comm.c	2767;"	d	file:
MAX_LEVEL	emlen.h	175;"	d
MAX_LIMITED	emlen.h	1655;"	d
MAX_MOB_TRO	emlen.h	134;"	d
MAX_MOB_TYPE	emlen.h	384;"	d
MAX_NESTING	sv.c	17;"	d	file:
MAX_ONESTAT	emlen.h	40;"	d
MAX_OPTION	poll.h	1;"	d
MAX_PLAYERS_IN_CLAN	emlen.h	170;"	d
MAX_RANDOMPOP	emlen.h	2831;"	d
MAX_RATING	emlen.h	159;"	d
MAX_REMORT_OPTIONS	emlen.h	2207;"	d
MAX_SCROLLBACK	emlen.h	2830;"	d
MAX_STAT	emlen.h	39;"	d
MAX_STR	comm.c	2755;"	d	file:
MAX_STRING_LENGTH	emlen.h	129;"	d
MAX_TOPTEN	emlen.h	158;"	d
MAX_TRADE	emlen.h	169;"	d
MAX_TROPHY	emlen.h	157;"	d
MAX_WEAR	emlen.h	948;"	d
MAX_WIS	comm.c	2771;"	d	file:
MIL	emlen.h	132;"	d
MOB	emlen.h	3093;"	d
MOBILE_UPD	emlen.h	3136;"	d
MOB_BIRD	emlen.h	369;"	d
MOB_CANINE	emlen.h	362;"	d
MOB_DARKELF	emlen.h	382;"	d
MOB_DATA	emlen.h	/^typedef struct npc_data MOB_DATA;$/;"	t	typeref:struct:npc_data
MOB_DEMON	emlen.h	367;"	d
MOB_DRAGON	emlen.h	361;"	d
MOB_DUMMY	emlen.h	383;"	d
MOB_DWARF	emlen.h	358;"	d
MOB_ELF	emlen.h	357;"	d
MOB_FAERIE	emlen.h	375;"	d
MOB_FELINE	emlen.h	372;"	d
MOB_FISH	emlen.h	370;"	d
MOB_FUNCTION	mob.h	13;"	d
MOB_FUNCTION	mob_101.c	/^ATTACH_TO_MOB (mob_101_2, 101, SAY \/ TELL, unused) MOB_FUNCTION (mob_101_1)$/;"	f
MOB_FUNCTION	mob_101.c	/^MOB_FUNCTION (mob_101_2)$/;"	f
MOB_FUNCTION	mob_1029.c	/^ATTACH_TO_MOB (mob_1029_2, 101, SAY \/ TELL, unused) MOB_FUNCTION (mob_1029_1)$/;"	f
MOB_FUNCTION	mob_1029.c	/^MOB_FUNCTION (mob_1029_2)$/;"	f
MOB_FUNCTION	mob_1114.c	/^ATTACH_TO_MOB (mob_1114_2, 1114, GIVEN_OBJECT, vnum) MOB_FUNCTION (mob_1114_1)$/;"	f
MOB_FUNCTION	mob_1114.c	/^MOB_FUNCTION (mob_1114_2)$/;"	f
MOB_FUNCTION	mob_1514.c	/^ATTACH_TO_MOB (mob_1514_2, 1514, GIVEN_OBJECT, vnum) MOB_FUNCTION (mob_1514_1)$/;"	f
MOB_FUNCTION	mob_1514.c	/^MOB_FUNCTION (mob_1514_2)$/;"	f
MOB_FUNCTION	mob_2013.c	/^ATTACH_TO_MOB (mob_2013_2, 2013, GIVEN_OBJECT, vnum) MOB_FUNCTION (mob_2013_1)$/;"	f
MOB_FUNCTION	mob_2013.c	/^MOB_FUNCTION (mob_2013_2)$/;"	f
MOB_GENERAL_ANIMAL	emlen.h	374;"	d
MOB_GHOST	emlen.h	377;"	d
MOB_GIANT	emlen.h	360;"	d
MOB_GNOME	emlen.h	359;"	d
MOB_GOLEM	emlen.h	366;"	d
MOB_HUMAN	emlen.h	356;"	d
MOB_INSECT	emlen.h	364;"	d
MOB_LYCAN	emlen.h	379;"	d
MOB_NIGHT	emlen.h	380;"	d
MOB_ORC	emlen.h	381;"	d
MOB_OTHER	emlen.h	378;"	d
MOB_PLANT	emlen.h	373;"	d
MOB_PROTOTYPE	emlen.h	/^typedef struct mob_proto_data MOB_PROTOTYPE;$/;"	t	typeref:struct:mob_proto_data
MOB_REPTILE	emlen.h	376;"	d
MOB_RODENT	emlen.h	363;"	d
MOB_STATUE	emlen.h	371;"	d
MOB_TROLL	emlen.h	368;"	d
MOB_UNDEAD	emlen.h	365;"	d
MODE_ACK	telnet.h	168;"	d
MODE_ECHO	telnet.h	176;"	d
MODE_EDIT	telnet.h	166;"	d
MODE_FLOW	telnet.h	175;"	d
MODE_FORCE	telnet.h	179;"	d
MODE_INBIN	telnet.h	177;"	d
MODE_LIT_ECHO	telnet.h	170;"	d
MODE_MASK	telnet.h	172;"	d
MODE_OUTBIN	telnet.h	178;"	d
MODE_SOFT_TAB	telnet.h	169;"	d
MODE_TRAPSIG	telnet.h	167;"	d
MOON_RISE	emlen.h	196;"	d
MOON_SET	emlen.h	197;"	d
MOUNTED_BY	emlen.h	2837;"	d
MOVES_MAX	emlen.h	3055;"	d
MOVES_NOW	emlen.h	3052;"	d
MOVE_MAX	emlen.h	3056;"	d
MOVE_NOW	emlen.h	3053;"	d
MRD	comm.c	48;"	d	file:
MSL	emlen.h	130;"	d
MT	emlen.h	3145;"	d
MV_MAX	emlen.h	3057;"	d
MV_NOW	emlen.h	3054;"	d
NAME	emlen.h	2961;"	d
NEW_ENV_VALUE	telnet.h	238;"	d
NEW_ENV_VAR	telnet.h	237;"	d
NEW_POSITION	dam.c	/^NEW_POSITION (CHAR_DATA * ch, int nw)$/;"	f
NO	emlen.h	31;"	d
NOCRYPT	emlen.h	23;"	d
NOP	telnet.h	56;"	d
NOTE_DATA	emlen.h	/^typedef struct note_data NOTE_DATA;$/;"	t	typeref:struct:note_data
NOTE_FILE	emlen.h	1162;"	d
NOTE_STAMP_LIST	emlen.h	/^typedef struct note_stamp_list NOTE_STAMP_LIST;$/;"	t	typeref:struct:note_stamp_list
NOTIFY	emlen.h	2964;"	d
NOT_WORN	emlen.h	2955;"	d
NO_HUNGER	emlen.h	967;"	d
NO_PKILL	emlen.h	970;"	d
NO_THIRST	emlen.h	966;"	d
NSLC	telnet.h	200;"	d
NST	emlen.h	2858;"	d
NTELOPTS	telnet.h	125;"	d
NTEXT	emlen.h	442;"	d
NULL_FILE	emlen.h	1153;"	d
NULL_FILE	emlen.h	1158;"	d
NUM	emlen.h	3103;"	d
OBJECT	emlen.h	3091;"	d
OBJ_ANYSIZE	emlen.h	2937;"	d
OBJ_BOAT	emlen.h	/^typedef struct obj_boat OBJ_BOAT;$/;"	t	typeref:struct:obj_boat
OBJ_FITABLE	emlen.h	2936;"	d
OBJ_FITS	emlen.h	2938;"	d
OBJ_FUNCTION	object.h	11;"	d
OBJ_PROTOTYPE	emlen.h	/^typedef struct obj_proto_data OBJ_PROTOTYPE;$/;"	t	typeref:struct:obj_proto_data
OBJ_TOO_BIG	emlen.h	2934;"	d
OBJ_TOO_SMALL	emlen.h	2935;"	d
OBJ_UPDATE	emlen.h	3140;"	d
OBJ_VNUM_BLOOD	emlen.h	609;"	d
OBJ_VNUM_CORPSE_NPC	emlen.h	602;"	d
OBJ_VNUM_CORPSE_PC	emlen.h	603;"	d
OBJ_VNUM_INTESTINES	emlen.h	608;"	d
OBJ_VNUM_SEVERED_HEAD	emlen.h	604;"	d
OBJ_VNUM_SLICED_ARM	emlen.h	606;"	d
OBJ_VNUM_SLICED_LEG	emlen.h	607;"	d
OBJ_VNUM_TORN_HEART	emlen.h	605;"	d
OLD_ENV_VALUE	telnet.h	236;"	d
OLD_ENV_VAR	telnet.h	235;"	d
ONE_COMBAT_ROUND	emlen.h	3082;"	d
ONE_SECOND	emlen.h	3083;"	d
OOSTR	emlen.h	2852;"	d
OPERATING_ROOM	alien.c	8;"	d	file:
OPTIONAL_DATA	emlen.h	/^typedef struct optional_data OPTIONAL_DATA;$/;"	t	typeref:struct:optional_data
O_NONBLOCK	comm.c	741;"	d	file:
PC	emlen.h	3051;"	d
PERCENTAGE	hnd.c	/^PERCENTAGE (int amount, int max)$/;"	f
PERCENT_STRUCT	emlen.h	/^typedef struct dam_moves PERCENT_STRUCT;$/;"	t	typeref:struct:dam_moves
PERS	emlen.h	2962;"	d
PIC_WAIT	emlen.h	7;"	d
PKF	emlen.h	2389;"	d
PLAYER	emlen.h	3092;"	d
PLAYERBASE_DATA	emlen.h	/^typedef struct playerbase_data PLAYERBASE_DATA;$/;"	t	typeref:struct:playerbase_data
PLAYER_DIR	emlen.h	1151;"	d
PLAYER_DIR	emlen.h	1155;"	d
PLAYER_DIR_2	emlen.h	1152;"	d
PLAYER_DIR_2	emlen.h	1156;"	d
PLR_ANSI	emlen.h	1124;"	d
PLR_ASCII	emlen.h	32;"	d
PLR_ASSIST	emlen.h	1117;"	d
PLR_AUTOEXIT	emlen.h	1109;"	d
PLR_AUTOGOLD	emlen.h	1108;"	d
PLR_AUTOLOOT	emlen.h	1110;"	d
PLR_AUTOSAC	emlen.h	1111;"	d
PLR_AUTOSPLIT	emlen.h	1120;"	d
PLR_BLANK	emlen.h	1112;"	d
PLR_BLANKPROMPT	emlen.h	1127;"	d
PLR_BRIEF	emlen.h	1113;"	d
PLR_COMBINE	emlen.h	1114;"	d
PLR_DENY	emlen.h	1074;"	d
PLR_FREEZE	emlen.h	1075;"	d
PLR_HOLYLAG	emlen.h	1079;"	d
PLR_HOLYLIGHT	emlen.h	1072;"	d
PLR_HOLYPEACE	emlen.h	1076;"	d
PLR_HOLYWALK	emlen.h	1078;"	d
PLR_LOG	emlen.h	1073;"	d
PLR_PROMPT	emlen.h	1115;"	d
PLR_PROMPT_UP	emlen.h	1128;"	d
PLR_SILENCE	emlen.h	1122;"	d
PLR_TELNET_GA	emlen.h	1116;"	d
PLR_VT100	emlen.h	1125;"	d
POLL_DATA	poll.h	/^typedef struct poll_data POLL_DATA;$/;"	t	typeref:struct:poll_data
POLL_FILE	poll.h	2;"	d
POLL_STAMP_LIST	poll.h	/^typedef struct poll_stamp_list POLL_STAMP_LIST;$/;"	t	typeref:struct:poll_stamp_list
POSITION_BACKSTAB	emlen.h	1063;"	d
POSITION_BASHED	emlen.h	1057;"	d
POSITION_CASTING	emlen.h	1066;"	d
POSITION_CIRCLE	emlen.h	1056;"	d
POSITION_DEAD	emlen.h	1049;"	d
POSITION_FALLING	emlen.h	1059;"	d
POSITION_FIGHTING	emlen.h	1055;"	d
POSITION_GROUNDFIGHTING	emlen.h	1058;"	d
POSITION_INCAP	emlen.h	1051;"	d
POSITION_INVEST	emlen.h	1065;"	d
POSITION_MEDITATING	emlen.h	1064;"	d
POSITION_MORTAL	emlen.h	1050;"	d
POSITION_RESTING	emlen.h	1054;"	d
POSITION_RUNNING	emlen.h	1061;"	d
POSITION_SEARCHING	emlen.h	1062;"	d
POSITION_SLEEPING	emlen.h	1053;"	d
POSITION_STANDING	emlen.h	1060;"	d
POSITION_STOPCAST	emlen.h	1067;"	d
POSITION_STUNNED	emlen.h	1052;"	d
POWER	emlen.h	/^typedef struct power_data POWER;$/;"	t	typeref:struct:power_data
PROFESSION_LIST_ATURION	emlen.h	2434;"	d
PROFESSION_LIST_HUMANOID	emlen.h	2432;"	d
PROF_ARCHMAGE	emlen.h	2423;"	d
PROF_ASSASSIN	emlen.h	2424;"	d
PROF_ATURION_ENGINEER	emlen.h	2429;"	d
PROF_ATURION_HUNTER	emlen.h	2428;"	d
PROF_ATURION_PHILOSOPHER	emlen.h	2430;"	d
PROF_BARBARIAN	emlen.h	2419;"	d
PROF_BARD	emlen.h	2426;"	d
PROF_DRUID	emlen.h	2422;"	d
PROF_HEALER	emlen.h	2416;"	d
PROF_KNIGHT	emlen.h	2418;"	d
PROF_MONK	emlen.h	2425;"	d
PROF_PALADIN	emlen.h	2421;"	d
PROF_RANGER	emlen.h	2420;"	d
PROF_WIZARD	emlen.h	2417;"	d
PULSE_AREA	emlen.h	186;"	d
PULSE_FIELD	emlen.h	187;"	d
PULSE_MOBILE	emlen.h	184;"	d
PULSE_PER_SECOND	emlen.h	182;"	d
PULSE_TICK	emlen.h	185;"	d
PULSE_VIOLENCE	emlen.h	183;"	d
PURPLE	emlen.h	417;"	d
QUEST_ITEM1	quest.c	51;"	d	file:
QUEST_ITEM2	quest.c	52;"	d	file:
QUEST_ITEM3	quest.c	53;"	d	file:
QUEST_ITEM4	quest.c	54;"	d	file:
QUEST_ITEM5	quest.c	55;"	d	file:
QUEST_OBJQUEST1	quest.c	62;"	d	file:
QUEST_OBJQUEST2	quest.c	63;"	d	file:
QUEST_OBJQUEST3	quest.c	64;"	d	file:
QUEST_OBJQUEST4	quest.c	65;"	d	file:
QUEST_OBJQUEST5	quest.c	66;"	d	file:
R	cmd.c	29;"	d	file:
RACE_COUNT	emlen.h	151;"	d
RAND	emlen.h	3113;"	d
RATING_DATA	emlen.h	/^typedef struct rating_data RATING_DATA;$/;"	t	typeref:struct:rating_data
RC_EVILRACE	emlen.h	350;"	d
RC_GOODRACE	emlen.h	349;"	d
RC_NEUTRALRACE	emlen.h	351;"	d
READ_YESNO	power.c	18;"	d	file:
REALCHAR_DATA	emlen.h	/^typedef struct pc_data REALCHAR_DATA;$/;"	t	typeref:struct:pc_data
RED	emlen.h	413;"	d
REMORT_DAM	emlen.h	2202;"	d
REMORT_DAM_AMOUNT	emlen.h	2209;"	d
REMORT_HP	emlen.h	2204;"	d
REMORT_HP_AMOUNT	emlen.h	2211;"	d
REMORT_MANA	emlen.h	2206;"	d
REMORT_MANA_AMOUNT	emlen.h	2213;"	d
REMORT_MOVE	emlen.h	2205;"	d
REMORT_MOVE_AMOUNT	emlen.h	2212;"	d
REMORT_PRAC	emlen.h	2203;"	d
REMORT_PRAC_AMOUNT	emlen.h	2210;"	d
REMOVE_ALL_SPELLS	emlen.h	2505;"	d
REMOVE_BIT	emlen.h	2849;"	d
REPAIRS_FREE	emlen.h	487;"	d
REPAIRS_ONE	emlen.h	488;"	d
REPAIRS_TWO	emlen.h	489;"	d
RESET_DATA	emlen.h	/^typedef struct reset_data RESET_DATA;$/;"	t	typeref:struct:reset_data
RESET_LOC_INOBJ	emlen.h	2690;"	d
RESET_LOC_INROOM	emlen.h	2692;"	d
RESET_LOC_ONOBJ	emlen.h	2691;"	d
RESET_LOC_PREVOBJ	emlen.h	2693;"	d
RIDING	emlen.h	2836;"	d
RIGHTARROW	emlen.h	434;"	d
RNAME	emlen.h	2851;"	d
ROOM2_ANCIENTROAD	emlen.h	854;"	d
ROOM2_EARTHCAVE_D	emlen.h	853;"	d
ROOM2_FIELD_D	emlen.h	851;"	d
ROOM2_FOREST_D	emlen.h	849;"	d
ROOM2_HILL_D	emlen.h	855;"	d
ROOM2_LIGHTF_D	emlen.h	852;"	d
ROOM2_OCEAN_D	emlen.h	848;"	d
ROOM2_RFOREST_D	emlen.h	850;"	d
ROOM_ACIDSPRAY	emlen.h	826;"	d
ROOM_ARROWTRAP	emlen.h	838;"	d
ROOM_AVALANCHE	emlen.h	834;"	d
ROOM_CAVERNS	emlen.h	809;"	d
ROOM_CLANSTORE	emlen.h	845;"	d
ROOM_DARK	emlen.h	805;"	d
ROOM_DATA	emlen.h	/^typedef struct room_data ROOM_DATA;$/;"	t	typeref:struct:room_data
ROOM_EXTRAHEAL	emlen.h	830;"	d
ROOM_EXTRAMANA	emlen.h	831;"	d
ROOM_FALLSFAST	emlen.h	827;"	d
ROOM_FIRETRAP	emlen.h	836;"	d
ROOM_FUNCTION	room.h	10;"	d
ROOM_GASTRAPONE	emlen.h	841;"	d
ROOM_GASTRAPTWO	emlen.h	842;"	d
ROOM_GYSERTRAP	emlen.h	833;"	d
ROOM_INDOORS	emlen.h	808;"	d
ROOM_ISVEHICLE	emlen.h	829;"	d
ROOM_MANADRAIN	emlen.h	835;"	d
ROOM_MORE	emlen.h	/^typedef struct room_extended ROOM_MORE;$/;"	t	typeref:struct:room_extended
ROOM_MOVING	emlen.h	819;"	d
ROOM_NOHEAR	emlen.h	813;"	d
ROOM_NOISY	emlen.h	814;"	d
ROOM_NOMAGIC	emlen.h	820;"	d
ROOM_NONE	emlen.h	2975;"	d
ROOM_NOSUMMON	emlen.h	817;"	d
ROOM_NO_MOB	emlen.h	806;"	d
ROOM_NO_RECALL	emlen.h	812;"	d
ROOM_PET_SHOP	emlen.h	810;"	d
ROOM_POISONTRAP	emlen.h	837;"	d
ROOM_ROCKTRAP	emlen.h	839;"	d
ROOM_SILENCE	emlen.h	821;"	d
ROOM_SPIKETRAP	emlen.h	840;"	d
ROOM_UNTRACKABLE	emlen.h	818;"	d
ROOM_VNUM_ARENA	emlen.h	610;"	d
R_MARK	emlen.h	816;"	d
SA	emlen.h	/^typedef struct scriptassoc SA;$/;"	t	typeref:struct:scriptassoc
SAME_ALIGN	emlen.h	1726;"	d
SAY	emlen.h	3075;"	d
SB	telnet.h	47;"	d
SCKEY	db2.c	1296;"	d	file:
SCKEY	db2.c	1299;"	d	file:
SCRIPT_DAT	emlen.h	/^typedef struct script_dat SCRIPT_DAT;$/;"	t	typeref:struct:script_dat
SCRIPT_DATA	emlen.h	/^typedef struct script_data SCRIPT_DATA;$/;"	t	typeref:struct:script_data
SCRIPT_INFO	script.h	/^typedef struct script_info SCRIPT_INFO;	\/* Holds info of a single trigger running *\/$/;"	t	typeref:struct:script_info
SCRIPT_INT	emlen.h	3143;"	d
SD	emlen.h	2164;"	d
SE	telnet.h	57;"	d
SEARCH_INV_FIRST	emlen.h	620;"	d
SEARCH_ROOM_FIRST	emlen.h	622;"	d
SECONDARY_PROF_LIST	emlen.h	2433;"	d
SECONDDICE	emlen.h	2917;"	d
SECT_AIR	emlen.h	894;"	d
SECT_CITY	emlen.h	886;"	d
SECT_DESERT	emlen.h	895;"	d
SECT_FIELD	emlen.h	887;"	d
SECT_FOREST	emlen.h	888;"	d
SECT_HILLS	emlen.h	889;"	d
SECT_ICE	emlen.h	899;"	d
SECT_INSIDE	emlen.h	885;"	d
SECT_JAVA	emlen.h	898;"	d
SECT_MARSH	emlen.h	900;"	d
SECT_MAX	emlen.h	901;"	d
SECT_MOUNTAIN	emlen.h	890;"	d
SECT_SNOW	emlen.h	896;"	d
SECT_TROPICAL	emlen.h	897;"	d
SECT_UNDERWATER	emlen.h	893;"	d
SECT_WATER_NOSWIM	emlen.h	892;"	d
SECT_WATER_SWIM	emlen.h	891;"	d
SET	emlen.h	3081;"	d
SET_BIT	emlen.h	2848;"	d
SET_OBJ_SIZE	emlen.h	2932;"	d
SEX	emlen.h	2875;"	d
SEX_FEMALE	emlen.h	596;"	d
SEX_MALE	emlen.h	595;"	d
SEX_NEUTRAL	emlen.h	594;"	d
SEX_NONE	emlen.h	2970;"	d
SHELL	emlen.h	/^typedef struct shell_command SHELL;$/;"	t	typeref:struct:shell_command
SHOP_DATA	emlen.h	/^typedef struct shop_data SHOP_DATA;$/;"	t	typeref:struct:shop_data
SHOW_TO_OTHERS	emlen.h	3098;"	d
SHOW_TO_ROOM	emlen.h	3097;"	d
SINGLE_OBJECT	emlen.h	/^typedef struct obj_data SINGLE_OBJECT;$/;"	t	typeref:struct:obj_data
SINGLE_TRIGGER	script.h	/^typedef struct single_trigger SINGLE_TRIGGER;	\/* Holds triggers *\/$/;"	t	typeref:struct:single_trigger
SKEY	db2.c	1294;"	d	file:
SKEY	sv.c	1229;"	d	file:
SKEY	sv.c	1231;"	d	file:
SKILL_COUNT	emlen.h	145;"	d
SKY_CLOUDLESS	emlen.h	203;"	d
SKY_CLOUDY	emlen.h	204;"	d
SKY_FOGGY	emlen.h	207;"	d
SKY_LIGHTNING	emlen.h	206;"	d
SKY_RAINING	emlen.h	205;"	d
SLC_ABORT	telnet.h	187;"	d
SLC_ACK	telnet.h	231;"	d
SLC_AO	telnet.h	184;"	d
SLC_AYT	telnet.h	185;"	d
SLC_BRK	telnet.h	182;"	d
SLC_CANTCHANGE	telnet.h	222;"	d
SLC_DEFAULT	telnet.h	224;"	d
SLC_EC	telnet.h	190;"	d
SLC_EL	telnet.h	191;"	d
SLC_EOF	telnet.h	188;"	d
SLC_EOR	telnet.h	186;"	d
SLC_EW	telnet.h	192;"	d
SLC_FLAGS	telnet.h	228;"	d
SLC_FLUSHIN	telnet.h	232;"	d
SLC_FLUSHOUT	telnet.h	233;"	d
SLC_FORW1	telnet.h	197;"	d
SLC_FORW2	telnet.h	198;"	d
SLC_FUNC	telnet.h	227;"	d
SLC_IP	telnet.h	183;"	d
SLC_LEVELBITS	telnet.h	225;"	d
SLC_LNEXT	telnet.h	194;"	d
SLC_NAME	telnet.h	219;"	d
SLC_NAMELIST	telnet.h	206;"	d
SLC_NAMES	telnet.h	215;"	d
SLC_NAME_OK	telnet.h	218;"	d
SLC_NOSUPPORT	telnet.h	221;"	d
SLC_RP	telnet.h	193;"	d
SLC_SUSP	telnet.h	189;"	d
SLC_SYNCH	telnet.h	181;"	d
SLC_VALUE	telnet.h	229;"	d
SLC_VARIABLE	telnet.h	223;"	d
SLC_XOFF	telnet.h	196;"	d
SLC_XON	telnet.h	195;"	d
SML_LENGTH	emlen.h	131;"	d
SOCIAL	emlen.h	/^typedef struct social_type SOCIAL;$/;"	t	typeref:struct:social_type
SOCIAL	emlen.h	3080;"	d
SOCIAL_TO	emlen.h	3079;"	d
SOLVED_EXISTENCE	mob_101.c	5;"	d	file:
SOLVED_EXISTENCE	mob_1029.c	5;"	d	file:
SPEC_FUNCTION	emlen.h	/^typedef bool SPEC_FUNCTION (CHAR_DATA * ch);$/;"	t
SPELL_ACID	emlen.h	289;"	d
SPELL_ADD_MOVE	emlen.h	286;"	d
SPELL_ALL_IN_ROOM	emlen.h	240;"	d
SPELL_ARMOR_1_2	emlen.h	270;"	d
SPELL_ARMOR_1_4	emlen.h	271;"	d
SPELL_DATA	emlen.h	/^typedef struct spell_data SPELL_DATA;$/;"	t	typeref:struct:spell_data
SPELL_DISPEL_MAGIC	emlen.h	248;"	d
SPELL_FAIL_1_2	emlen.h	262;"	d
SPELL_FAIL_1_3	emlen.h	265;"	d
SPELL_FAIL_1_4	emlen.h	266;"	d
SPELL_FIRE	emlen.h	290;"	d
SPELL_HALVED_SAVE	emlen.h	275;"	d
SPELL_HASH	emlen.h	2982;"	d
SPELL_HEALS_DAM	emlen.h	242;"	d
SPELL_HURT_EVIL	emlen.h	249;"	d
SPELL_HURT_GOOD	emlen.h	250;"	d
SPELL_HURT_UNDEAD	emlen.h	251;"	d
SPELL_IDENTIFY	emlen.h	253;"	d
SPELL_LOCATE_OBJECT	emlen.h	254;"	d
SPELL_LOCATE_PERSON	emlen.h	258;"	d
SPELL_MESSAGE	emlen.h	238;"	d
SPELL_MODIFY_OBJECT	emlen.h	252;"	d
SPELL_NOT_MOB	emlen.h	281;"	d
SPELL_NOT_SELF	emlen.h	278;"	d
SPELL_OBJ_TO_ROOM	emlen.h	282;"	d
SPELL_ONLY_GROUP	emlen.h	291;"	d
SPELL_ONLY_MULTI_MOBS	emlen.h	272;"	d
SPELL_ONLY_NOT_GROUP	emlen.h	294;"	d
SPELL_RAISE_UNDEAD	emlen.h	280;"	d
SPELL_RECALL	emlen.h	261;"	d
SPELL_REMOVES_BIT	emlen.h	241;"	d
SPELL_SCRY	emlen.h	255;"	d
SPELL_SUMMON	emlen.h	245;"	d
SPELL_TELEPORT	emlen.h	239;"	d
SPELL_TWO_SAVES	emlen.h	267;"	d
START_FIGHTING	emlen.h	3071;"	d
STD_LENGTH	emlen.h	128;"	d
STOP_ALL_IN_ROOM_FIGHTING	emlen.h	3070;"	d
STOP_BOTH_FIGHTING	emlen.h	3069;"	d
STOP_FIGHTING	emlen.h	3068;"	d
STOREDIV	emlen.h	172;"	d
STR	emlen.h	2855;"	d
STRENGTH	emlen.h	3043;"	d
STRIKE_ARMS	emlen.h	1420;"	d
STRIKE_BODY	emlen.h	1417;"	d
STRIKE_HEAD	emlen.h	1418;"	d
STRIKE_LEGS	emlen.h	1419;"	d
STRING	emlen.h	3090;"	d
STRING_HITS	emlen.h	2905;"	d
STRING_MOVES	emlen.h	2907;"	d
STR_I	emlen.h	41;"	d
ST_CRLF	shell.c	/^const int ST_CRLF = 9;$/;"	v
ST_DATA	shell.c	/^const int ST_DATA = 0;$/;"	v
ST_DO	shell.c	/^const int ST_DO = 7;$/;"	v
ST_DONT	shell.c	/^const int ST_DONT = 8;$/;"	v
ST_HOW	shell.c	/^const int ST_HOW = 4;$/;"	v
ST_IAC	shell.c	/^const int ST_IAC = 1;$/;"	v
ST_IP	shell.c	/^const int ST_IP = 10;$/;"	v
ST_OPT	shell.c	/^const int ST_OPT = 3;$/;"	v
ST_SE	shell.c	/^const int ST_SE = 2;$/;"	v
ST_WILL	shell.c	/^const int ST_WILL = 5;$/;"	v
ST_WONT	shell.c	/^const int ST_WONT = 6;$/;"	v
SUBHIT	dam.c	/^SUBHIT (CHAR_DATA * ch, int i)$/;"	f
SUBMOVE	dam.c	/^SUBMOVE (CHAR_DATA * ch, int i)$/;"	f
SUCK_ALL_MANA	emlen.h	2503;"	d
SUCK_HALF_HITS	emlen.h	2506;"	d
SUCK_HALF_MANA	emlen.h	2504;"	d
SUCK_HALF_MOVES	emlen.h	2507;"	d
SUN_DARK	emlen.h	192;"	d
SUN_LIGHT	emlen.h	194;"	d
SUN_RISE	emlen.h	193;"	d
SUN_SET	emlen.h	195;"	d
SUSP	telnet.h	60;"	d
SYNCH	telnet.h	63;"	d
S_ALL	emlen.h	2455;"	d
S_ARCHMAGE	emlen.h	2447;"	d
S_ASSASSIN	emlen.h	2448;"	d
S_BARBARIAN	emlen.h	2443;"	d
S_BARD	emlen.h	2450;"	d
S_DRUID	emlen.h	2446;"	d
S_ENGINEER	emlen.h	2452;"	d
S_HEALER	emlen.h	2440;"	d
S_HUNTER	emlen.h	2451;"	d
S_KNIGHT	emlen.h	2442;"	d
S_MONK	emlen.h	2449;"	d
S_PALADIN	emlen.h	2445;"	d
S_PHILOSOPHER	emlen.h	2453;"	d
S_RANGER	emlen.h	2444;"	d
S_WIZARD	emlen.h	2441;"	d
TAB	emlen.h	444;"	d
TAR_ALL_IN_ROOM	emlen.h	1147;"	d
TAR_CHAR_DEFENSIVE	emlen.h	1144;"	d
TAR_CHAR_OFFENSIVE	emlen.h	1143;"	d
TAR_CHAR_SELF	emlen.h	1145;"	d
TAR_IGNORE	emlen.h	1142;"	d
TAR_OBJ_INV	emlen.h	1146;"	d
TAR_OBJ_ROOM	emlen.h	1148;"	d
TATTACKED	script.h	25;"	d
TAT_HOUR	script.h	18;"	d
TCOMMAND	script.h	10;"	d
TCREATED	script.h	9;"	d
TDESTROYED	script.h	12;"	d
TDROPPED	script.h	20;"	d
TELCMD	telnet.h	79;"	d
TELCMD_FIRST	telnet.h	75;"	d
TELCMD_LAST	telnet.h	76;"	d
TELCMD_OK	telnet.h	77;"	d
TELL	emlen.h	3077;"	d
TELOPT	telnet.h	143;"	d
TELOPT_3270REGIME	telnet.h	111;"	d
TELOPT_AUTHENTICATION	telnet.h	119;"	d
TELOPT_BINARY	telnet.h	82;"	d
TELOPT_BM	telnet.h	101;"	d
TELOPT_DET	telnet.h	102;"	d
TELOPT_ECHO	telnet.h	83;"	d
TELOPT_ENCRYPT	telnet.h	120;"	d
TELOPT_EOR	telnet.h	107;"	d
TELOPT_EXOPL	telnet.h	122;"	d
TELOPT_FIRST	telnet.h	140;"	d
TELOPT_LAST	telnet.h	141;"	d
TELOPT_LFLOW	telnet.h	115;"	d
TELOPT_LINEMODE	telnet.h	116;"	d
TELOPT_LOGOUT	telnet.h	100;"	d
TELOPT_NAMS	telnet.h	86;"	d
TELOPT_NAOCRD	telnet.h	92;"	d
TELOPT_NAOFFD	telnet.h	95;"	d
TELOPT_NAOHTD	telnet.h	94;"	d
TELOPT_NAOHTS	telnet.h	93;"	d
TELOPT_NAOL	telnet.h	90;"	d
TELOPT_NAOLFD	telnet.h	98;"	d
TELOPT_NAOP	telnet.h	91;"	d
TELOPT_NAOVTD	telnet.h	97;"	d
TELOPT_NAOVTS	telnet.h	96;"	d
TELOPT_NAWS	telnet.h	113;"	d
TELOPT_NEW_ENVIRON	telnet.h	121;"	d
TELOPT_OK	telnet.h	142;"	d
TELOPT_OLD_ENVIRON	telnet.h	118;"	d
TELOPT_OUTMRK	telnet.h	109;"	d
TELOPT_RCP	telnet.h	84;"	d
TELOPT_RCTE	telnet.h	89;"	d
TELOPT_SGA	telnet.h	85;"	d
TELOPT_SNDLOC	telnet.h	105;"	d
TELOPT_STATUS	telnet.h	87;"	d
TELOPT_SUPDUP	telnet.h	103;"	d
TELOPT_SUPDUPOUTPUT	telnet.h	104;"	d
TELOPT_TM	telnet.h	88;"	d
TELOPT_TSPEED	telnet.h	114;"	d
TELOPT_TTYLOC	telnet.h	110;"	d
TELOPT_TTYPE	telnet.h	106;"	d
TELOPT_TUID	telnet.h	108;"	d
TELOPT_X3PAD	telnet.h	112;"	d
TELOPT_XASCII	telnet.h	99;"	d
TELOPT_XDISPLOC	telnet.h	117;"	d
TELQUAL_INFO	telnet.h	149;"	d
TELQUAL_IS	telnet.h	147;"	d
TELQUAL_NAME	telnet.h	151;"	d
TELQUAL_REPLY	telnet.h	150;"	d
TELQUAL_SEND	telnet.h	148;"	d
TEMPFLAG	emlen.h	3100;"	d
TEMPSTRING	emlen.h	3089;"	d
TEMP_STR	emlen.h	/^typedef struct temp_str TEMP_STR;$/;"	t	typeref:struct:temp_str
TENTERS	script.h	7;"	d
TEQUIPPED	script.h	24;"	d
TEVERY_HOUR	script.h	15;"	d
TEVERY_QUICKTICK	script.h	16;"	d
TEVERY_REGENTICK	script.h	17;"	d
TGIVEN	script.h	19;"	d
TGIVEN_MONEY	script.h	27;"	d
TIME_INFO_DATA	emlen.h	/^typedef struct time_info_data TIME_INFO_DATA;$/;"	t	typeref:struct:time_info_data
TLEAVES	script.h	8;"	d
TMAX_TRIGGERS	script.h	29;"	d
TMOVES	script.h	11;"	d
TOBJ_SACCED	script.h	26;"	d
TOGGLE_BIT	emlen.h	2850;"	d
TOOL_FLASH_POWDER	emlen.h	696;"	d
TOOL_LOCKPICK	emlen.h	695;"	d
TOOL_TINDERBOX	emlen.h	694;"	d
TOPTEN_DATA	emlen.h	/^typedef struct topten_data TOPTEN_DATA;$/;"	t	typeref:struct:topten_data
TOP_LEVEL	emlen.h	148;"	d
TOROOM	emlen.h	2862;"	d
TO_BOTH	emlen.h	1729;"	d
TO_CHAR	emlen.h	343;"	d
TO_CHAR_SPAM	emlen.h	347;"	d
TO_EVIL	emlen.h	1728;"	d
TO_FREE	emlen.h	/^typedef struct to_free TO_FREE;$/;"	t	typeref:struct:to_free
TO_GOOD	emlen.h	1727;"	d
TO_NOTVICT	emlen.h	341;"	d
TO_NOTVICT_SPAM	emlen.h	344;"	d
TO_ROOM	emlen.h	340;"	d
TO_ROOM_SPAM	emlen.h	345;"	d
TO_VICT	emlen.h	342;"	d
TO_VICT_SPAM	emlen.h	346;"	d
TPERS	emlen.h	2963;"	d
TPS	emlen.h	3048;"	d
TRACK_DATA	emlen.h	/^typedef struct track_data TRACK_DATA;$/;"	t	typeref:struct:track_data
TRANSPORT_UPD	emlen.h	3138;"	d
TRIGGER_DATA	emlen.h	/^typedef struct trigger_data TRIGGER_DATA;$/;"	t	typeref:struct:trigger_data
TRIGGY_DATA	emlen.h	/^typedef struct triggy TRIGGY_DATA;$/;"	t	typeref:struct:triggy
TRUE	emlen.h	27;"	d
TSAYS	script.h	13;"	d
TTELLS	script.h	14;"	d
TYPE_EXPLODE	emlen.h	397;"	d
TYPE_HIT	emlen.h	393;"	d
TYPE_PIERCE	emlen.h	395;"	d
TYPE_POUND	emlen.h	398;"	d
TYPE_SHOT	emlen.h	400;"	d
TYPE_SLASH	emlen.h	394;"	d
TYPE_SUCTION	emlen.h	399;"	d
TYPE_UNDEFINED	emlen.h	392;"	d
TYPE_WHIP	emlen.h	396;"	d
UMAX	emlen.h	2843;"	d
UMIN	emlen.h	2842;"	d
UNMARK	ar.c	148;"	d	file:
UNMARK	emlen.h	2860;"	d
UPARROW	emlen.h	435;"	d
UPPER	emlen.h	2846;"	d
URANGE	emlen.h	2844;"	d
VALID_EDGE	emlen.h	2866;"	d
VARIABLE_DATA	emlen.h	/^typedef struct variable_data VARIABLE_DATA;$/;"	t	typeref:struct:variable_data
VERSION_STR	mush.h	2;"	d
VERSION_STR	mush.h	4;"	d
VIEW_MOBS	emlen.h	969;"	d
VNUM_WAITONE	emlen.h	611;"	d
VNUM_WAITTWO	emlen.h	612;"	d
VOTING_DATA	emlen.h	/^typedef struct voting_data VOTING_DATA;$/;"	t	typeref:struct:voting_data
WAIT_STATE	emlen.h	2904;"	d
WAIT_TYPE_CHAR_TICK	emlen.h	2048;"	d
WAIT_TYPE_COMBAT_TICK	emlen.h	2049;"	d
WAIT_TYPE_PULSE	emlen.h	2051;"	d
WAIT_TYPE_SMALL_TICK	emlen.h	2050;"	d
WEAR_ABOUT	emlen.h	921;"	d
WEAR_ANKLE_1	emlen.h	940;"	d
WEAR_ANKLE_2	emlen.h	941;"	d
WEAR_ARMS	emlen.h	919;"	d
WEAR_BACK	emlen.h	922;"	d
WEAR_BELT_1	emlen.h	928;"	d
WEAR_BELT_2	emlen.h	929;"	d
WEAR_BELT_3	emlen.h	930;"	d
WEAR_BELT_4	emlen.h	931;"	d
WEAR_BELT_5	emlen.h	932;"	d
WEAR_BODY	emlen.h	914;"	d
WEAR_EAR_1	emlen.h	938;"	d
WEAR_EAR_2	emlen.h	939;"	d
WEAR_ELBOW_1	emlen.h	944;"	d
WEAR_ELBOW_2	emlen.h	945;"	d
WEAR_EYEPATCH	emlen.h	947;"	d
WEAR_FACE	emlen.h	937;"	d
WEAR_FEET	emlen.h	917;"	d
WEAR_FINGER_L	emlen.h	910;"	d
WEAR_FINGER_R	emlen.h	911;"	d
WEAR_FLOAT_1	emlen.h	926;"	d
WEAR_FLOAT_2	emlen.h	927;"	d
WEAR_HANDS	emlen.h	918;"	d
WEAR_HEAD	emlen.h	915;"	d
WEAR_HOLD_1	emlen.h	933;"	d
WEAR_HOLD_2	emlen.h	934;"	d
WEAR_KNEE_1	emlen.h	942;"	d
WEAR_KNEE_2	emlen.h	943;"	d
WEAR_LEGS	emlen.h	916;"	d
WEAR_NECK_1	emlen.h	912;"	d
WEAR_NECK_2	emlen.h	913;"	d
WEAR_NONE	emlen.h	909;"	d
WEAR_SHIELD	emlen.h	920;"	d
WEAR_SHOULDER_L	emlen.h	935;"	d
WEAR_SHOULDER_R	emlen.h	936;"	d
WEAR_TATTOO	emlen.h	946;"	d
WEAR_WAIST	emlen.h	923;"	d
WEAR_WRIST_L	emlen.h	924;"	d
WEAR_WRIST_R	emlen.h	925;"	d
WEATHER_DATA	emlen.h	/^typedef struct weather_data WEATHER_DATA;$/;"	t	typeref:struct:weather_data
WILL	telnet.h	46;"	d
WISDOM	emlen.h	3045;"	d
WIS_I	emlen.h	43;"	d
WIZ_NOTIFY	emlen.h	1085;"	d
WIZ_NOTIFY_1	emlen.h	1086;"	d
WIZ_NOTIFY_2	emlen.h	1087;"	d
WIZ_NOTIFY_BUG	emlen.h	1090;"	d
WIZ_NOTIFY_DEATH	emlen.h	1089;"	d
WIZ_NOTIFY_LOG	emlen.h	1091;"	d
WIZ_NOTIFY_LOGIN	emlen.h	1088;"	d
WIZ_NOTIFY_SCRIPT	emlen.h	1092;"	d
WONT	telnet.h	45;"	d
WORDS	int.c	803;"	d	file:
WORKS_ON_MOBS_ONLY	emlen.h	3085;"	d
WORKS_ON_PLAYERS_ONLY	emlen.h	3086;"	d
WRD	int.c	/^            typedef struct wrd WRD; struct wrd$/;"	t	typeref:struct:wrd	file:
WRITE	emlen.h	3096;"	d
WRITELN	emlen.h	3095;"	d
WRITE_AUTH	emlen.h	984;"	d
XPOS	hnd.c	740;"	d	file:
YELLOW	emlen.h	415;"	d
YES	emlen.h	30;"	d
YPOS	hnd.c	741;"	d	file:
_ARPA_TELNET_H	telnet.h	37;"	d
a	emlen.h	/^  char a;			\/* Overhead mapping ascii override *\/$/;"	m	struct:room_data
a_pierce	emlen.h	/^  short a_pierce;$/;"	m	struct:material_data
a_pound	emlen.h	/^  short a_pound;$/;"	m	struct:material_data
a_slash	emlen.h	/^  short a_slash;		\/* This armorval for slash *\/$/;"	m	struct:material_data
above	emlen.h	/^  int above;			\/* v2 *\/$/;"	m	struct:item_climbable
abuf	emlen.h	/^  char abuf[100];		\/* Authorization buffer for in\/out *\/$/;"	m	struct:descriptor_data
accepted	emlen.h	/^  bool accepted;$/;"	m	struct:clanwar
accumulator	script.h	/^  int accumulator;		\/* Single register process *\/$/;"	m	struct:script_info
act	ansi_out.c	/^act (const char *format, CHAR_DATA * ch, const void *arg1, const void *arg2,$/;"	f
act	emlen.h	/^  int act;			\/* Action bits 1 *\/$/;"	m	struct:char_data
act	emlen.h	/^  int act;			\/* Action template *\/$/;"	m	struct:mob_proto_data
act2	emlen.h	/^  int act2;			\/* Player's act2, special bits *\/$/;"	m	struct:pc_data
act3	emlen.h	/^  int act3;			\/* Action template for act3 bit *\/$/;"	m	struct:mob_proto_data
act3	emlen.h	/^  int act3;			\/* act3 *\/$/;"	m	struct:pc_data
act3_bit_name	hnd.c	/^act3_bit_name (int zact)$/;"	f
act4	emlen.h	/^  int act4;			\/* Action template for act4 bit *\/$/;"	m	struct:mob_proto_data
act4	emlen.h	/^  int act4;			\/* act4 *\/$/;"	m	struct:pc_data
act4_bit_name	hnd.c	/^act4_bit_name (int zact)$/;"	f
act_1	def.c	/^const struct flag_data act_1[] = {$/;"	v	typeref:struct:flag_data
act_3	def.c	/^const struct flag_data act_3[] = {$/;"	v	typeref:struct:flag_data
act_4	def.c	/^const struct flag_data act_4[] = {$/;"	v	typeref:struct:flag_data
act_bit_name	hnd.c	/^act_bit_name (int zact)$/;"	f
act_code	emlen.h	/^  char act_code[5];$/;"	m	struct:color_data
act_name_bit	hnd.c	/^act_name_bit (char *buf)$/;"	f
act_to_ch_1	emlen.h	/^  char *act_to_ch_1;		\/* Shown to character when he\/she casts *\/$/;"	m	struct:spell_data
act_to_ch_2	emlen.h	/^  char *act_to_ch_2;		\/* Just another line to show to char *\/$/;"	m	struct:spell_data
act_to_non_java	combat.c	/^act_to_non_java (char *arg, CHAR_DATA * ch)$/;"	f
act_to_notvict_1	emlen.h	/^  char *act_to_notvict_1;	\/* To everyone in room besides char + vict *\/$/;"	m	struct:spell_data
act_to_notvict_2	emlen.h	/^  char *act_to_notvict_2;$/;"	m	struct:spell_data
act_to_vict_1	emlen.h	/^  char *act_to_vict_1;		\/* To victim *\/$/;"	m	struct:spell_data
act_to_vict_2	emlen.h	/^  char *act_to_vict_2;$/;"	m	struct:spell_data
action	emlen.h	/^  char *action[MAXALIAS];	\/* Action response *\/$/;"	m	struct:pc_data
action_descr	emlen.h	/^  char *action_descr[3];	\/* Action description, Aturion only *\/$/;"	m	struct:obj_proto_data
action_off	comm.c	/^bool action_off = FALSE;$/;"	v
actionname	emlen.h	/^  char *actionname[MAXALIAS];	\/* Action trigger *\/$/;"	m	struct:pc_data
active	emlen.h	/^  bool active;			\/*Is the script still active? *\/$/;"	m	struct:triggy
add_ansi	dam.c	/^add_ansi (CHAR_DATA * victim, COMBAT_FIELD * cfld)$/;"	f
add_color	comm.c	/^add_color (char *txt)$/;"	f
add_color_limited	comm.c	/^add_color_limited (char *txt)$/;"	f
add_damroll	look.c	/^add_damroll (CHAR_DATA * ch)$/;"	f
add_hitroll	look.c	/^add_hitroll (CHAR_DATA * ch)$/;"	f
add_level_bonuses	power.c	/^add_level_bonuses (CHAR_DATA * ch, int how_many)$/;"	f
add_newline	db2.c	/^char *add_newline (char *str)$/;"	f
add_read_note_stamp	note.c	/^add_read_note_stamp (CHAR_DATA * ch, time_t stamp)$/;"	f
add_read_poll_stamp	poll.c	/^add_read_poll_stamp (CHAR_DATA * ch, time_t stamp, short choice)$/;"	f
add_reset	oc.c	/^add_reset (ROOM_DATA * room, RESET_DATA * pReset, int idx)$/;"	f
add_room_to_list	yell.c	/^add_room_to_list (int vnum)$/;"	f
add_to_aggro_list	hnd.c	/^add_to_aggro_list (CHAR_DATA * ch)$/;"	f
add_to_combat_field	combat.c	/^add_to_combat_field (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
add_to_fighting_list	hnd.c	/^add_to_fighting_list (CHAR_DATA * ch)$/;"	f
add_to_list	db2.c	/^add_to_list (char *nm, DO_COMMAND * cmd, int pos, int lev, int log_lev,$/;"	f
add_to_stats	emlen.h	/^  bool add_to_stats;		\/* Remorts add stats? *\/$/;"	m	struct:power_data
add_who_entry	dam.c	/^add_who_entry (CHAR_DATA * ch, CHAR_DATA * wch)$/;"	f
addbitvector	emlen.h	/^  int addbitvector;		\/\/$/;"	m	struct:spell_data
addbitvector2	emlen.h	/^  int addbitvector2;		\/\/ These 4 replace bitvector and bitvector2$/;"	m	struct:spell_data
addoffense	fgt.c	/^addoffense (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
advance_level	upd.c	/^advance_level (CHAR_DATA * ch)$/;"	f
aedit	aedit.c	/^aedit (CHAR_DATA * ch, char *argy)$/;"	f
affect_bit_name	hnd.c	/^affect_bit_name (int vector)$/;"	f
affect_bit_name_two	hnd.c	/^affect_bit_name_two (int vector)$/;"	f
affect_bits	emlen.h	/^  int affect_bits;		\/* Natural abilities *\/$/;"	m	struct:race_data
affect_data	emlen.h	/^struct affect_data$/;"	s
affect_flags_2	def.c	/^const struct flag_data affect_flags_2[] = {$/;"	v	typeref:struct:flag_data
affect_flagss	def.c	/^const struct flag_data affect_flagss[] = {$/;"	v	typeref:struct:flag_data
affect_free	hnd.c	/^AFFECT_DATA *affect_free = NULL;$/;"	v
affect_join	hnd.c	/^affect_join (CHAR_DATA * ch, AFFECT_DATA * paf)$/;"	f
affect_loc_name	hnd.c	/^affect_loc_name (int location)$/;"	f
affect_modify	hnd.c	/^affect_modify (CHAR_DATA * ch, AFFECT_DATA * paf, bool fAdd, short flaggy)$/;"	f
affect_name_bit	hnd.c	/^affect_name_bit (char *buf)$/;"	f
affect_name_bit_two	hnd.c	/^affect_name_bit_two (char *buf)$/;"	f
affect_name_loc	hnd.c	/^affect_name_loc (char *name)$/;"	f
affect_remove	hnd.c	/^affect_remove (CHAR_DATA * ch, AFFECT_DATA * paf)$/;"	f
affect_strip	hnd.c	/^affect_strip (CHAR_DATA * ch, int sn)$/;"	f
affect_strip_bits	hnd.c	/^affect_strip_bits (CHAR_DATA * ch, int bits)$/;"	f
affect_to_char	hnd.c	/^affect_to_char (CHAR_DATA * ch, AFFECT_DATA * paf)$/;"	f
affect_worn	misc.c	/^affect_worn (CHAR_DATA * ch, int bit)$/;"	f
affected	emlen.h	/^  AFFECT_DATA *affected;	\/* Affected by these extra affects *\/$/;"	m	struct:obj_proto_data
affected	emlen.h	/^  AFFECT_DATA *affected;	\/* Linked list of affects *\/$/;"	m	struct:char_data
affected_by	emlen.h	/^  int affected_by;		\/* Affected bits 1 *\/$/;"	m	struct:char_data
affected_by	emlen.h	/^  int affected_by;		\/* Affected by these bits *\/$/;"	m	struct:mob_proto_data
aggr_update	upd.c	/^aggr_update (void)$/;"	f
aggro_check	db2.c	/^CHAR_DATA *aggro_check = NULL;$/;"	v
alarm_handler	chan.c	/^alarm_handler ()$/;"	f	file:
alias	emlen.h	/^  char *alias[MAXALIAS];	\/* Alias expansion *\/$/;"	m	struct:pc_data
aliasname	emlen.h	/^  char *aliasname[MAXALIAS];	\/* Alias names *\/$/;"	m	struct:pc_data
aliasok	misc.c	/^aliasok (char *aliasname, char *s)$/;"	f
alignment	emlen.h	/^  short alignment;		\/* 1=good,2=evil,0=neut,3=special *\/$/;"	m	struct:clan_data
alignment	emlen.h	/^  short alignment;		\/* Alignment of the mob *\/$/;"	m	struct:mob_proto_data
alignment	emlen.h	/^  short alignment;		\/* Player's alignment *\/$/;"	m	struct:pc_data
allocate_correct_datatype	object.c	/^allocate_correct_datatype (SINGLE_OBJECT * obj, int *val)$/;"	f
allow_anything	db2.c	/^bool allow_anything = FALSE;$/;"	v
allow_recall	emlen.h	/^  bool allow_recall;		\/* Allow use of the recall command? *\/$/;"	m	struct:power_data
allow_rerolls	emlen.h	/^  bool allow_rerolls;		\/* Allow rerolls in old creation method? *\/$/;"	m	struct:power_data
allow_where	emlen.h	/^  bool allow_where;		\/* Allow use of 'where' command? *\/$/;"	m	struct:power_data
allow_who_in_login	emlen.h	/^  bool allow_who_in_login;	\/* Allow "who" in greeting screen. *\/$/;"	m	struct:power_data
alt_vnum	emlen.h	/^  int alt_vnum;			\/* Alters into this vnum.. UNUSED! *\/$/;"	m	struct:mob_proto_data
amount_lost_on_death	emlen.h	/^  int amount_lost_on_death;	\/* Actual skill amount lost on death *\/$/;"	m	struct:power_data
ans_uppercase	move.c	/^ans_uppercase (const char *txt)$/;"	f
anseval	ansi_out.c	/^anseval (const char *txt, CHAR_DATA * to)$/;"	f
ansi_color	ansi_out.c	/^ansi_color (const char *txt, CHAR_DATA * ch)$/;"	f
append_file	db2.c	/^void append_file (CHAR_DATA * ch, char *file, char *str)$/;"	f
apply_ac	hnd.c	/^apply_ac (SINGLE_OBJECT * obj, int iWear)$/;"	f
area	emlen.h	/^  AREA_DATA *area;		\/* Room this area is in *\/$/;"	m	struct:room_data
area	emlen.h	/^  AREA_DATA *area;		\/* Saves in this area *\/$/;"	m	struct:obj_proto_data
area	emlen.h	/^  AREA_DATA *area;		\/* The area this mob saves in *\/$/;"	m	struct:mob_proto_data
area_bit_name	oc.c	/^char *area_bit_name (int area_flags)$/;"	f
area_data	emlen.h	/^struct area_data$/;"	s
area_first	db2.c	/^AREA_DATA *area_first;$/;"	v
area_flags	emlen.h	/^  int area_flags;		\/* Area flags, changed, etc *\/$/;"	m	struct:area_data
area_free	oc.c	/^AREA_DATA *area_free;$/;"	v
area_last	db2.c	/^AREA_DATA *area_last;$/;"	v
area_sort	db2.c	/^area_sort (AREA_DATA * pArea)$/;"	f
arena	arena.c	/^arena (void)$/;"	f
arena_good_evil	emlen.h	/^  bool arena_good_evil;		\/* Good\/Evil fights in arena? *\/$/;"	m	struct:power_data
arena_msg	emlen.h	/^  int arena_msg;		\/* Arena message status *\/$/;"	m	struct:pc_data
arena_on	emlen.h	/^  bool arena_on;		\/* Arena active? *\/$/;"	m	struct:power_data
arena_timelimit	db2.c	/^int arena_timelimit;$/;"	v
arg1	emlen.h	/^  short arg1;$/;"	m	struct:reset_data
arg2	emlen.h	/^  short arg2;$/;"	m	struct:reset_data
arg3	emlen.h	/^  short arg3;$/;"	m	struct:reset_data
arg_count	oc.c	/^int arg_count (char *argy)$/;"	f
argy	emlen.h	/^  char *argy;$/;"	m	struct:fight_data
arm_m	emlen.h	/^  char *arm_m[20][2];$/;"	m	struct:dammsg_data
arm_m1	emlen.h	/^  char *arm_m1[20][2];$/;"	m	struct:dammsg_data
arm_m2	emlen.h	/^  char *arm_m2[20][2];$/;"	m	struct:dammsg_data
arm_percent	emlen.h	/^  short arm_percent[20][2];$/;"	m	struct:dammsg_data
arm_range	emlen.h	/^  short arm_range[20][2];$/;"	m	struct:dammsg_data
armcls	emlen.h	/^  short armcls;			\/* Armor class. 101 = default for level *\/$/;"	m	struct:mob_proto_data
armor	emlen.h	/^  short armor;			\/* General skin armor *\/$/;"	m	struct:char_data
armor	emlen.h	/^  short armor;$/;"	m	struct:material_data
armor_lev_max	emlen.h	/^  short armor_lev_max[20];	\/* Armor level range *\/$/;"	m	struct:power_data
armor_lev_min	emlen.h	/^  short armor_lev_min[20];	\/* Armor level range *\/$/;"	m	struct:power_data
armor_lev_word	emlen.h	/^  char *armor_lev_word[20];	\/* Armor level range descriptions. *\/$/;"	m	struct:power_data
armsp	armor.c	/^int armsp;$/;"	v
assign_coordinates	draw.c	/^assign_coordinates (CHAR_DATA * ch, char *argy)$/;"	f
atimes	emlen.h	/^  int atimes;			\/* Authorization ident attempts *\/$/;"	m	struct:descriptor_data
attached_to_mob	script.h	/^  int attached_to_mob;$/;"	m	struct:single_trigger
attached_to_obj	script.h	/^  int attached_to_obj;$/;"	m	struct:single_trigger
attached_to_room	script.h	/^  int attached_to_room;$/;"	m	struct:single_trigger
attack_table	def.c	/^const struct attack_type attack_table[] = {$/;"	v	typeref:struct:attack_type
attack_type	emlen.h	/^  signed char attack_type;	\/* v3 *\/$/;"	m	struct:item_weapon
attack_type	emlen.h	/^struct attack_type$/;"	s
attacker_turn	emlen.h	/^  bool attacker_turn;		\/* Internal use *\/$/;"	m	struct:fight_data
attackers	emlen.h	/^  CHAR_DATA *attackers[4];	\/* Melee attackers *\/$/;"	m	struct:ced
attackname	emlen.h	/^  char *attackname;		\/* Attack name, NULL for default attack type *\/$/;"	m	struct:mob_proto_data
attacks	emlen.h	/^  char attacks;			\/* Internal use *\/$/;"	m	struct:fight_data
aturion_down	comm.c	/^bool aturion_down;		                \/* Shutdown *\/$/;"	v
auction_bid	db2.c	/^int auction_bid;$/;"	v
auction_char	db2.c	/^CHAR_DATA *auction_char;$/;"	v
auction_going	db2.c	/^short auction_going;$/;"	v
auction_item	db2.c	/^char auction_item[500];$/;"	v
auction_item_g	db2.c	/^SINGLE_OBJECT *auction_item_g;$/;"	v
auction_lag	emlen.h	/^  bool auction_lag;		\/* PK Quit lag applied to auctions? *\/$/;"	m	struct:power_data
auction_lastbidder	auction.c	/^CHAR_DATA *auction_lastbidder = NULL;$/;"	v
auction_minbid	db2.c	/^int auction_minbid;$/;"	v
auction_tochar	db2.c	/^CHAR_DATA *auction_tochar;$/;"	v
auction_update	auction.c	/^auction_update (void)$/;"	f
auth_fd	emlen.h	/^  socket_t auth_fd;		\/* Authorization ident file desc *\/$/;"	m	struct:descriptor_data
auth_inc	emlen.h	/^  int auth_inc;$/;"	m	struct:descriptor_data
auth_state	emlen.h	/^  int auth_state;		\/* Authorization state *\/$/;"	m	struct:descriptor_data
authtype_names	telnet.h	/^char *authtype_names[] = {$/;"	v
auto_auction	emlen.h	/^  bool auto_auction;		\/* Allow auto-auction? *\/$/;"	m	struct:power_data
auto_toggles	emlen.h	/^  char auto_toggles;$/;"	m	struct:fight_data
auto_xfer	db2.c	/^bool auto_xfer;$/;"	v
average_time	upd.c	/^long average_time[MT];$/;"	v
award_tps	upd.c	/^award_tps (CHAR_DATA * ch, int gain)$/;"	f
b_list	emlen.h	/^struct b_list$/;"	s
bah	give.c	/^static char bah[500];$/;"	v	file:
ban_data	emlen.h	/^struct ban_data$/;"	s
ban_free	aw.c	/^BAN_DATA * ban_free;$/;"	v
ban_list	aw.c	/^  BAN_DATA * ban_list;$/;"	v
bank	emlen.h	/^  unsigned long bank;		\/* Money in the bank, in copper *\/$/;"	m	struct:pc_data
bansite	aw.c	/^bansite (char *argy)$/;"	f
base_blist	db2.c	/^BLIST *base_blist = NULL;$/;"	v
base_hp_regen	emlen.h	/^  short base_hp_regen;		\/* Base hp regen per heartbeat *\/$/;"	m	struct:power_data
base_mana_regen_bonus	emlen.h	/^  short base_mana_regen_bonus;	\/* Non-meditating regen for mana *\/$/;"	m	struct:power_data
base_mp_regen	emlen.h	/^  short base_mp_regen;		\/* Base mp regen per heartbeat *\/$/;"	m	struct:power_data
base_pc	db2.c	/^REALCHAR_DATA base_pc;$/;"	v
bash_slip_to_tackle	emlen.h	/^  bool bash_slip_to_tackle;	\/* Can a bash slip into a groundfight? *\/$/;"	m	struct:power_data
bashable	fgt.c	/^bashable (CHAR_DATA * ch)$/;"	f
beamin	emlen.h	/^  char *beamin;			\/* Beam in message (immorts) *\/$/;"	m	struct:pc_data
beamout	emlen.h	/^  char *beamout;		\/* Beam out message (immorts) *\/$/;"	m	struct:pc_data
beams_to_room	emlen.h	/^  int beams_to_room;		\/* Jump to this room after remorting? *\/$/;"	m	struct:power_data
been_here	yell.c	/^been_here (int vnum)$/;"	f
been_to_room	yell.c	/^int been_to_room[501];$/;"	v
below	emlen.h	/^  int below;			\/* v3 *\/$/;"	m	struct:item_climbable
belt_empty	hnd.c	/^belt_empty (CHAR_DATA * ch)$/;"	f
bfs_clear_queue	ar.c	/^bfs_clear_queue (void)$/;"	f
bfs_dequeue	ar.c	/^bfs_dequeue (void)$/;"	f
bfs_enqueue	ar.c	/^bfs_enqueue (ROOM_DATA * room, short dir, short depth)$/;"	f
bfs_queue_struct	ar.c	/^struct bfs_queue_struct$/;"	s	file:
bfy	rfd.c	/^char bfy[1000];$/;"	v
bgf	emlen.h	/^  bool bgf;			\/* Battleground flag, internal use *\/$/;"	m	struct:pc_data
bid_data	emlen.h	/^struct bid_data$/;"	s
biddata	db2.c	/^BID_DATA biddata;$/;"	v
bidders	emlen.h	/^  char bidders[50][17];		\/*Character names of bidders (didn't to structs cuz $/;"	m	struct:bid_data
bidfor	emlen.h	/^  bool bidfor[50];		\/*FALSE for fighter 0, TRUE for fighter 1 *\/$/;"	m	struct:bid_data
bids	emlen.h	/^  long bids[50];		\/*actually monetary bid *\/$/;"	m	struct:bid_data
bidtotal	arena.c	/^bidtotal (int nummy)$/;"	f
bite	grnd.c	/^bite (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
bitvector	emlen.h	/^  int bitvector;		\/* Bitvector for modification *\/$/;"	m	struct:spell_data
bitvector	emlen.h	/^  int bitvector;		\/* bitvector affects #1 *\/$/;"	m	struct:affect_data
bitvector2	emlen.h	/^  int bitvector2;		\/* More effects *\/$/;"	m	struct:spell_data
bitvector2	emlen.h	/^  int bitvector2;		\/* bitvector affects #2 *\/$/;"	m	struct:affect_data
blank_prompt	remort.c	/^blank_prompt (CHAR_DATA * ch)$/;"	f
board_num	emlen.h	/^  int board_num;		\/* Game Board number this note is located on *\/$/;"	m	struct:note_data
boards	note.c	/^char *boards[MAX_BOARDS] = {$/;"	v
boat	emlen.h	/^  OBJ_BOAT *boat;		\/* OLD boat data *\/$/;"	m	struct:obj_data
body_m	emlen.h	/^  char *body_m[20][2];$/;"	m	struct:dammsg_data
body_m1	emlen.h	/^  char *body_m1[20][2];$/;"	m	struct:dammsg_data
body_m2	emlen.h	/^  char *body_m2[20][2];$/;"	m	struct:dammsg_data
body_percent	emlen.h	/^  short body_percent[20][2];$/;"	m	struct:dammsg_data
body_range	emlen.h	/^  short body_range[20][2];$/;"	m	struct:dammsg_data
bodyp	armor.c	/^int bodyp;$/;"	v
bonus	emlen.h	/^  short bonus[5];		\/* Initial stat bonuses *\/$/;"	m	struct:race_data
bool	emlen.h	/^typedef unsigned char bool;$/;"	t
boot_db	db2.c	/^boot_db (void)$/;"	f
bounty	emlen.h	/^  short bounty;			\/* bounty.. UNUSED *\/$/;"	m	struct:pc_data
bt_tm	db2.c	/^time_t bt_tm;$/;"	v
bug	db2.c	/^void bug (const char *str, int param)$/;"	f
bug_buf	db2.c	/^char bug_buf[2 * SML_LENGTH];$/;"	v
builder_port	db2.c	/^bool builder_port = FALSE;$/;"	v
builders	emlen.h	/^  char *builders;		\/* Builder list *\/$/;"	m	struct:area_data
buy_type	emlen.h	/^  short buy_type[MAX_TRADE];	\/* What a shopkeeper will buy *\/$/;"	m	struct:shop_data
bytes_saved	db2.c	/^int bytes_saved = 0;$/;"	v
bzero	aedit.c	/^bzero (char *spot, int len)$/;"	f
c	dam.c	/^CHAR_DATA *c;$/;"	v
c	emlen.h	/^  char c;			\/* Overhead mapping color override *\/$/;"	m	struct:room_data
called_by	script.h	/^  SINGLE_TRIGGER *called_by;	\/* Trigger it was called by *\/$/;"	m	struct:script_info
caller	emlen.h	/^  CHAR_DATA *caller;$/;"	m	struct:fight_data
caller	emlen.h	/^  char caller[50];$/;"	m	struct:shell_command
came_from_boat	emlen.h	/^  SINGLE_OBJECT *came_from_boat;	\/* Came from this OLD format boat? *\/$/;"	m	struct:ced
can_drop_obj	hnd.c	/^can_drop_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
can_fight_self	emlen.h	/^  bool can_fight_self;		\/* Can fight yourself? *\/$/;"	m	struct:power_data
can_groundfight	grnd.c	/^can_groundfight (CHAR_DATA * ch)$/;"	f
can_quit	emlen.h	/^  char can_quit;		\/* Can_quit status; quit rules *\/$/;"	m	struct:area_data
can_see	hnd.c	/^can_see (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
can_see_nextdoor	hnd.c	/^can_see_nextdoor (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
can_see_obj	hnd.c	/^can_see_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
can_summon_mobs	emlen.h	/^  bool can_summon_mobs;		\/* Does the game allow mob summoning? *\/$/;"	m	struct:power_data
can_travel_sectors	emlen.h	/^  int can_travel_sectors;	\/* Can travel through these sectors *\/$/;"	m	struct:room_extended
can_trip	fgt.c	/^can_trip (CHAR_DATA * ch)$/;"	f
can_vote	poll.c	/^can_vote (CHAR_DATA * ch, POLL_DATA * poll)$/;"	f
can_yell	upd.c	/^can_yell (CHAR_DATA * ch)$/;"	f
cap	db2.c	/^char *cap (char *str)$/;"	f
capitalize	db2.c	/^char *capitalize (const char *str)$/;"	f
carried_by	emlen.h	/^  CHAR_DATA *carried_by;	\/* Carried by this player *\/$/;"	m	struct:obj_data
carry_number	emlen.h	/^  short carry_number;		\/* Carrying this amount of items *\/$/;"	m	struct:pc_data
carry_weight	emlen.h	/^  short carry_weight;		\/* Player's current carrying weight *\/$/;"	m	struct:pc_data
carrying	emlen.h	/^  SINGLE_OBJECT *carrying;	\/* Objects carrying *\/$/;"	m	struct:char_data
cast_percent	emlen.h	/^  signed char cast_percent;	\/* Percent he\/she will cast a spell *\/$/;"	m	struct:optional_data
cast_spells	emlen.h	/^  char *cast_spells[10];	\/* Casts up to 10 spells *\/$/;"	m	struct:optional_data
casting_time	emlen.h	/^  int casting_time;		\/* Casting delay time. 10 = 1 combat round *\/$/;"	m	struct:spell_data
ced	emlen.h	/^  CED_DATA *ced;		\/* Character extended data *\/$/;"	m	struct:char_data
ced	emlen.h	/^struct ced$/;"	s
ced_first	db2.c	/^CED_DATA *ced_first;$/;"	v
ced_free	db2.c	/^CED_DATA *ced_free;$/;"	v
cedit	clan.c	/^cedit (CHAR_DATA * ch, char *argy)$/;"	f
cf	db2.c	/^CHR_FUNCTION *cf = NULL;$/;"	v
chCorrupt	sv.c	/^CHAR_DATA *chCorrupt = NULL;$/;"	v
challenge	emlen.h	/^  signed char challenge;	\/* Has this bloke been challenged to arena fight? *\/$/;"	m	struct:fight_data
challenge_on	emlen.h	/^  bool challenge_on;		\/* Arena challenges on\/off? *\/$/;"	m	struct:pc_data
challenge_time	emlen.h	/^  short challenge_time;		\/* Challenge time counter *\/$/;"	m	struct:pc_data
challenged	emlen.h	/^  bool challenged;		\/* Has been challenged? *\/$/;"	m	struct:pc_data
challenged_by	emlen.h	/^  char *challenged_by;		\/* Challenged by whom? *\/$/;"	m	struct:pc_data
chan	channels.c	/^char *chan[2][30][MAX_SCROLLBACK];$/;"	v
chan_color	emlen.h	/^  char chan_color[30][MAX_COLORS];	\/* Channel colors *\/$/;"	m	struct:pc_data
chan_count	channels.c	/^short chan_count[2][30];$/;"	v
chan_first	db2.c	/^CHANNEL *chan_first = NULL;$/;"	v
chan_ignore	emlen.h	/^  int chan_ignore;		\/* Deaf to these new style channels *\/$/;"	m	struct:pc_data
chance	quest.c	/^bool chance(int num)$/;"	f
change	emlen.h	/^  int change;			\/* Last change *\/$/;"	m	struct:weather_data
changed_spells	db2.c	/^bool changed_spells;$/;"	v
channel_function	channels.c	/^channel_function (CHAR_DATA * ch, char *argy, CHANNEL * c, int channel,$/;"	f
channel_name	emlen.h	/^  char *channel_name;		\/* Channel name *\/$/;"	m	struct:channel_type
channel_type	emlen.h	/^struct channel_type$/;"	s
channeld	channels.c	/^channeld (DESCRIPTOR_DATA * d, char *input)$/;"	f
char_auto	emlen.h	/^  char *char_auto;$/;"	m	struct:social_type
char_data	emlen.h	/^struct char_data$/;"	s
char_found	emlen.h	/^  char *char_found;$/;"	m	struct:social_type
char_free	db2.c	/^CHAR_DATA *char_free = NULL;$/;"	v
char_from_boat	boat.c	/^char_from_boat (CHAR_DATA * ch, SINGLE_OBJECT * boat)$/;"	f
char_from_room	hnd.c	/^char_from_room (CHAR_DATA * ch)$/;"	f
char_list	db2.c	/^CHAR_DATA *char_list;$/;"	v
char_no_arg	emlen.h	/^  char *char_no_arg;$/;"	m	struct:social_type
char_not_found	emlen.h	/^  char *char_not_found;$/;"	m	struct:social_type
char_only_update	upd.c	/^char_only_update (void)$/;"	f
char_to_boat	boat.c	/^char_to_boat (CHAR_DATA * ch, SINGLE_OBJECT * boat)$/;"	f
char_to_room	hnd.c	/^char_to_room (CHAR_DATA * ch, ROOM_DATA * oneroom)$/;"	f
char_update	upd.c	/^char_update (void)$/;"	f
character	emlen.h	/^  CHAR_DATA *character;		\/* player this descriptor is attached to *\/$/;"	m	struct:descriptor_data
character_add	edit.c	/^character_add (CHAR_DATA * ch, char *to_add)$/;"	f
chars_sent	db2.c	/^long chars_sent;$/;"	v
check_action	comm.c	/^check_action (DESCRIPTOR_DATA * dd, char *action, char *todo, char *txt)$/;"	f
check_add_trophy	toptr.c	/^check_add_trophy (CHAR_DATA * ch, CHAR_DATA * victim, int same_align, int diff_align)$/;"	f
check_background_processes	syslag.c	/^check_background_processes (void)$/;"	f
check_blind	look.c	/^check_blind (CHAR_DATA * ch)$/;"	f
check_body_temp	warmth.c	/^check_body_temp (CHAR_DATA * ch)$/;"	f
check_ced	oc.c	/^void check_ced (CHAR_DATA * ch)$/;"	f
check_clan	clan.c	/^check_clan (CLAN_DATA * clan, char *argy)$/;"	f
check_clear_more	room.c	/^check_clear_more (ROOM_DATA * room)$/;"	f
check_dodge	fgt.c	/^check_dodge (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
check_enterroom_script	move.c	/^check_enterroom_script (CHAR_DATA * fch, CHAR_DATA * ch)$/;"	f
check_fgt	hnd.c	/^check_fgt (CHAR_DATA * ch)$/;"	f
check_given_script	move.c	/^check_given_script (CHAR_DATA * fch, CHAR_DATA * ch, int vnum)$/;"	f
check_grep	int.c	/^        char grep[500]; char *check_grep (CHAR_DATA * ch, char *argy)$/;"	f
check_hours	pedit.c	/^check_hours (CHAR_DATA * ch)$/;"	f
check_limited_stuff	quit.c	/^check_limited_stuff (CHAR_DATA * ch)$/;"	f
check_mob_long	medit.c	/^check_mob_long (char *nm, CHAR_DATA * ch)$/;"	f
check_mob_name	medit.c	/^check_mob_name (char *nm, CHAR_DATA * ch)$/;"	f
check_mob_short	medit.c	/^check_mob_short (char *nm, CHAR_DATA * ch)$/;"	f
check_mounts	aw.c	/^void check_mounts (CHAR_DATA * ch)$/;"	f
check_obj_long	oedit.c	/^check_obj_long (char *nm, CHAR_DATA * ch)$/;"	f
check_obj_name	oedit.c	/^check_obj_name (char *nm, CHAR_DATA * ch)$/;"	f
check_obj_short	oedit.c	/^check_obj_short (char *nm, CHAR_DATA * ch)$/;"	f
check_parry	fgt.c	/^check_parry (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
check_parse_name	comm.c	/^check_parse_name (char *name, bool space_allowed)$/;"	f
check_pkill	fgt.c	/^check_pkill (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
check_pr	prompt.c	/^check_pr (char *txt)$/;"	f
check_prereq	sedit.c	/^void check_prereq(SPELL_DATA *spell)$/;"	f
check_prereq_depth	skill.c	/^check_prereq_depth(SPELL_DATA *spell, SPELL_DATA *prereq)$/;"	f
check_rating	toptr.c	/^check_rating (CHAR_DATA * ch)$/;"	f
check_reconnect	comm.c	/^check_reconnect (DESCRIPTOR_DATA * d \/*, char *name, bool fConn *\/ )$/;"	f
check_reset	oc.c	/^void check_reset (CHAR_DATA * ch, RESET_DATA * pReset)$/;"	f
check_rit	channels.c	/^check_rit (DESCRIPTOR_DATA * d, char *argy)$/;"	f
check_room_more	room.c	/^check_room_more (ROOM_DATA * room)$/;"	f
check_say_script	move.c	/^check_say_script (CHAR_DATA * fch, CHAR_DATA * ch, char *txt)$/;"	f
check_shield	fgt.c	/^check_shield (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
check_short_tick_script	move.c	/^check_short_tick_script (CHAR_DATA * fch, CHAR_DATA * ch)$/;"	f
check_social	int.c	/^bool check_social (CHAR_DATA * ch, char *command, char *argy)$/;"	f
check_social_script	move.c	/^check_social_script (CHAR_DATA * fch, CHAR_DATA * ch, char *txt)$/;"	f
check_stats	hnd.c	/^check_stats (CHAR_DATA * ch)$/;"	f
check_super	move.c	/^bool check_super = TRUE;$/;"	v
check_tell_script	move.c	/^check_tell_script (CHAR_DATA * fch, CHAR_DATA * ch, char *txt)$/;"	f
check_temp	oc.c	/^check_temp (CHAR_DATA * ch)$/;"	f
check_toggle_implant	pedit.c	/^check_toggle_implant (CHAR_DATA * ch, char *arg)$/;"	f
check_topten	toptr.c	/^check_topten (CHAR_DATA * ch)$/;"	f
check_write_limited	sv.c	/^check_write_limited (SINGLE_OBJECT * obji, int vnum)$/;"	f
choice	poll.h	/^  short choice;			\/* What did the player choose *\/$/;"	m	struct:poll_stamp_list
choose_evil_races	emlen.h	/^  bool choose_evil_races;	\/* Choose evil races at newbie creation? *\/$/;"	m	struct:power_data
cl	db2.c	/^char cl[10024];$/;"	v
clan	emlen.h	/^  bool clan;			\/* Clan channel? *\/$/;"	m	struct:channel_type
clan2	emlen.h	/^  bool clan2;			\/* Sect channel? *\/$/;"	m	struct:channel_type
clan_check_align	clan.c	/^clan_check_align (CHAR_DATA * ch)$/;"	f
clan_counter	emlen.h	/^  short clan_counter;		\/* Clan counter "head" *\/$/;"	m	struct:pc_data
clan_data	emlen.h	/^struct clan_data$/;"	s
clan_free	clan.c	/^clan_free (CLAN_DATA * clan)$/;"	f
clan_guard_1	emlen.h	/^  char clan_guard_1;		\/* Guards for this clan *\/$/;"	m	struct:mob_proto_data
clan_guard_2	emlen.h	/^  char clan_guard_2;		\/* Guards for this sect *\/$/;"	m	struct:mob_proto_data
clan_index_free	clan.c	/^CLAN_DATA *clan_index_free;$/;"	v
clan_index_free_2	clan.c	/^CLAN_DATA *clan_index_free_2;$/;"	v
clan_index_hash	db2.c	/^CLAN_DATA *clan_index_hash[20];$/;"	v
clan_index_hash_2	db2.c	/^CLAN_DATA *clan_index_hash_2[20];$/;"	v
clan_list	db2.c	/^CLAN_DATA *clan_list = NULL;$/;"	v
clan_list_2	db2.c	/^CLAN_DATA *clan_list_2 = NULL;$/;"	v
clan_notify	channels.c	/^clan_notify (char *argy, int clan_num)	\/*By Owen Emlen *\/$/;"	f
clan_number	clan.c	/^clan_number (CHAR_DATA * ch)$/;"	f
clan_number_2	clan.c	/^clan_number_2 (CHAR_DATA * ch)$/;"	f
clan_talk_history	channels.c	/^clan_talk_history (CHAR_DATA * ch)$/;"	f
clan_talks	emlen.h	/^  char *clan_talks[15];		\/* Circular list of clan talks *\/$/;"	m	struct:pc_data
clans	emlen.h	/^  int clans[1];			\/* [0] and [1] are clan numbers *\/$/;"	m	struct:clanwar
clanwar	db2.c	/^CLANWAR clanwar;$/;"	v
clanwar	emlen.h	/^struct clanwar$/;"	s
clanzone	emlen.h	/^  bool clanzone;		\/* Is this a clan zone?  unused *\/$/;"	m	struct:area_data
clean_blank_rooms	db2.c	/^clean_blank_rooms (CHAR_DATA * ch, char *argy)$/;"	f
clean_oldchars	pb.c	/^clean_oldchars (CHAR_DATA * ch, char *argy)$/;"	f
clean_up	pb.c	/^clean_up (CHAR_DATA * ch, char *argy)$/;"	f
cleanup_system	db2.c	/^cleanup_system (void)$/;"	f
clear_been_to_room	yell.c	/^clear_been_to_room (void)$/;"	f
clear_data	char.c	/^clear_data (void *thing)$/;"	f
clear_evil_auction_listeners	auction.c	/^clear_evil_auction_listeners (void)$/;"	f
clear_fgt	hnd.c	/^clear_fgt (CHAR_DATA * ch)$/;"	f
clear_gn_auction_listeners	auction.c	/^clear_gn_auction_listeners (void)$/;"	f
clear_host	comm.c	/^clear_host (CHAR_DATA * ch)$/;"	f
clear_tracks	quit.c	/^clear_tracks (CHAR_DATA * ch)$/;"	f
clookup	power.c	/^clookup (char *t)$/;"	f
close_hour	emlen.h	/^  unsigned char close_hour;	\/* Time the shop closes *\/$/;"	m	struct:shop_data
close_socket	comm.c	/^close_socket (DESCRIPTOR_DATA * dclose)$/;"	f
close_socket2	comm.c	/^close_socket2 (DESCRIPTOR_DATA * dclose, DESCRIPTOR_DATA * dnew)$/;"	f
closeto	combat.c	/^bool closeto = FALSE;$/;"	v
clr	draw.c	/^clr (CHAR_DATA * ch)$/;"	f
cmd_type	emlen.h	/^struct cmd_type$/;"	s
code	emlen.h	/^  char code[10];$/;"	m	struct:color_data
code	script.h	/^  char *code;$/;"	m	struct:code_segment
code_label	script.h	/^  char code_label[10];		\/* Label of code to execute *\/$/;"	m	struct:single_trigger
code_list	db2.c	/^CODE *code_list[256];$/;"	v
code_seg	script.h	/^  char code_seg[10];		\/* Current label of code we're in *\/$/;"	m	struct:script_info
code_segment	script.h	/^struct code_segment$/;"	s
color	emlen.h	/^  char *color;			\/* Color of this channel for newbies *\/$/;"	m	struct:channel_type
color_data	emlen.h	/^struct color_data$/;"	s
color_name	def.c	/^char *const color_name[] = {$/;"	v
color_table	def.c	/^const struct color_data color_table[] = {$/;"	v	typeref:struct:color_data
colors	emlen.h	/^  short colors[MAX_COLORS];	\/* Colors for old style channels *\/$/;"	m	struct:pc_data
colrs	draw.c	/^signed char colrs[80][25];	\/* Virtual Screen - numeric color values *\/$/;"	v
combat_delay_count	emlen.h	/^  short combat_delay_count;	\/* Delay ticks, internal use *\/$/;"	m	struct:fight_data
combat_field	emlen.h	/^struct combat_field$/;"	s
combat_field_update	combat.c	/^combat_field_update (void)$/;"	f
combat_state	db2.c	/^short combat_state;$/;"	v
command	emlen.h	/^  char *command;$/;"	m	struct:script_data
command	emlen.h	/^  char command;			\/* command (Object Mob, etc) *\/$/;"	m	struct:reset_data
command_hash	db2.c	/^COMMAND *command_hash[256];$/;"	v
command_level	poll.c	/^command_level (char *comm)$/;"	f
commands	db2.c	/^int commands = 0;$/;"	v
commands	emlen.h	/^  char *commands[3];		\/* Commands to use this channel *\/$/;"	m	struct:channel_type
compare	reloc.c	/^compare (CHAR_DATA * ch, char *argy)$/;"	f
complete	emlen.h	/^  bool complete[1000];		\/* Temp flags for OLD quest method *\/$/;"	m	struct:pc_data
compress	int.c	/^char *compress (char *s, long len)$/;"	f
con_app	prse.c	/^struct con_apply_type con_app[36];$/;"	v	typeref:struct:con_apply_type
con_apply_type	emlen.h	/^struct con_apply_type$/;"	s
con_name	comm.c	/^con_name (int con)$/;"	f
con_state	aw.c	/^char *con_state (DESCRIPTOR_DATA * d)$/;"	f
condition	emlen.h	/^  short condition[3];		\/* Drunk,Thirsty,Hungry stats *\/$/;"	m	struct:pc_data
condition_now	emlen.h	/^  signed char condition_now;	\/* v7 *\/$/;"	m	struct:item_armor
condition_var	db2.c	/^char condition_var[500];$/;"	v
connect_remote	chan.c	/^connect_remote (char *host, char *port, CHAR_DATA * ch)$/;"	f
connected	emlen.h	/^  short connected;		\/* Connect state *\/$/;"	m	struct:descriptor_data
connection_names	chan.c	/^char connection_names[5][5];$/;"	v
connectiond	chan.c	/^DESCRIPTOR_DATA *connectiond[5];$/;"	v
cons_damage	db2.c	/^int cons_damage;$/;"	v
contains	emlen.h	/^  SINGLE_OBJECT *contains;	\/* For containers *\/$/;"	m	struct:obj_data
contents	emlen.h	/^  SINGLE_OBJECT *contents;	\/* Object contents of room *\/$/;"	m	struct:room_extended
control	comm.c	/^socket_t control;$/;"	v
conv_height	sv.c	/^conv_height (CHAR_DATA * ch)$/;"	f
conv_race	sv.c	/^conv_race (CHAR_DATA * ch)$/;"	f
convo	emlen.h	/^  char convo[200];		\/* Convo 199 is cur cursor pos *\/$/;"	m	struct:pc_data
cool_skills	emlen.h	/^  int cool_skills;		\/* Cool extra skills\/abilities *\/$/;"	m	struct:pc_data
copper	emlen.h	/^  int copper;			\/* Amount of copper *\/$/;"	m	struct:char_data
copper	emlen.h	/^  int copper;			\/* Copper in room *\/$/;"	m	struct:room_extended
cost	emlen.h	/^  int cost;			\/* Cost of the object *\/$/;"	m	struct:obj_proto_data
cost	emlen.h	/^  int cost;			\/* Object cost.  Change to ref back to proto *\/$/;"	m	struct:obj_data
cost	emlen.h	/^  int cost;			\/* \/3 for body, \/5 for legs, \/5 for arms, \/6 for head$/;"	m	struct:material_data
count	emlen.h	/^  short count;			\/* How many mobs are there of this type? *\/$/;"	m	struct:mob_proto_data
count	emlen.h	/^  short count;			\/* internal use *\/$/;"	m	struct:obj_proto_data
count_chars	note.c	/^count_chars (char *text)$/;"	f
count_lines	note.c	/^count_lines (char *text)$/;"	f
count_mat	autoeq.c	/^		  int count_mat (void)$/;"	f
count_obj_list	hnd.c	/^count_obj_list (OBJ_PROTOTYPE * pObjIndex, SINGLE_OBJECT * list)$/;"	f
count_options	poll.c	/^count_options (POLL_DATA * poll)$/;"	f
create_amount	hnd.c	/^create_amount (int amount, CHAR_DATA * pMob, ROOM_DATA * pRoom,$/;"	f
create_mobile	db2.c	/^CHAR_DATA * create_mobile (MOB_PROTOTYPE * pMobIndex)$/;"	f
create_object	db2.c	/^  SINGLE_OBJECT * create_object (OBJ_PROTOTYPE * pObjIndex, int level)$/;"	f
create_standards	autoeq.c	/^create_standards (CHAR_DATA * ch, char *argy)$/;"	f
createobject	script.c	/^createobject (CHAR_DATA * ch, int vnum)$/;"	f
creates_hours	emlen.h	/^  short creates_hours;		\/* ever creates_hours hours. *\/$/;"	m	struct:shop_data
creates_message	emlen.h	/^  char *creates_message;	\/* display this message when he\/she creates *\/$/;"	m	struct:shop_data
creates_obj	emlen.h	/^  int creates_obj;		\/* Creates this object vnum *\/$/;"	m	struct:spell_data
creates_vnum	emlen.h	/^  int creates_vnum;		\/* Shopkeeper makes this object *\/$/;"	m	struct:shop_data
crypt	emlen.h	3512;"	d
cscr	script.c	/^cscr (char *txt, CHAR_DATA * mob, char *player, SINGLE_OBJECT * obj)$/;"	f
ctr	draw.c	/^int ctr;$/;"	v
cur_col	draw.c	/^char cur_col = -6;$/;"	v
cur_line	emlen.h	/^  int cur_line;			\/*The scriptline that just was run *\/$/;"	m	struct:ced
cur_temp	info.c	/^cur_temp (CHAR_DATA * ch)$/;"	f
current	script.h	/^  CHAR_DATA *current;		\/* Person currently being looked at by the script *\/$/;"	m	struct:script_info
current_charges	emlen.h	/^  signed char current_charges;	\/* v2 *\/$/;"	m	struct:item_wand
current_line	script.h	/^  short current_line;		\/* Line of code it will execute next *\/$/;"	m	struct:script_info
current_time	comm.c	/^time_t current_time;		                \/* Time of this pulse *\/$/;"	v
current_vnum	db2.c	/^int current_vnum = 0;$/;"	v
d_info	emlen.h	/^  DOOR_DATA *d_info;		\/* Optional door info structure *\/$/;"	m	struct:exit_data
d_next	comm.c	/^DESCRIPTOR_DATA *d_next;		        \/* Next descriptor in loop *\/$/;"	v
dam	emlen.h	/^  short dam;$/;"	m	struct:str_apply_type
dam_message	dam2.c	/^dam_message (CHAR_DATA * ch, CHAR_DATA * victim, int dam, int dt, int p)$/;"	f
dam_mort	emlen.h	/^  short dam_mort;$/;"	m	struct:pc_data
damage	emlen.h	/^  char *damage;			\/* If combat spell, how much dam (w\/vars) *\/$/;"	m	struct:spell_data
damage	fgt.c	/^damage (CHAR_DATA * ch, CHAR_DATA * victim, int dam, int dt)$/;"	f
damage_p	emlen.h	/^  signed char damage_p;		\/* v0 *\/$/;"	m	struct:item_weapon
damages_struct	emlen.h	/^struct damages_struct$/;"	s
dammsg_data	emlen.h	/^struct dammsg_data$/;"	s
damroll	emlen.h	/^  short damroll;		\/* Damroll *\/$/;"	m	struct:char_data
damroll	emlen.h	/^  signed char damroll;		\/* Extra damroll.  Can be - or + *\/$/;"	m	struct:mob_proto_data
damt	db2.c	/^DAM_STRUCT damt;$/;"	v
darkie	conflict.c	/^char *darkie;$/;"	v
data_type	emlen.h	/^  signed char data_type;$/;"	m	struct:char_data
data_type	emlen.h	/^  signed char data_type;$/;"	m	struct:obj_data
data_type	emlen.h	/^  signed char data_type;$/;"	m	struct:pc_data
data_type	emlen.h	/^  signed char data_type;$/;"	m	struct:room_data
date	emlen.h	/^  char *date;			\/* Date it was sent *\/$/;"	m	struct:note_data
date	poll.h	/^  char *date;			\/* Date it was set up *\/$/;"	m	struct:poll_data
date_stamp	emlen.h	/^  time_t date_stamp;		\/* Date stamp for unread notes *\/$/;"	m	struct:note_data
date_stamp	poll.h	/^  time_t date_stamp;		\/* Date stamp *\/$/;"	m	struct:poll_data
day	emlen.h	/^  short day;$/;"	m	struct:time_info_data
day_counter	db2.c	/^long day_counter;$/;"	v
day_name	info.c	/^char *const day_name[] = {$/;"	v
dbs	draw.c	/^bool dbs = TRUE;		\/* Double space option *\/$/;"	v
dbs	emlen.h	/^  bool dbs;			\/* Double space on maps? *\/$/;"	m	struct:pc_data
deaf	emlen.h	/^  short deaf;			\/* Deaf to these channels *\/$/;"	m	struct:pc_data
death_cry	death.c	/^death_cry (CHAR_DATA * ch, bool flaggy)$/;"	f
deaths	emlen.h	/^  int deaths;			\/* Times the player has died *\/$/;"	m	struct:pc_data
debug	script3.c	/^void debug (CHAR_DATA * ch, char *argy)$/;"	f
debugger	script3.c	/^CHAR_DATA * debugger = NULL;	\/* This holds who debugging should go to *\/$/;"	v
decode	reloc.c	/^decode (CHAR_DATA * ch, char *argy)$/;"	f
decompress	int.c	/^char *decompress (char *s)$/;"	f
decrease	emlen.h	/^  short decrease;		\/* Decrease percent for multiple items *\/$/;"	m	struct:shop_data
delay_ticks	script.h	/^  short delay_ticks;$/;"	m	struct:script_info
depth	ar.c	/^  short depth;$/;"	m	struct:bfs_queue_struct	file:
desc	emlen.h	/^  DESCRIPTOR_DATA *desc;	\/* Descriptor for players, NULL for mobs *\/$/;"	m	struct:char_data
desc	emlen.h	/^  char *desc;$/;"	m	struct:material_data
desc_rooms	db2.c	/^int desc_rooms;$/;"	v
desc_rooms	emlen.h	/^  short desc_rooms;		\/* Descripted room count *\/$/;"	m	struct:area_data
description	emlen.h	/^  char *description;		\/* 'On ground' description of the object *\/$/;"	m	struct:obj_data
description	emlen.h	/^  char *description;		\/* Description seen when on ground *\/$/;"	m	struct:obj_proto_data
description	emlen.h	/^  char *description;		\/* Exit description *\/$/;"	m	struct:door_data
description	emlen.h	/^  char *description;		\/* Full textual description *\/$/;"	m	struct:mob_proto_data
description	emlen.h	/^  char *description;		\/* Textual description of player *\/$/;"	m	struct:pc_data
description	emlen.h	/^  char *description;		\/* The actual extra description *\/$/;"	m	struct:extra_descr_data
description	emlen.h	/^  char *description;		\/* The room description *\/$/;"	m	struct:room_data
descriptor	emlen.h	/^  socket_t descriptor;		\/* Actual file descriptor number *\/$/;"	m	struct:descriptor_data
descriptor_data	emlen.h	/^struct descriptor_data$/;"	s
descriptor_free	comm.c	/^DESCRIPTOR_DATA *descriptor_free = NULL;	\/* Free list for descriptors *\/$/;"	v
descriptor_list	comm.c	/^DESCRIPTOR_DATA *descriptor_list = NULL;	\/* All open descriptors *\/$/;"	v
destroy_list	yell.c	/^destroy_list (CHAR_DATA * ch)$/;"	f
dex_name	comm.c	/^dex_name (int dex)$/;"	f
dice	db2.c	/^int dice (int number, int size)$/;"	f
dict	dict.c	/^const char *dict[] = {$/;"	v
diggy	redit.c	/^bool diggy = FALSE;$/;"	v
dir	ar.c	/^  short dir;$/;"	m	struct:bfs_queue_struct	file:
dir_came	emlen.h	/^  signed char dir_came;		\/* Came from direction *\/$/;"	m	struct:track_data
dir_left	emlen.h	/^  signed char dir_left;		\/* Left in this direction *\/$/;"	m	struct:track_data
dir_name	move.c	/^char *const dir_name[] = {$/;"	v
dir_rev	move.c	/^char *const dir_rev[] = {$/;"	v
dirrev	move.c	/^char *const dirrev[] = {$/;"	v
disabled	emlen.h	/^  bool disabled;$/;"	m	struct:material_data
disarm	fgt.c	/^disarm (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
disengage	boat.c	/^disengage (CHAR_DATA * ch, char *argy)$/;"	f
disp_already	draw.c	/^bool disp_already[MAXX];	\/* Displayed this coordinate already? *\/$/;"	v
display_dam_stuff	dam.c	/^display_dam_stuff (CHAR_DATA * ch)$/;"	f
display_hours	pedit.c	/^display_hours (CHAR_DATA * ch, char *argy)$/;"	f
display_menu	comm.c	/^display_menu (CHAR_DATA * ch)$/;"	f
display_resets	oc.c	/^void display_resets (CHAR_DATA * ch)$/;"	f
display_room	draw.c	/^display_room (CHAR_DATA * ch, ROOM_DATA * rid, int x, int y, short came_from, bool sup)$/;"	f
display_room_mark	draw.c	/^display_room_mark (CHAR_DATA * ch, ROOM_DATA * rid, int x, int y, short came_from, bool sup, bool mobbie)$/;"	f
display_room_mark_direct	draw.c	/^display_room_mark_direct (CHAR_DATA * ch, ROOM_DATA * rid, int x, int y,$/;"	f
display_toggles	config.c	/^display_toggles (CHAR_DATA * ch)$/;"	f
dist_name	def.c	/^char *const dist_name[8] = $/;"	v
distribute_clan_talk	channels.c	/^distribute_clan_talk (CHAR_DATA * me, char *argy, int channel)$/;"	f
dmsg	db2.c	/^DAM_MSG dmsg;$/;"	v
do_2backward	oc.c	/^void do_2backward (CHAR_DATA * ch, char *argy)$/;"	f
do_2forward	oc.c	/^void do_2forward (CHAR_DATA * ch, char *argy)$/;"	f
do_acceptc	arena.c	/^do_acceptc (CHAR_DATA * ch, char *argy)$/;"	f
do_action	quit.c	/^do_action (CHAR_DATA * ch, char *argy)$/;"	f
do_actual_backstab	fgt.c	/^do_actual_backstab (CHAR_DATA * ch, char *argy)$/;"	f
do_actual_cast	mgc.c	/^do_actual_cast (CHAR_DATA * ch, char *argy)$/;"	f
do_actual_circle	fgt.c	/^do_actual_circle (CHAR_DATA * ch, char *argy, bool used_flash)$/;"	f
do_actual_investigate	death.c	/^do_actual_investigate (CHAR_DATA * ch, char *argy)$/;"	f
do_actual_mine	create.c	/^void do_actual_mine (CHAR_DATA *ch, char *argy)$/;"	f
do_actual_search	look.c	/^do_actual_search (CHAR_DATA * ch, char *argy)$/;"	f
do_advance	aw.c	/^void do_advance (CHAR_DATA * ch, char *argy)$/;"	f
do_aedit	oc.c	/^void do_aedit (CHAR_DATA * ch, char *argy)$/;"	f
do_affect	score.c	/^do_affect (CHAR_DATA * ch, char *argy)$/;"	f
do_afk	remort.c	/^do_afk (CHAR_DATA * ch, char *argy)$/;"	f
do_alias	quit.c	/^do_alias (CHAR_DATA * ch, char *argy)$/;"	f
do_alien	alien.c	/^do_alien (CHAR_DATA * ch, char *argy)$/;"	f
do_allow	aw.c	/^do_allow (CHAR_DATA * ch, char *argy)$/;"	f
do_anon	info.c	/^do_anon (CHAR_DATA * ch, char *argy)$/;"	f
do_ansi	config.c	/^do_ansi (CHAR_DATA * ch, char *argy)$/;"	f
do_answer	int.c	/^void do_answer (CHAR_DATA * ch, char *argy)$/;"	f
do_areas	aw.c	/^do_areas (CHAR_DATA * ch, char *argy)$/;"	f
do_arena	arena.c	/^do_arena (CHAR_DATA * ch, char *argy)$/;"	f
do_arenaecho	aw.c	/^void do_arenaecho (CHAR_DATA * ch, char *argy, bool batspam)$/;"	f
do_armor	armor.c	/^do_armor (CHAR_DATA * ch, char *argy)$/;"	f
do_asave	oc.c	/^do_asave (CHAR_DATA * ch, char *argy)$/;"	f
do_assist	config.c	/^do_assist (CHAR_DATA * ch, char *argy)$/;"	f
do_astat	oc.c	/^void do_astat (CHAR_DATA * ch, char *argy)$/;"	f
do_at	aw.c	/^void do_at (CHAR_DATA * ch, char *argy)$/;"	f
do_attribute	score.c	/^do_attribute (CHAR_DATA * ch, char *argy)$/;"	f
do_auction	auction.c	/^do_auction (CHAR_DATA * ch, char *argy, bool to_all)$/;"	f
do_auto	config.c	/^do_auto (CHAR_DATA * ch, char *argy)$/;"	f
do_autoexit	config.c	/^do_autoexit (CHAR_DATA * ch, char *argy)$/;"	f
do_autogold	config.c	/^do_autogold (CHAR_DATA * ch, char *argy)$/;"	f
do_autoloot	config.c	/^do_autoloot (CHAR_DATA * ch, char *argy)$/;"	f
do_autosac	config.c	/^do_autosac (CHAR_DATA * ch, char *argy)$/;"	f
do_autosplit	config.c	/^do_autosplit (CHAR_DATA * ch, char *argy)$/;"	f
do_award_skill	aw.c	/^do_award_skill (CHAR_DATA * ch, char *argy)$/;"	f
do_backstab	fgt.c	/^do_backstab (CHAR_DATA * ch, char *argy)$/;"	f
do_backward	oc.c	/^void do_backward (CHAR_DATA * ch, char *argy)$/;"	f
do_balance	bank.c	/^do_balance (CHAR_DATA * ch, char *argy)$/;"	f
do_ban	aw.c	/^void do_ban (CHAR_DATA * ch, char *argy)$/;"	f
do_bash	fgt.c	/^do_bash (CHAR_DATA * ch, char *argy)$/;"	f
do_battleground	arena.c	/^do_battleground (CHAR_DATA * ch, char *argy)$/;"	f
do_beamin	aw.c	/^void do_beamin (CHAR_DATA * ch, char *argy)$/;"	f
do_beamout	aw.c	/^void do_beamout (CHAR_DATA * ch, char *argy)$/;"	f
do_beep	config.c	/^do_beep (CHAR_DATA * ch, char *argy)$/;"	f
do_berserk	death.c	/^do_berserk (CHAR_DATA * ch, char *argy)$/;"	f
do_bet	arena.c	/^do_bet (CHAR_DATA * ch, char *argy)$/;"	f
do_bid	auction.c	/^do_bid (CHAR_DATA * ch, char *argy)	\/*By Owen Emlen *\/$/;"	f
do_bite	alien.c	/^do_bite (CHAR_DATA * ch, char *argy)$/;"	f
do_blackjack	bank.c	/^do_blackjack (CHAR_DATA * ch, char *argy)$/;"	f
do_blank	config.c	/^do_blank (CHAR_DATA * ch, char *argy)$/;"	f
do_board	boat.c	/^do_board (CHAR_DATA * ch, char *argy)$/;"	f
do_boast	look.c	/^do_boast (CHAR_DATA * ch, char *argy)$/;"	f
do_brandish	give.c	/^do_brandish (CHAR_DATA * ch, char *argy)$/;"	f
do_break	move.c	/^do_break (CHAR_DATA * ch, char *argy)$/;"	f
do_brief	config.c	/^do_brief (CHAR_DATA * ch, char *argy)$/;"	f
do_bs	fgt.c	/^do_bs (CHAR_DATA * ch, char *argy)$/;"	f
do_buck	ar.c	/^do_buck (CHAR_DATA * ch, char *argy)$/;"	f
do_bury	give.c	/^do_bury (CHAR_DATA * ch, char *argy)$/;"	f
do_busy	quit.c	/^do_busy (CHAR_DATA * ch, char *argy)$/;"	f
do_butcher	give.c	/^do_butcher (CHAR_DATA * ch, char *argy)	\/*By Arcane *\/$/;"	f
do_buy	buysell.c	/^do_buy (CHAR_DATA * ch, char *argy)$/;"	f
do_cadd	clan.c	/^do_cadd (CHAR_DATA * ch, char *argy)$/;"	f
do_cancel	arena.c	/^do_cancel (CHAR_DATA * ch, char *argy)$/;"	f
do_cast	mgc.c	/^do_cast (CHAR_DATA * ch, char *argy)$/;"	f
do_catps	alien.c	/^do_catps (CHAR_DATA * ch, char *argy)$/;"	f
do_cedit	oc.c	/^void do_cedit (CHAR_DATA * ch, char *argy)$/;"	f
do_cedit2	oc.c	/^void do_cedit2 (CHAR_DATA * ch, char *argy)$/;"	f
do_challenge	arena.c	/^do_challenge (CHAR_DATA * ch, char *argy)$/;"	f
do_chan_notify	channels.c	/^do_chan_notify (CHAR_DATA * ch, char *txt)$/;"	f
do_change	info.c	/^do_change (CHAR_DATA * ch, char *argy)$/;"	f
do_channels	config.c	/^do_channels (CHAR_DATA * ch, char *argy)$/;"	f
do_cindex	clan.c	/^do_cindex (CHAR_DATA * ch, char *argy)$/;"	f
do_cindex_2	clan.c	/^do_cindex_2 (CHAR_DATA * ch, char *argy)$/;"	f
do_circle	fgt.c	/^do_circle (CHAR_DATA * ch, char *argy)$/;"	f
do_clan	clan.c	/^do_clan (CHAR_DATA * ch, char *argy)	\/*CLANS by Owen Emlen *\/$/;"	f
do_clan_2	clan.c	/^do_clan_2 (CHAR_DATA * ch, char *argy)	\/*CLANS by Owen Emlen *\/$/;"	f
do_clan_notify	channels.c	/^do_clan_notify (CHAR_DATA * ch, char *argy)$/;"	f
do_clan_quit	clan.c	/^do_clan_quit (CHAR_DATA * ch, char *argy)$/;"	f
do_clanstore	bank.c	/^do_clanstore (CHAR_DATA * ch, char *argy)$/;"	f
do_clanunstore	bank.c	/^do_clanunstore (CHAR_DATA * ch, char *argy)$/;"	f
do_clanwar	clan.c	/^do_clanwar (CHAR_DATA * ch, char *argy)$/;"	f
do_cleanup	utils.c	/^do_cleanup (void)$/;"	f
do_clear	move.c	/^do_clear (CHAR_DATA * ch, char *argy)$/;"	f
do_climb	climb.c	/^do_climb (CHAR_DATA * ch, char *argy)$/;"	f
do_close	move.c	/^do_close (CHAR_DATA * ch, char *argy)$/;"	f
do_coins	hnd.c	/^do_coins (CHAR_DATA * ch, char *argy)$/;"	f
do_color	config.c	/^do_color (CHAR_DATA * ch, char *argy)$/;"	f
do_commands	help.c	/^do_commands (CHAR_DATA * ch, char *argy)$/;"	f
do_config	config.c	/^do_config (CHAR_DATA * ch, char *argy)$/;"	f
do_consider	consid.c	/^do_consider (CHAR_DATA * ch, char *argy)$/;"	f
do_convert	bank.c	/^do_convert (CHAR_DATA * ch, char *argy)$/;"	f
do_count	aw.c	/^do_count (CHAR_DATA * ch, char *argy)$/;"	f
do_credits	pinfo.c	/^do_credits (CHAR_DATA * ch, char *argy)$/;"	f
do_cremove	clan.c	/^do_cremove (CHAR_DATA * ch, char *argy)$/;"	f
do_ctpsr	alien.c	/^do_ctpsr (CHAR_DATA * ch, char *argy)$/;"	f
do_dam	dam.c	/^do_dam (CHAR_DATA * ch, char *argy)$/;"	f
do_decline	arena.c	/^do_decline (CHAR_DATA * ch, char *argy)$/;"	f
do_deleteold	utils.c	/^do_deleteold (void)$/;"	f
do_deposit	bank.c	/^do_deposit (CHAR_DATA * ch, char *argy)$/;"	f
do_description	config.c	/^void do_description (CHAR_DATA * ch, char *argy)$/;"	f
do_destroy	script.c	/^do_destroy (CHAR_DATA * mob, int i)$/;"	f
do_dir	look.c	/^do_dir (CHAR_DATA * ch, char *argy)$/;"	f
do_disarm	fgt.c	/^do_disarm (CHAR_DATA * ch, char *argy)$/;"	f
do_disaster	upd.c	/^do_disaster ()$/;"	f
do_disconnect	aw.c	/^void do_disconnect (CHAR_DATA * ch, char *argy)$/;"	f
do_disembark	boat.c	/^do_disembark (CHAR_DATA * ch, char *argy)$/;"	f
do_dismount	ar.c	/^do_dismount (CHAR_DATA * ch, char *argy)$/;"	f
do_down	move.c	/^do_down (CHAR_DATA * ch, char *argy)$/;"	f
do_drag	give.c	/^do_drag (CHAR_DATA * ch, char *argy)$/;"	f
do_draw	give.c	/^do_draw (CHAR_DATA * ch, char *argy)$/;"	f
do_drawmini	draw.c	/^do_drawmini (CHAR_DATA * ch, char *argy)$/;"	f
do_drawmort	draw.c	/^do_drawmort (CHAR_DATA * ch, char *argy)$/;"	f
do_drawrooms	draw.c	/^do_drawrooms (CHAR_DATA * ch, char *argy)$/;"	f
do_drawrooms1	draw.c	/^do_drawrooms1 (CHAR_DATA * ch, char *argy)$/;"	f
do_drawtop	draw.c	/^do_drawtop (CHAR_DATA * ch, char *argy)$/;"	f
do_drink	give.c	/^do_drink (CHAR_DATA * ch, char *argy)$/;"	f
do_drop	give.c	/^do_drop (CHAR_DATA * ch, char *argy)$/;"	f
do_e_bid	auction.c	/^do_e_bid (CHAR_DATA * ch, char *argy)$/;"	f
do_e_tauction	auction.c	/^do_e_tauction (CHAR_DATA * ch, char *argy)	\/*By Owen Emlen *\/$/;"	f
do_east	move.c	/^do_east (CHAR_DATA * ch, char *argy)$/;"	f
do_eat	give.c	/^do_eat (CHAR_DATA * ch, char *argy)$/;"	f
do_echo	aw.c	/^void do_echo (CHAR_DATA * ch, char *argy)$/;"	f
do_effect	score.c	/^do_effect (CHAR_DATA * ch, char *argy)$/;"	f
do_emote	channels.c	/^do_emote (CHAR_DATA * ch, char *argy)$/;"	f
do_emote2	channels.c	/^do_emote2 (CHAR_DATA * ch, char *argy)$/;"	f
do_empty	give.c	/^do_empty (CHAR_DATA * ch, char *argy)$/;"	f
do_enter	move.c	/^do_enter (CHAR_DATA * ch, char *argy)$/;"	f
do_equipment	look.c	/^do_equipment (CHAR_DATA * ch, char *argy)$/;"	f
do_examine	look.c	/^do_examine (CHAR_DATA * ch, char *argy)$/;"	f
do_exchange	give.c	/^do_exchange (CHAR_DATA * ch, char *argy)$/;"	f
do_exits	look.c	/^do_exits (CHAR_DATA * ch, char *argy)$/;"	f
do_extinguish	give.c	/^do_extinguish (CHAR_DATA * ch, char *argy)$/;"	f
do_fatal	death.c	/^do_fatal (CHAR_DATA * victim, CHAR_DATA * ch, int dt)$/;"	f
do_fight	config.c	/^do_fight (CHAR_DATA * ch, char *argy)$/;"	f
do_fill	give.c	/^do_fill (CHAR_DATA * ch, char *argy)$/;"	f
do_finger	pinfo.c	/^do_finger (CHAR_DATA * ch, char *argy)$/;"	f
do_flash	fgt.c	/^do_flash (CHAR_DATA * ch, char *argy)$/;"	f
do_flee	fgt.c	/^do_flee (CHAR_DATA * ch, char *argy)$/;"	f
do_flurry	fgt.c	/^do_flurry (CHAR_DATA * ch, char *argy)$/;"	f
do_fly	move.c	/^do_fly (CHAR_DATA * ch, char *argy)$/;"	f
do_force	aw.c	/^do_force (CHAR_DATA * ch, char *argy)$/;"	f
do_forge	create.c	/^void do_forge(CHAR_DATA * ch, char * argy)$/;"	f
do_forward	oc.c	/^void do_forward (CHAR_DATA * ch, char *argy)$/;"	f
do_freeze	aw.c	/^void do_freeze (CHAR_DATA * ch, char *argy)$/;"	f
do_fun	emlen.h	/^  DO_COMMAND *do_fun;		\/* Command executes this function *\/$/;"	m	struct:cmd_type
do_garea	aw.c	/^do_garea (CHAR_DATA * ch, char *argy)$/;"	f
do_gen_gos	channels.c	/^do_gen_gos (CHAR_DATA * ch, char *argy)$/;"	f
do_get	give.c	/^do_get (CHAR_DATA * ch, char *argy)$/;"	f
do_give	give.c	/^do_give (CHAR_DATA * ch, char *argy)$/;"	f
do_glance	look.c	/^do_glance (CHAR_DATA * ch, char *argy)$/;"	f
do_global	channels.c	/^do_global (char *buf, int level, int toggler)$/;"	f
do_goto	aw.c	/^void do_goto (CHAR_DATA * ch, char *argy)$/;"	f
do_grepit	comm.c	/^do_grepit (DESCRIPTOR_DATA * d, char *txt, int max_lines)$/;"	f
do_group_consider	consid.c	/^do_group_consider (CHAR_DATA * ch, char *argy)$/;"	f
do_grunt	alien.c	/^do_grunt (CHAR_DATA * ch, char *argy)$/;"	f
do_gtell	channels.c	/^do_gtell (CHAR_DATA * ch, char *argy)$/;"	f
do_gtell2	channels.c	/^do_gtell2 (CHAR_DATA * ch, char *argy)$/;"	f
do_guild	guild.c	/^do_guild (CHAR_DATA * ch, char *argy)$/;"	f
do_hands	alien.c	/^do_hands (CHAR_DATA * ch, char *argy)$/;"	f
do_headbutt	alien.c	/^do_headbutt (CHAR_DATA * ch, char *argy)$/;"	f
do_hedit	hedit.c	/^do_hedit (CHAR_DATA * ch, char *argy)$/;"	f
do_help	info.c	/^do_help (CHAR_DATA * ch, char *argy)$/;"	f
do_hide	move.c	/^do_hide (CHAR_DATA * ch, char *argy)$/;"	f
do_hold	give.c	/^do_hold (CHAR_DATA * ch, char *argy)$/;"	f
do_holylag	aw.c	/^do_holylag (CHAR_DATA * ch, char *argy)$/;"	f
do_holylight	aw.c	/^do_holylight (CHAR_DATA * ch, char *argy)$/;"	f
do_holypeace	aw.c	/^do_holypeace (CHAR_DATA * ch, char *argy)$/;"	f
do_holywalk	aw.c	/^do_holywalk (CHAR_DATA * ch, char *argy)$/;"	f
do_ignore	channels.c	/^do_ignore (CHAR_DATA * ch, char *argy)$/;"	f
do_implant	alien.c	/^do_implant (CHAR_DATA * ch, char *argy)$/;"	f
do_info	score.c	/^do_info (CHAR_DATA * ch, char *argy)$/;"	f
do_info_sp_sk	skill.c	/^do_info_sp_sk (CHAR_DATA * ch, SPELL_DATA * spell)$/;"	f
do_inventory	look.c	/^do_inventory (CHAR_DATA * ch, char *argy)$/;"	f
do_investigate	death.c	/^do_investigate (CHAR_DATA * ch, char *argy)$/;"	f
do_invis	aw.c	/^do_invis (CHAR_DATA * ch, char *argy)$/;"	f
do_it	yell.c	/^do_it (CHAR_DATA * ch, ROOM_DATA * rid, int strength, short came_from)$/;"	f
do_kick	fgt.c	/^do_kick (CHAR_DATA * ch, char *argy)$/;"	f
do_kill	fgt.c	/^do_kill (CHAR_DATA * ch, char *argy)$/;"	f
do_land	move.c	/^do_land (CHAR_DATA * ch, char *argy)$/;"	f
do_learn	skill.c	/^do_learn (CHAR_DATA * ch, char *argy)$/;"	f
do_leave	move.c	/^do_leave (CHAR_DATA * ch, char *argy)$/;"	f
do_levels	info.c	/^do_levels (CHAR_DATA * ch, char *argy)$/;"	f
do_light	give.c	/^do_light (CHAR_DATA * ch, char *argy)$/;"	f
do_limited	remort.c	/^do_limited (CHAR_DATA * ch, char *argy)$/;"	f
do_linkless	aw.c	/^do_linkless (CHAR_DATA * ch, char *argy)$/;"	f
do_list	buysell.c	/^do_list (CHAR_DATA * ch, char *argy)$/;"	f
do_list_done_quests	script.c	/^do_list_done_quests (CHAR_DATA * ch, char *argy)$/;"	f
do_lock	move.c	/^do_lock (CHAR_DATA * ch, char *argy)$/;"	f
do_log	aw.c	/^do_log (CHAR_DATA * ch, char *argy)$/;"	f
do_look	look.c	/^do_look (CHAR_DATA * ch, char *argy)$/;"	f
do_lowlevel_help	info.c	/^do_lowlevel_help (CHAR_DATA * ch, char *argy)$/;"	f
do_mat	aw.c	/^void do_mat (CHAR_DATA * ch, char *argy)$/;"	f
do_mcopy	oedit.c	/^do_mcopy (CHAR_DATA * ch, char *argy)$/;"	f
do_medit	oc.c	/^void do_medit (CHAR_DATA * ch, char *argy)$/;"	f
do_meditate	give.c	/^do_meditate (CHAR_DATA * ch, char *argy)$/;"	f
do_memory	db2.c	/^void do_memory (CHAR_DATA * ch, char *argy)$/;"	f
do_mfind	aw.c	/^void do_mfind (CHAR_DATA * ch, char *argy)$/;"	f
do_mindex	oc.c	/^void do_mindex (CHAR_DATA * ch, char *argy)$/;"	f
do_mindexc	oc.c	/^void do_mindexc (CHAR_DATA * ch, char *argy, bool windowed)$/;"	f
do_mine	create.c	/^void do_mine (CHAR_DATA *ch, char *argy)$/;"	f
do_mload	aw.c	/^void do_mload (CHAR_DATA * ch, char *argy)$/;"	f
do_mobscatter	alien.c	/^do_mobscatter (CHAR_DATA * ch, char *argy)$/;"	f
do_mount	ar.c	/^do_mount (CHAR_DATA * ch, char *argy)$/;"	f
do_mplay	int.c	/^void do_mplay (CHAR_DATA * ch, char *argy)$/;"	f
do_mreset	upd.c	/^do_mreset (CHAR_DATA * ch, char *argy)$/;"	f
do_mset	aw.c	/^do_mset (CHAR_DATA * ch, char *argy)$/;"	f
do_mstat	aw.c	/^void do_mstat (CHAR_DATA * ch, char *argy)$/;"	f
do_mudmap	info.c	/^do_mudmap (CHAR_DATA * ch, char *argy)$/;"	f
do_mwhere	aw.c	/^void do_mwhere (CHAR_DATA * ch, char *argy)$/;"	f
do_nban	aw.c	/^do_nban (CHAR_DATA * ch, char *argy)$/;"	f
do_new_prereq	skill.c	/^void do_new_prereq (CHAR_DATA *ch, char *argy)$/;"	f
do_nfrm	note.c	/^do_nfrm (CHAR_DATA * ch, char *argy)$/;"	f
do_noaffect	aw.c	/^do_noaffect (CHAR_DATA * ch, char *argy)$/;"	f
do_nodelete	remort.c	/^do_nodelete (CHAR_DATA * ch, char *argy)$/;"	f
do_north	move.c	/^do_north (CHAR_DATA * ch, char *argy)$/;"	f
do_note	note.c	/^do_note (CHAR_DATA * ch, char *argy)$/;"	f
do_notestats	note.c	/^do_notestats (CHAR_DATA * ch, char *argy)$/;"	f
do_notify	aw.c	/^do_notify (CHAR_DATA * ch, char *argy)$/;"	f
do_ocopy	oedit.c	/^do_ocopy (CHAR_DATA * ch, char *argy)$/;"	f
do_oedit	oc.c	/^void do_oedit (CHAR_DATA * ch, char *argy)$/;"	f
do_ofind	aw.c	/^void do_ofind (CHAR_DATA * ch, char *argy)$/;"	f
do_oindex	oc.c	/^void do_oindex (CHAR_DATA * ch, char *argy)$/;"	f
do_oload	aw.c	/^void do_oload (CHAR_DATA * ch, char *argy)$/;"	f
do_open	move.c	/^do_open (CHAR_DATA * ch, char *argy)$/;"	f
do_order	pets.c	/^void do_order (CHAR_DATA* ch, char* argy)$/;"	f
do_oreset	upd.c	/^do_oreset (CHAR_DATA * ch, char *argy)$/;"	f
do_oset	aw.c	/^do_oset (CHAR_DATA * ch, char *argy)$/;"	f
do_ostat	aw.c	/^void do_ostat (CHAR_DATA * ch, char *argy)$/;"	f
do_owhere	aw.c	/^do_owhere (CHAR_DATA * ch, char *argy)$/;"	f
do_pagelen	config.c	/^do_pagelen (CHAR_DATA * ch, char *argy)$/;"	f
do_password	look.c	/^do_password (CHAR_DATA * ch, char *argy)$/;"	f
do_pdelete	remort.c	/^do_pdelete (CHAR_DATA * ch, char *argy)$/;"	f
do_peace	aw.c	/^void do_peace (CHAR_DATA * ch, char *argy)$/;"	f
do_pedit	pedit.c	/^do_pedit (CHAR_DATA * ch, char *argy)$/;"	f
do_phedit	config.c	/^void do_phedit (CHAR_DATA * ch, char *argy) \/\/ Kenor '03$/;"	f
do_pick	move.c	/^do_pick (CHAR_DATA * ch, char *argy)$/;"	f
do_players	remort.c	/^do_players (CHAR_DATA * ch, char *argy)$/;"	f
do_poll	poll.c	/^do_poll (CHAR_DATA * ch, char *argy)$/;"	f
do_practice	skill.c	/^do_practice (CHAR_DATA * ch, char *argy)$/;"	f
do_prereqs	skill.c	/^do_prereqs (CHAR_DATA * ch, char *argy)$/;"	f
do_preset	aw.c	/^do_preset (CHAR_DATA * ch, char *argy)	\/*BY Owen Emlen *\/$/;"	f
do_prof	alien.c	/^do_prof (CHAR_DATA * ch, char *argy)$/;"	f
do_prompt	config.c	/^do_prompt (CHAR_DATA * ch, char *argy)$/;"	f
do_pset	aw.c	/^do_pset (CHAR_DATA * ch, char *argy)$/;"	f
do_pstat	aw.c	/^void do_pstat (CHAR_DATA * ch, char *argy)$/;"	f
do_purge	aw.c	/^void do_purge (CHAR_DATA * ch, char *argy)$/;"	f
do_purgearea	upd.c	/^do_purgearea (CHAR_DATA * ch, char *argy)$/;"	f
do_purse	look.c	/^do_purse (CHAR_DATA * ch, char *argy)$/;"	f
do_put	give.c	/^do_put (CHAR_DATA * ch, char *argy)$/;"	f
do_quaff	give.c	/^do_quaff (CHAR_DATA * ch, char *argy)$/;"	f
do_quest	quest.c	/^void do_quest(CHAR_DATA *ch, char *argy)$/;"	f
do_quests	db2.c	/^do_quests (CHAR_DATA * ch, char *argy)$/;"	f
do_qui	quit.c	/^do_qui (CHAR_DATA * ch, char *argy)$/;"	f
do_quiet	channels.c	/^do_quiet (CHAR_DATA * ch, char *argy)$/;"	f
do_quit	quit.c	/^do_quit (CHAR_DATA * ch, char *argy)$/;"	f
do_r	info.c	/^do_r (CHAR_DATA * ch, char *argy)$/;"	f
do_raccess	int.c	/^do_raccess (CHAR_DATA * ch, char *argy)$/;"	f
do_raceinfo	info.c	/^do_raceinfo (CHAR_DATA * ch, char *argy)$/;"	f
do_random_split	pc_wiz.c	/^do_random_split (CHAR_DATA * ch , char *argy) {$/;"	f
do_rank	config.c	/^do_rank (CHAR_DATA * ch, char *argy)	\/\/ Kenor '03$/;"	f
do_rating	toptr.c	/^do_rating (CHAR_DATA * ch, char *argy)$/;"	f
do_rawclear	move.c	/^do_rawclear (CHAR_DATA * ch)$/;"	f
do_rcopy	oedit.c	/^do_rcopy (CHAR_DATA * ch, char *argy)$/;"	f
do_read	give.c	/^do_read (CHAR_DATA * ch, char *argy)$/;"	f
do_reboo	aw.c	/^void do_reboo (CHAR_DATA * ch, char *argy)$/;"	f
do_reboot	aw.c	/^void do_reboot (CHAR_DATA * ch, char *argy)$/;"	f
do_recall	move.c	/^do_recall (CHAR_DATA * ch, char *argy)$/;"	f
do_recallc	death.c	/^do_recallc (CHAR_DATA * ch, char *argy)$/;"	f
do_recho	aw.c	/^void do_recho (CHAR_DATA * ch, char *argy)$/;"	f
do_recite	give.c	/^do_recite (CHAR_DATA * ch, char *argy)$/;"	f
do_redit	oc.c	/^void do_redit (CHAR_DATA * ch, char *argy)$/;"	f
do_refresh	utils.c	/^do_refresh (void)$/;"	f
do_reload_help	info.c	/^do_reload_help (CHAR_DATA * ch, char *argy)$/;"	f
do_remortcost	info.c	/^do_remortcost (CHAR_DATA * ch, char *argy)$/;"	f
do_remove	give.c	/^do_remove (CHAR_DATA * ch, char *argy)$/;"	f
do_repair	buysell.c	/^do_repair (CHAR_DATA * ch, char *argy)$/;"	f
do_reply	channels.c	/^do_reply (CHAR_DATA * ch, char *argy)$/;"	f
do_repop	aedit.c	/^do_repop (CHAR_DATA * ch, char *argy)$/;"	f
do_report	look.c	/^do_report (CHAR_DATA * ch, char *argy)$/;"	f
do_rescue	fgt.c	/^do_rescue (CHAR_DATA * ch, char *argy)$/;"	f
do_resets	oc.c	/^void do_resets (CHAR_DATA * ch, char *argy)$/;"	f
do_resize	buysell.c	/^do_resize (CHAR_DATA * ch, char *argy)$/;"	f
do_rest	move.c	/^do_rest (CHAR_DATA * ch, char *argy)$/;"	f
do_restore	aw.c	/^void do_restore (CHAR_DATA * ch, char *argy)$/;"	f
do_return	aw.c	/^void do_return (CHAR_DATA * ch, char *argy)$/;"	f
do_rfind	aw.c	/^void do_rfind (CHAR_DATA * ch, char *argy)$/;"	f
do_rpstat	aw.c	/^void do_rpstat (CHAR_DATA * ch, char *argy)$/;"	f
do_rstat	aw.c	/^void do_rstat (CHAR_DATA * ch, char *argy)$/;"	f
do_run	move.c	/^do_run (CHAR_DATA * ch, char *argy)$/;"	f
do_sacrifice	give.c	/^do_sacrifice (CHAR_DATA * ch, char *argy)$/;"	f
do_say	channels.c	/^do_say (CHAR_DATA * ch, char *argy)$/;"	f
do_say2	channels.c	/^do_say2 (CHAR_DATA * ch, char *argy)$/;"	f
do_scan	look.c	/^do_scan (CHAR_DATA * ch, char *argy)$/;"	f
do_scatter	alien.c	/^do_scatter (CHAR_DATA * ch, char *argy)$/;"	f
do_score	score.c	/^do_score (CHAR_DATA * ch, char *argy)$/;"	f
do_scriptline	script.c	/^do_scriptline (CHAR_DATA * mob, CHAR_DATA * player, SINGLE_OBJECT * obj)$/;"	f
do_scriptr	script.c	/^do_scriptr (CHAR_DATA * ch, char *argy)$/;"	f
do_search	look.c	/^do_search (CHAR_DATA * ch, char *argy)$/;"	f
do_secretlog	db2.c	/^do_secretlog (CHAR_DATA * ch, char *argy)$/;"	f
do_sedit	sedit.c	/^do_sedit (CHAR_DATA * ch, char *argy)$/;"	f
do_sell	buysell.c	/^do_sell (CHAR_DATA * ch, char *argy)$/;"	f
do_set_fighters	arena.c	/^do_set_fighters (CHAR_DATA * ch, char *argy)$/;"	f
do_setlevels	arena.c	/^do_setlevels (CHAR_DATA * ch, char *argy)$/;"	f
do_setmiw	upd.c	/^do_setmiw (CHAR_DATA * ch, char *argy)$/;"	f
do_setroom	oc.c	/^do_setroom (CHAR_DATA * ch, char *argy)$/;"	f
do_sforce	int.c	/^void do_sforce (CHAR_DATA * ch, char *argy)$/;"	f
do_sheath	give.c	/^do_sheath (CHAR_DATA * ch, char *argy)$/;"	f
do_shell	pc_wiz.c	/^do_shell (CHAR_DATA * ch, char *argy)$/;"	f
do_showloot	look.c	/^do_showloot (CHAR_DATA * ch, char *argy)$/;"	f
do_showskills	skill.c	/^do_showskills (CHAR_DATA * ch, char *argy)$/;"	f
do_showspells	skill.c	/^do_showspells (CHAR_DATA * ch, char *argy)$/;"	f
do_silence	aw.c	/^do_silence (CHAR_DATA * ch, char *argy)$/;"	f
do_sing	death.c	/^do_sing (CHAR_DATA * ch, char *argy)$/;"	f
do_skill	skill.c	/^do_skill (CHAR_DATA * ch, char *argy)$/;"	f
do_sla	fgt.c	/^do_sla (CHAR_DATA * ch, char *argy)$/;"	f
do_slam	alien.c	/^do_slam (CHAR_DATA * ch, char *argy)$/;"	f
do_slay	fgt.c	/^do_slay (CHAR_DATA * ch, char *argy)$/;"	f
do_sleep	move.c	/^do_sleep (CHAR_DATA * ch, char *argy)$/;"	f
do_slist	skill.c	/^do_slist (CHAR_DATA * ch, char *argy)$/;"	f
do_slookup	aw.c	/^do_slookup (CHAR_DATA * ch, char *argy)$/;"	f
do_sneak	move.c	/^do_sneak (CHAR_DATA * ch, char *argy)$/;"	f
do_snoop	aw.c	/^void do_snoop (CHAR_DATA * ch, char *argy)$/;"	f
do_soc_edit	oc.c	/^void do_soc_edit (CHAR_DATA * ch, char *argy)$/;"	f
do_socials	help.c	/^do_socials (CHAR_DATA * ch, char *argy)$/;"	f
do_south	move.c	/^do_south (CHAR_DATA * ch, char *argy)$/;"	f
do_spells	skill.c	/^do_spells (CHAR_DATA * ch, char *argy)$/;"	f
do_spico_help	pc_wiz.c	/^do_spico_help (CHAR_DATA * ch, char *argy)$/;"	f
do_spray	spl.c	/^do_spray (CHAR_DATA * ch, char *argy)$/;"	f
do_sset	aw.c	/^do_sset (CHAR_DATA * ch, char *argy)$/;"	f
do_stand	move.c	/^do_stand (CHAR_DATA * ch, char *argy)$/;"	f
do_steal	give.c	/^do_steal (CHAR_DATA * ch, char *argy)$/;"	f
do_store	bank.c	/^do_store (CHAR_DATA * ch, char *argy)$/;"	f
do_study	give.c	/^do_study (CHAR_DATA * ch, char *argy)$/;"	f
do_swap	give.c	/^do_swap (CHAR_DATA * ch, char *argy)$/;"	f
do_switch	aw.c	/^void do_switch (CHAR_DATA * ch, char *argy)$/;"	f
do_tackle	fgt.c	/^do_tackle (CHAR_DATA * ch, char *argy)$/;"	f
do_take	give.c	/^do_take (CHAR_DATA * ch, char *argy)$/;"	f
do_tap	channels.c	/^do_tap (CHAR_DATA * ch, char *argy)$/;"	f
do_tauction	auction.c	/^do_tauction (CHAR_DATA * ch, char *argy)	\/*By Owen Emlen *\/$/;"	f
do_tell	channels.c	/^do_tell (CHAR_DATA * ch, char *argy)$/;"	f
do_thrust	fgt.c	/^do_thrust (CHAR_DATA * ch, char *argy)$/;"	f
do_time	info.c	/^do_time (CHAR_DATA * ch, char *argy)$/;"	f
do_title	config.c	/^do_title (CHAR_DATA * ch, char *argy)$/;"	f
do_todo	info.c	/^do_todo (CHAR_DATA * ch, char *argy)$/;"	f
do_topten	toptr.c	/^do_topten (CHAR_DATA * ch, char *argy)$/;"	f
do_track	ar.c	/^do_track (CHAR_DATA * ch, char *argy)$/;"	f
do_track_t	ar.c	/^do_track_t (CHAR_DATA * ch, char *argy)$/;"	f
do_transfer	aw.c	/^void do_transfer (CHAR_DATA * ch, char *argy)$/;"	f
do_trophy	toptr.c	/^do_trophy (CHAR_DATA * ch, char *argy)$/;"	f
do_unlearn	aw.c	/^do_unlearn (CHAR_DATA * ch, char *argy)$/;"	f
do_unlock	move.c	/^do_unlock (CHAR_DATA * ch, char *argy)$/;"	f
do_unstore	bank.c	/^do_unstore (CHAR_DATA * ch, char *argy)$/;"	f
do_up	move.c	/^do_up (CHAR_DATA * ch, char *argy)$/;"	f
do_users	aw.c	/^do_users (CHAR_DATA * ch, char *argy)$/;"	f
do_value	buysell.c	/^do_value (CHAR_DATA * ch, char *argy)$/;"	f
do_vbite	alien.c	/^do_vbite (CHAR_DATA * ch, char *argy)$/;"	f
do_visible	move.c	/^do_visible (CHAR_DATA * ch, char *argy)$/;"	f
do_vscore	score.c	/^do_vscore (CHAR_DATA * ch, char *argy)$/;"	f
do_vwho	info.c	/^do_vwho (CHAR_DATA * ch, char *argy)$/;"	f
do_wake	move.c	/^do_wake (CHAR_DATA * ch, char *argy)$/;"	f
do_weapon	skill.c	/^do_weapon (CHAR_DATA * ch, char *argy)$/;"	f
do_wear	give.c	/^do_wear (CHAR_DATA * ch, char *argy)$/;"	f
do_weather	info.c	/^do_weather (CHAR_DATA * ch, char *argy)$/;"	f
do_weight	score.c	/^do_weight (CHAR_DATA * ch, char *argy)$/;"	f
do_west	move.c	/^do_west (CHAR_DATA * ch, char *argy)$/;"	f
do_where	look.c	/^do_where (CHAR_DATA * ch, char *argy)$/;"	f
do_who	info.c	/^do_who (CHAR_DATA * ch, char *argy)$/;"	f
do_wield	give.c	/^do_wield (CHAR_DATA * ch, char *argy)$/;"	f
do_wimpy	config.c	/^do_wimpy (CHAR_DATA * ch, char *argy)$/;"	f
do_withdraw	bank.c	/^do_withdraw (CHAR_DATA * ch, char *argy)$/;"	f
do_wizlist	info.c	/^do_wizlist (CHAR_DATA * ch, char *argy)$/;"	f
do_wizlock	aw.c	/^do_wizlock (CHAR_DATA * ch, char *argy)$/;"	f
do_world	db2.c	/^void do_world (CHAR_DATA * ch, char *argy)$/;"	f
do_yell	channels.c	/^do_yell (CHAR_DATA * ch, char *argy)$/;"	f
do_zap	give.c	/^do_zap (CHAR_DATA * ch, char *argy)$/;"	f
dodge	emlen.h	/^  unsigned char dodge;		\/* Extra dodge bonus. *\/$/;"	m	struct:mob_proto_data
doecho	comm.c	/^char doecho[] = {$/;"	v
doiecho	edit.c	/^char doiecho[] = { 255, 253, 1, '\\0' };$/;"	v
dolinemode	edit.c	/^char dolinemode[] = { 255, 253, 34, '\\0' };$/;"	v
donated	emlen.h	/^  int donated;			\/* Donated value *\/$/;"	m	struct:pc_data
dontecho	comm.c	/^char dontecho[] = {$/;"	v
dontiecho	edit.c	/^char dontiecho[] = { 255, 254, 1, '\\0' };$/;"	v
dontlinemode	edit.c	/^char dontlinemode[] = { 255, 254, 34, '\\0' };$/;"	v
door	emlen.h	/^  char door;			\/* v0 *\/$/;"	m	struct:item_blood
door_cond	move.c	/^	  char *door_cond (int val)$/;"	f
door_data	emlen.h	/^struct door_data$/;"	s
dragon	spec.c	/^dragon (CHAR_DATA * ch, char *spell_name)$/;"	f
draw_data	draw.c	/^draw_data (CHAR_DATA * ch, int lines)$/;"	f
draw_menu	menu.c	/^draw_menu (CHAR_DATA * ch)$/;"	f
draw_mp	menu.c	/^draw_mp (CHAR_DATA * ch)$/;"	f
draw_obj	give.c	/^draw_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
drawit	draw.c	/^drawit (CHAR_DATA * ch, char *argy)$/;"	f
dum	upd.c	/^dum (void)$/;"	f
dummy_pc	crsh.c	/^dummy_pc (void)$/;"	f
dummycall	upd.c	/^dummycall ()$/;"	f
duration	emlen.h	/^  char *duration;		\/* Needs to be a string so we can have vars *\/$/;"	m	struct:spell_data
duration	emlen.h	/^  short duration;		\/* duration of affect *\/$/;"	m	struct:affect_data
e_auction_bid	db2.c	/^int e_auction_bid;$/;"	v
e_auction_char	db2.c	/^CHAR_DATA *e_auction_char;$/;"	v
e_auction_going	db2.c	/^short e_auction_going;$/;"	v
e_auction_item	db2.c	/^char e_auction_item[500];$/;"	v
e_auction_item_e	db2.c	/^SINGLE_OBJECT *e_auction_item_e;$/;"	v
e_auction_lastbidder	auction.c	/^CHAR_DATA *e_auction_lastbidder = NULL;$/;"	v
e_auction_minbid	db2.c	/^int e_auction_minbid;$/;"	v
e_auction_tochar	db2.c	/^CHAR_DATA *e_auction_tochar;$/;"	v
e_auction_update	auction.c	/^e_auction_update (void)$/;"	f
e_auto_xfer	db2.c	/^bool e_auto_xfer;$/;"	v
e_bad_destroy_num	script3.c	/^void e_bad_destroy_num (SCRIPT_INFO * scr, char *ln)$/;"	f
e_bad_if	script3.c	/^void e_bad_if (SCRIPT_INFO * scr, char *ln)$/;"	f
e_bad_wait_type	script3.c	/^void e_bad_wait_type (SCRIPT_INFO * scr, char *typ)$/;"	f
e_bad_wait_value	script3.c	/^void e_bad_wait_value (SCRIPT_INFO * scr, char *cmd)$/;"	f
e_bidders	auction.c	/^int e_bidders = 0;$/;"	v
e_buf	script3.c	/^  char e_buf[500]; int executed_lines = 0;	\/* Keeps track of lines executed.. traps repeating loops *\/$/;"	v
e_couldnt_find_label	script3.c	/^e_couldnt_find_label (SCRIPT_INFO * scr, char *lab,$/;"	f
e_goto_invalid_line_number	script3.c	/^e_goto_invalid_line_number (SCRIPT_INFO * scr, char *ln,$/;"	f
e_invalid_create_mob	script3.c	/^void e_invalid_create_mob (SCRIPT_INFO * scr, char *ln)$/;"	f
e_invalid_create_obj	script3.c	/^void e_invalid_create_obj (SCRIPT_INFO * scr, char *ln)$/;"	f
e_repeating_loop	script3.c	/^void e_repeating_loop (SCRIPT_INFO * scr)$/;"	f
ears	emlen.h	/^  short ears;			\/* Ears left, and internally used *\/$/;"	m	struct:fight_data
easier_moves	emlen.h	/^  bool easier_moves;		\/* Easier movement method *\/$/;"	m	struct:power_data
echo_off_str	comm.c	/^char echo_off_str[] = {$/;"	v
echo_on_str	comm.c	/^char echo_on_str[] = {$/;"	v
edit_note	emlen.h	/^  bool edit_note;$/;"	m	struct:pc_data
effects	emlen.h	/^  int effects;			\/* Default effects.. unused *\/$/;"	m	struct:obj_proto_data
elbow	grnd.c	/^elbow (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
email	emlen.h	/^  char email[45];		\/* Email address *\/$/;"	m	struct:pc_data
email_address	emlen.h	/^  char email_address[45];	\/* Player's email addy *\/$/;"	m	struct:playerbase_data
email_to	emlen.h	/^  char email_to[50];		\/* Email to here for validation *\/$/;"	m	struct:power_data
encrypt_names	telnet.h	/^char *encrypt_names[] = {$/;"	v
enctype_names	telnet.h	/^char *enctype_names[] = {$/;"	v
end_arena	arena.c	/^end_arena (CHAR_DATA * winner, CHAR_DATA * loser)$/;"	f
end_script	script3.c	/^void end_script (SCRIPT_INFO * scr)$/;"	f
enter_game	comm.c	/^enter_game (DESCRIPTOR_DATA * d)$/;"	f
enter_menu	menu.c	/^enter_menu (CHAR_DATA * ch, char *argy)$/;"	f
eqlist	emlen.h	/^  short eqlist;$/;"	m	struct:pc_data
equip_char	hnd.c	/^equip_char (CHAR_DATA * ch, SINGLE_OBJECT * obj, int iWear)$/;"	f
equip_in_combat	emlen.h	/^  bool equip_in_combat;		\/* Equip armor in combat? *\/$/;"	m	struct:power_data
evaluate_random	script.c	/^evaluate_random (char *arg)$/;"	f
evil	conflict.c	/^char *evil;$/;"	v
evil_can_cast	emlen.h	/^  bool evil_can_cast;		\/* Evil can cast spells? *\/$/;"	m	struct:power_data
evil_good	emlen.h	/^  bool evil_good;		\/* Evil\/Good conflict? *\/$/;"	m	struct:power_data
evil_kill_evil	emlen.h	/^  bool evil_kill_evil;$/;"	m	struct:power_data
exc_set	comm.c	/^static fd_set exc_set;$/;"	v	file:
execute_code	script3.c	/^void execute_code (SCRIPT_INFO * scr)$/;"	f
executed_lines	script3.c	/^  char e_buf[500]; int executed_lines = 0;	\/* Keeps track of lines executed.. traps repeating loops *\/$/;"	v
exit	emlen.h	/^  EXIT_DATA *exit[MAX_DIR];	\/* Exits from this room *\/$/;"	m	struct:room_data
exit_data	emlen.h	/^struct exit_data$/;"	s
exit_flag	db2.c	/^int exit_flag (int flag)$/;"	f
exit_info	emlen.h	/^  short exit_info;		\/* Exit flags, mostly compat with diku *\/$/;"	m	struct:door_data
exp	emlen.h	/^  unsigned long exp;		\/* Experience, or experience worth for mobs *\/$/;"	m	struct:char_data
exp_table	int.c	/^unsigned long exp_table[100] = {$/;"	v
exp_to_level	emlen.h	/^  char *exp_to_level;		\/* Interpretted exp to level. *\/$/;"	m	struct:power_data
extra_bit_name	hnd.c	/^extra_bit_name (int extra_flags)$/;"	f
extra_descr	emlen.h	/^  DESCRIPTION_DATA *extra_descr;	\/* Extra description list *\/$/;"	m	struct:obj_proto_data
extra_descr	emlen.h	/^  DESCRIPTION_DATA *extra_descr;	\/* Extra descriptions in room *\/$/;"	m	struct:room_extended
extra_descr_data	emlen.h	/^struct extra_descr_data$/;"	s
extra_descr_free	db2.c	/^DESCRIPTION_DATA *extra_descr_free = NULL;$/;"	v
extra_descr_free	oc.c	/^DESCRIPTION_DATA *extra_descr_free;$/;"	v
extra_flags	emlen.h	/^  int extra_flags;		\/* Extra object flags *\/$/;"	m	struct:obj_data
extra_flags	emlen.h	/^  int extra_flags;		\/* Extra object flags, bonuses, etc *\/$/;"	m	struct:obj_proto_data
extra_flagss	def.c	/^const struct flag_data extra_flagss[] = {$/;"	v	typeref:struct:flag_data
extra_name_bit	hnd.c	/^extra_name_bit (char *buf)$/;"	f
extract_char	hnd.c	/^extract_char (CHAR_DATA * ch, bool fPull)$/;"	f
f	sv.c	/^FILE *f = NULL;$/;"	v
fBootDb	db2.c	/^bool fBootDb;$/;"	v
fLogAll	int.c	/^bool fLogAll = FALSE;$/;"	v
f_first	db2.c	/^CHAR_DATA *f_first = NULL;$/;"	v
fade_tracks	upd.c	/^fade_tracks(void)$/;"	f
false	emlen.h	12;"	d
fatality	grnd.c	/^fatality (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
fcheck_pbase	pb.c	/^fcheck_pbase (char *n)$/;"	f
fdpair	emlen.h	/^  int fdpair[2];		\/* File desc pair for shelling *\/$/;"	m	struct:descriptor_data
ffg	comm.c	/^FILE *ffg;$/;"	v
fgt	emlen.h	/^  FGT *fgt;			\/* Fight data *\/$/;"	m	struct:char_data
field	emlen.h	/^  COMBAT_FIELD *field;$/;"	m	struct:fight_data
field_list	combat.c	/^COMBAT_FIELD *field_list = NULL;$/;"	v
field_move	combat.c	/^field_move (CHAR_DATA * ch, int dir)$/;"	f
field_ticks	emlen.h	/^  char field_ticks;$/;"	m	struct:fight_data
fight_data	emlen.h	/^struct fight_data$/;"	s
fight_ops	emlen.h	/^  int fight_ops;		\/* Fighting options, via 'fight' command *\/$/;"	m	struct:ced
fighters	emlen.h	/^  char fighters[2][17];		\/*[0] and [1] hold the two fighters' names *\/$/;"	m	struct:bid_data
fighting	emlen.h	/^  CHAR_DATA *fighting;		\/* Currently fighting *\/$/;"	m	struct:fight_data
filename	emlen.h	/^  char *filename;		\/* Area filename *\/$/;"	m	struct:area_data
find_arm_protection	armor.c	/^find_arm_protection (CHAR_DATA * ch, int attack_type)$/;"	f
find_attack_direction	combat.c	/^find_attack_direction (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
find_body_protection	armor.c	/^find_body_protection (CHAR_DATA * ch, int attack_type)$/;"	f
find_char_mana	mgc.c	/^find_char_mana (CHAR_DATA * ch, int bit, int sn)$/;"	f
find_clan_in	bank.c	/^find_clan_in (CHAR_DATA * ch)$/;"	f
find_code	script3.c	/^CODE * find_code (char *id)$/;"	f
find_connection_num	channels.c	/^find_connection_num (DESCRIPTOR_DATA * d)$/;"	f
find_coord	room.c	/^find_coord (short x, short y, char z)$/;"	f
find_door	move.c	/^find_door (CHAR_DATA * ch, char *arg)$/;"	f
find_first_step	ar.c	/^find_first_step (ROOM_DATA * src, ROOM_DATA * target)$/;"	f
find_flee_direction	combat.c	/^find_flee_direction (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
find_head_protection	armor.c	/^find_head_protection (CHAR_DATA * ch, int attack_type)$/;"	f
find_keeper	buysell.c	/^find_keeper (CHAR_DATA * ch)$/;"	f
find_leg_protection	armor.c	/^find_leg_protection (CHAR_DATA * ch, int attack_type)$/;"	f
find_location	aw.c	/^ROOM_DATA * find_location (CHAR_DATA * ch, char *arg)$/;"	f
find_next_mob	oc.c	/^find_next_mob (int cur)$/;"	f
find_next_obj	oc.c	/^find_next_obj (int cur)$/;"	f
find_people_n	yell.c	/^find_people_n (CHAR_DATA * ch, int n)$/;"	f
find_player	script.c	/^find_player (char *pname)$/;"	f
find_prev_mob	oc.c	/^find_prev_mob (int cur)$/;"	f
find_prev_obj	oc.c	/^find_prev_obj (int cur)$/;"	f
find_repair	buysell.c	/^find_repair (CHAR_DATA * ch, int rnum)$/;"	f
find_room_tag	reloc.c	/^     ROOM_DATA * find_room_tag (char *tag)$/;"	f
find_str	hnd.c	/^find_str (char *str1, char *str2)$/;"	f
find_trigger	script3.c	/^find_trigger (char *trigname)$/;"	f
find_vehicle	move.c	/^find_vehicle (CHAR_DATA * ch, int sector_type)$/;"	f
findmob	script.c	/^findmob (void)$/;"	f
finger	syslag.c	/^finger (CHAR_DATA * ch, char *argy)$/;"	f
first	misc.c	/^first (char *s)$/;"	f
first_arg	int.c	/^char *first_arg (char *argy, char *arg_first, bool fCase)$/;"	f
firstdice	emlen.h	/^  signed char firstdice;	\/* v7 *\/$/;"	m	struct:item_weapon
fix_amount	hnd.c	/^fix_amount (CHAR_DATA * ch)$/;"	f
fix_char	upd.c	/^fix_char (CHAR_DATA * ch)$/;"	f
fix_exits	db2.c	/^fix_exits (void)$/;"	f
fix_object	db2.c	/^fix_object (OBJ_PROTOTYPE * pObjIndex)$/;"	f
fix_skillst	sedit.c	/^fix_skillst (void)$/;"	f
fix_string	oc.c	/^char *fix_string (const char *str)$/;"	f
flagGuild	guild.c	/^void flagGuild (CHAR_DATA * mob, CHAR_DATA * target, int guild, bool flag)$/;"	f
flag_data	emlen.h	/^struct flag_data$/;"	s
flaggy	upd.c	/^static bool flaggy;$/;"	v	file:
flagname	emlen.h	/^  char *flagname;$/;"	m	struct:scriptassoc
flagname	emlen.h	/^  int flagname;			\/* The actual FLAG *\/$/;"	m	struct:flag_data
flags	emlen.h	/^  int flags;			\/* v1 *\/$/;"	m	struct:item_container
flagtext	emlen.h	/^  char *flagtext;$/;"	m	struct:scriptassoc
flee_chance	emlen.h	/^  char flee_chance;		\/* Percent chance that fleeing will fail *\/$/;"	m	struct:power_data
flip	draw.c	/^bool flip = FALSE;		\/* Rotate 90 degrees option *\/$/;"	v
flurries	emlen.h	/^  bool flurries;		\/* Mob flurries *\/$/;"	m	struct:optional_data
flurry_mps	emlen.h	/^  short flurry_mps;		\/* Move point cost for flurry *\/$/;"	m	struct:power_data
fname	emlen.h	/^  char fname[20];$/;"	m	struct:shell_command
format_obj_to	armor.c	/^format_obj_to (SINGLE_OBJECT * obj, CHAR_DATA * ch, bool fShort)$/;"	f
format_string	script3.c	/^char *format_string (char *oldstring)$/;"	f
found	utils.c	/^bool found = FALSE;$/;"	v
fpArea	db2.c	/^FILE *fpArea;$/;"	v
fpReserve	comm.c	/^FILE *fpReserve;		                \/* Reserved file handle *\/$/;"	v
fread_and_compress_string	db2.c	/^char *fread_and_compress_string (FILE * fp, CHAR_DATA * ch)$/;"	f
fread_char	sv.c	/^fread_char (CHAR_DATA * ch, FILE * fp)$/;"	f
fread_clan	db2.c	/^fread_clan (FILE * fp, int vnum)$/;"	f
fread_clan_2	db2.c	/^fread_clan_2 (FILE * fp, int vnum)$/;"	f
fread_clan_storage	sv.c	/^fread_clan_storage (int clan_num)$/;"	f
fread_letter	db2.c	/^char fread_letter (FILE * fp)$/;"	f
fread_mobile	db2.c	/^fread_mobile (FILE * fp, int vnum)$/;"	f
fread_number	db2.c	/^int fread_number (FILE * fp)$/;"	f
fread_obj	sv.c	/^fread_obj (CHAR_DATA * ch, FILE * fp, int storage)$/;"	f
fread_object	db2.c	/^fread_object (FILE * fp, int vnum)$/;"	f
fread_room	db2.c	/^fread_room (FILE * fp, int vnum)$/;"	f
fread_string	db2.c	/^char *fread_string (FILE * fp, CHAR_DATA * ch)$/;"	f
fread_string2	db2.c	/^char *fread_string2 (FILE * fp, CHAR_DATA * ch)$/;"	f
fread_string_eol	db2.c	/^char *fread_string_eol (FILE * fp)$/;"	f
fread_to_eol	db2.c	/^void fread_to_eol (FILE * fp)$/;"	f
fread_tro	sv.c	/^fread_tro (CHAR_DATA * ch)$/;"	f
fread_word	db2.c	/^char *fread_word (FILE * fp)$/;"	f
free_affect	oc.c	/^void free_affect (AFFECT_DATA * pAf)$/;"	f
free_area	oc.c	/^void free_area (AREA_DATA * pArea)$/;"	f
free_arena	arena.c	/^free_arena (void)$/;"	f
free_bet_slot	arena.c	/^free_bet_slot (void)$/;"	f
free_ced	oc.c	/^void free_ced (CHAR_DATA * ch)$/;"	f
free_clan_storage	sv.c	/^free_clan_storage (CLAN_DATA * clan)$/;"	f
free_combat_field	combat.c	/^free_combat_field (COMBAT_FIELD * cf)$/;"	f
free_exit	oc.c	/^void free_exit (EXIT_DATA * pExit)$/;"	f
free_extra_descr	oc.c	/^void free_extra_descr (DESCRIPTION_DATA * pExtra)$/;"	f
free_field_list	combat.c	/^COMBAT_FIELD *free_field_list = NULL;$/;"	v
free_it	char.c	/^free_it (void *thing)$/;"	f
free_m	db2.c	/^void free_m (void *p)$/;"	f
free_mob_index	oc.c	/^void free_mob_index (MOB_PROTOTYPE * pMob)$/;"	f
free_read_notes	note.c	/^free_read_notes (CHAR_DATA * ch)$/;"	f
free_read_polls	poll.c	/^free_read_polls (CHAR_DATA * ch)$/;"	f
free_reset_data	oc.c	/^void free_reset_data (RESET_DATA * pReset)$/;"	f
free_shop	oc.c	/^void free_shop (SHOP_DATA * pShop)$/;"	f
free_storage	sv.c	/^free_storage (CHAR_DATA * ch)$/;"	f
free_string	db2.c	/^void free_string (char *pstr)$/;"	f
free_temp	oc.c	/^free_temp (CHAR_DATA * ch)$/;"	f
free_trophy_slot	toptr.c	/^free_trophy_slot (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
fullscreen_editor	edit.c	/^fullscreen_editor (CHAR_DATA * ch, char **pString)$/;"	f
fwrite_char	sv.c	/^fwrite_char (CHAR_DATA * ch, FILE * fp)$/;"	f
fwrite_char_tro	sv.c	/^fwrite_char_tro (CHAR_DATA * ch, FILE * fp)$/;"	f
fwrite_clan_storage	sv.c	/^fwrite_clan_storage (int clan_num)$/;"	f
fwrite_host	comm.c	/^fwrite_host (CHAR_DATA * ch)$/;"	f
fwrite_obj	sv.c	/^fwrite_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj, FILE * fp, int iNest)$/;"	f
fwrite_storage_objs	sv.c	/^fwrite_storage_objs (CHAR_DATA * ch, FILE * fp)$/;"	f
g_bidders	auction.c	/^int g_bidders = 0;$/;"	v
g_moblist	db2.c	/^unsigned short g_moblist[MAX_RANDOMPOP][10];$/;"	v
g_mobpop	db2.c	/^bool g_mobpop[10000];$/;"	v
g_obj_pop	db2.c	/^unsigned short g_obj_pop[MAX_RANDOMPOP];$/;"	v
g_percent	db2.c	/^unsigned char g_percent[MAX_RANDOMPOP];$/;"	v
gain_condition	upd.c	/^gain_condition (CHAR_DATA * ch, int iCond, int value)$/;"	f
gain_exp	upd.c	/^gain_exp (CHAR_DATA * ch, int gain)$/;"	f
game_loop_unix	comm.c	/^game_loop_unix (socket_t contrl, int control2)$/;"	f
gem_type	emlen.h	/^  signed short gem_type;	\/* v0 *\/$/;"	m	struct:item_gem
gen_m	emlen.h	/^  char *gen_m[20][2];$/;"	m	struct:dammsg_data
gen_m1	emlen.h	/^  char *gen_m1[20][2];$/;"	m	struct:dammsg_data
gen_m2	emlen.h	/^  char *gen_m2[20][2];$/;"	m	struct:dammsg_data
gen_next	emlen.h	/^  CHAR_DATA *gen_next;		\/* General next, for AGGRO list *\/$/;"	m	struct:char_data
general_ac	armor.c	/^general_ac (CHAR_DATA * ch)$/;"	f
general_spell	spl.c	/^general_spell (SPELL_DATA * spell, int level, CHAR_DATA * ch, void *vo)$/;"	f
generate_quest	quest.c	/^void generate_quest(CHAR_DATA *ch, CHAR_DATA *questman)$/;"	f
generic_percent	emlen.h	/^  short generic_percent[20][2];$/;"	m	struct:dammsg_data
generic_range	emlen.h	/^  short generic_range[20][2];$/;"	m	struct:dammsg_data
get_age	hnd.c	/^get_age (CHAR_DATA * ch)$/;"	f
get_ansi_spaces	aw.c	/^char *get_ansi_spaces (char *txt)$/;"	f
get_area_data	oc.c	/^AREA_DATA * get_area_data (int vnum)$/;"	f
get_area_flags_number	oc.c	/^int get_area_flags_number (char *argy)$/;"	f
get_bet_slot	arena.c	/^get_bet_slot (char *charname)$/;"	f
get_better_pos	grnd.c	/^get_better_pos (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
get_char_room	hnd.c	/^get_char_room (CHAR_DATA * ch, char *argy)$/;"	f
get_char_world	hnd.c	/^get_char_world (CHAR_DATA * ch, char *argy)$/;"	f
get_char_world_2	hnd.c	/^get_char_world_2 (CHAR_DATA * ch, char *argy)$/;"	f
get_clan_index	db2.c	/^CLAN_DATA * get_clan_index (int vnum)$/;"	f
get_clan_index_2	db2.c	/^CLAN_DATA * get_clan_index_2 (int vnum)$/;"	f
get_condition	armor.c	/^get_condition (SINGLE_OBJECT * obj)$/;"	f
get_cost	buysell.c	/^get_cost (CHAR_DATA * keeper, SINGLE_OBJECT * obj, bool fBuy)$/;"	f
get_curr_con	hnd.c	/^get_curr_con (CHAR_DATA * ch)$/;"	f
get_curr_dex	hnd.c	/^get_curr_dex (CHAR_DATA * ch)$/;"	f
get_curr_int	hnd.c	/^get_curr_int (CHAR_DATA * ch)$/;"	f
get_curr_str	hnd.c	/^get_curr_str (CHAR_DATA * ch)$/;"	f
get_curr_wis	hnd.c	/^get_curr_wis (CHAR_DATA * ch)$/;"	f
get_direction	move.c	/^get_direction (char *arg)$/;"	f
get_direction_number	oc.c	/^int get_direction_number (char *arg)$/;"	f
get_eq_char	hnd.c	/^get_eq_char (CHAR_DATA * ch, int iWear)$/;"	f
get_exit_flag_number	oc.c	/^int get_exit_flag_number (char *arg)$/;"	f
get_extra_descr	hnd.c	/^get_extra_descr (const char *name, DESCRIPTION_DATA * ed)$/;"	f
get_from_corpse_while_in_combat	emlen.h	/^  bool get_from_corpse_while_in_combat;	\/* Loot corpses while fighting? *\/$/;"	m	struct:power_data
get_item_held	hnd.c	/^get_item_held (CHAR_DATA * ch, int itype)$/;"	f
get_main_guild	info.c	/^char* get_main_guild (CHAR_DATA * ch)$/;"	f
get_mob_index	db2.c	/^MOB_PROTOTYPE * get_mob_index (int vnum)$/;"	f
get_mob_sex_number	oc.c	/^int get_mob_sex_number (char *arg)$/;"	f
get_mob_spec	oc.c	/^SPEC_FUNCTION * get_mob_spec (char *arg)$/;"	f
get_name	db2.c	/^char *get_name (char *str)$/;"	f
get_obj	give.c	/^get_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj, SINGLE_OBJECT * container)$/;"	f
get_obj_carry	hnd.c	/^get_obj_carry (CHAR_DATA * ch, char *argy)$/;"	f
get_obj_held	hnd.c	/^get_obj_held (CHAR_DATA * ch, char *argy)$/;"	f
get_obj_here	hnd.c	/^get_obj_here (CHAR_DATA * ch, char *argy, int lookfirst)$/;"	f
get_obj_index	db2.c	/^OBJ_PROTOTYPE * get_obj_index (int vnum)$/;"	f
get_obj_inv	hnd.c	/^get_obj_inv (CHAR_DATA * ch, char *argy)$/;"	f
get_obj_list	hnd.c	/^get_obj_list (CHAR_DATA * ch, char *argy, SINGLE_OBJECT * list)$/;"	f
get_obj_number	hnd.c	/^get_obj_number (SINGLE_OBJECT * obj)$/;"	f
get_obj_type	hnd.c	/^get_obj_type (OBJ_PROTOTYPE * pObjIndex)$/;"	f
get_obj_wear	hnd.c	/^get_obj_wear (CHAR_DATA * ch, char *argy)$/;"	f
get_obj_weight	hnd.c	/^get_obj_weight (SINGLE_OBJECT * obj)$/;"	f
get_obj_world	hnd.c	/^get_obj_world (CHAR_DATA * ch, char *argy)$/;"	f
get_perm_stat	score.c	/^get_perm_stat (CHAR_DATA * ch, int st)$/;"	f
get_player_world	hnd.c	/^get_player_world (CHAR_DATA * ch, char *argy, bool need_see)$/;"	f
get_race_look	hnd.c	/^get_race_look (char *argy)$/;"	f
get_room_index	db2.c	/^ROOM_DATA * get_room_index (int vnum)$/;"	f
get_sector_name	oc.c	/^char *get_sector_name (int sector_type)$/;"	f
get_sector_number	oc.c	/^int get_sector_number (char *argy)$/;"	f
get_vnum_area	oc.c	/^AREA_DATA * get_vnum_area (int vnum)$/;"	f
get_warmth	warmth.c	/^get_warmth (CHAR_DATA * ch)$/;"	f
gettimeofday	comm.c	/^gettimeofday (struct timeval *t, struct timezone *dummy)$/;"	f
ggotoxy_dir	draw.c	/^ggotoxy_dir (CHAR_DATA * ch, int x, int y)$/;"	f
ghit_pos	fgt.c	/^int ghit_pos = 0;$/;"	v
give_back_money	arena.c	/^give_back_money (void)$/;"	f
give_while_fighting	emlen.h	/^  bool give_while_fighting;	\/* Give objects while fighting? *\/$/;"	m	struct:power_data
glog	emlen.h	/^  char *glog[20];$/;"	m	struct:pc_data
glog_count	emlen.h	/^  short glog_count;$/;"	m	struct:pc_data
go_ahead_str	comm.c	/^char go_ahead_str[] = {$/;"	v
go_display	draw.c	/^go_display (CHAR_DATA * ch, ROOM_DATA * rid, int x, int y, short came_from, int maxy, int maxx, bool ds)$/;"	f
go_mdisplay	draw.c	/^go_mdisplay (ROOM_DATA * rid, int x, int y, signed char z, short came_from)$/;"	f
go_to_second	emlen.h	/^  bool go_to_second;            \/* Is there vert line to second prereq? *\/$/;"	m	struct:spell_data
god_names	emlen.h	/^  char *god_names[5];		\/* Holds the name of mudgods. *\/$/;"	m	struct:power_data
gods	emlen.h	/^  char *gods;			\/* Gods who run the place *\/$/;"	m	struct:power_data
gold	emlen.h	/^  int gold;			\/* Amount of gold *\/$/;"	m	struct:char_data
gold	emlen.h	/^  int gold;			\/* Gold in room *\/$/;"	m	struct:room_extended
good	conflict.c	/^char *good;$/;"	v
good_hit	combat.c	/^good_hit (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
good_kill_good	emlen.h	/^  bool good_kill_good;$/;"	m	struct:power_data
got	db2.c	/^bool got = TRUE;$/;"	v
gotoxy	draw.c	/^gotoxy (CHAR_DATA * ch, int x, int y)$/;"	f
gotoxy_dir	draw.c	/^gotoxy_dir (CHAR_DATA * ch, int x, int y)$/;"	f
gr	comm.c	/^bool gr = TRUE;$/;"	v
grab_hostnames	power.c	/^grab_hostnames (CHAR_DATA * ch, char *argy)$/;"	f
grab_num	script.c	/^grab_num (char *arg)$/;"	f
grab_num_2	prse.c	/^grab_num_2 (char *txt)$/;"	f
grep	int.c	/^        char grep[500]; char *check_grep (CHAR_DATA * ch, char *argy)$/;"	v
ground_hit	grnd.c	/^ground_hit (CHAR_DATA * ch, CHAR_DATA * victim, int dt)$/;"	f
ground_pos	emlen.h	/^  short ground_pos;		\/* Groundfight position *\/$/;"	m	struct:ced
groundfight_stand	emlen.h	/^  short groundfight_stand;	\/* Chance of standing in a groundfight *\/$/;"	m	struct:power_data
group_gain	death.c	/^group_gain (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
group_notify	channels.c	/^group_notify (char *argy, CHAR_DATA * ch)	\/*By Owen Emlen *\/$/;"	f
gsn	emlen.h	/^  int gsn;			\/* General slot number.  internal use *\/$/;"	m	struct:spell_data
gsn_backstab	db2.c	/^short gsn_backstab;$/;"	v
gsn_bash	db2.c	/^short gsn_bash;$/;"	v
gsn_berserk	db2.c	/^short gsn_berserk;$/;"	v
gsn_bite	db2.c	/^short gsn_bite;$/;"	v
gsn_blindness	db2.c	/^short gsn_blindness;$/;"	v
gsn_bodyslam	db2.c	/^short gsn_bodyslam;$/;"	v
gsn_butcher	db2.c	/^short gsn_butcher;$/;"	v
gsn_calm	db2.c	/^short gsn_calm;$/;"	v
gsn_charge	db2.c	/^short gsn_charge;$/;"	v
gsn_charm_person	db2.c	/^short gsn_charm_person;$/;"	v
gsn_circle	db2.c	/^short gsn_circle;$/;"	v
gsn_concussion	db2.c	/^short gsn_concussion;$/;"	v
gsn_curse	db2.c	/^short gsn_curse;$/;"	v
gsn_disarm	db2.c	/^short gsn_disarm;$/;"	v
gsn_dodge	db2.c	/^short gsn_dodge;$/;"	v
gsn_dual_backstab	db2.c	/^short gsn_dual_backstab;$/;"	v
gsn_dual_daggers	db2.c	/^short gsn_dual_daggers;$/;"	v
gsn_dual_wield	db2.c	/^short gsn_dual_wield;$/;"	v
gsn_enhanced_damage	db2.c	/^short gsn_enhanced_damage;$/;"	v
gsn_flash	db2.c	/^short gsn_flash;$/;"	v
gsn_grunt	db2.c	/^short gsn_grunt;$/;"	v
gsn_hands	db2.c	/^short gsn_hands;$/;"	v
gsn_headbutt	db2.c	/^short gsn_headbutt;$/;"	v
gsn_heavy_slash	db2.c	/^short gsn_heavy_slash;$/;"	v
gsn_hide	db2.c	/^short gsn_hide;$/;"	v
gsn_invest	db2.c	/^short gsn_invest;$/;"	v
gsn_invis	db2.c	/^short gsn_invis;$/;"	v
gsn_kick	db2.c	/^short gsn_kick;$/;"	v
gsn_lance	db2.c	/^short gsn_lance;$/;"	v
gsn_light_slash	db2.c	/^short gsn_light_slash;$/;"	v
gsn_mass_invis	db2.c	/^short gsn_mass_invis;$/;"	v
gsn_parry	db2.c	/^short gsn_parry;$/;"	v
gsn_peek	db2.c	/^short gsn_peek;$/;"	v
gsn_penetration	db2.c	/^short gsn_penetration;$/;"	v
gsn_pick_lock	db2.c	/^short gsn_pick_lock;$/;"	v
gsn_pierce	db2.c	/^short gsn_pierce;$/;"	v
gsn_plague	db2.c	/^short gsn_plague;$/;"	v
gsn_poison	db2.c	/^short gsn_poison;$/;"	v
gsn_raise_undead	db2.c	/^short gsn_raise_undead;$/;"	v
gsn_rescue	db2.c	/^short gsn_rescue;$/;"	v
gsn_riding	db2.c	/^short gsn_riding;$/;"	v
gsn_rush	db2.c	/^short gsn_rush;$/;"	v
gsn_search	db2.c	/^short gsn_search;$/;"	v
gsn_second_attack	db2.c	/^short gsn_second_attack;$/;"	v
gsn_second_kick	db2.c	/^short gsn_second_kick;$/;"	v
gsn_shield_block	db2.c	/^short gsn_shield_block;$/;"	v
gsn_slashing	db2.c	/^short gsn_slashing;$/;"	v
gsn_sleep	db2.c	/^short gsn_sleep;$/;"	v
gsn_sneak	db2.c	/^short gsn_sneak;$/;"	v
gsn_stab	db2.c	/^short gsn_stab;$/;"	v
gsn_steal	db2.c	/^short gsn_steal;$/;"	v
gsn_swim	db2.c	/^short gsn_swim;$/;"	v
gsn_tackle	db2.c	/^short gsn_tackle;$/;"	v
gsn_third_attack	db2.c	/^short gsn_third_attack;$/;"	v
gsn_thrust	db2.c	/^short gsn_thrust;$/;"	v
gsn_track	db2.c	/^short gsn_track;$/;"	v
gsn_vbite	db2.c	/^short gsn_vbite;$/;"	v
gsn_whip	db2.c	/^short gsn_whip;$/;"	v
gtell_counter	emlen.h	/^  short gtell_counter;        \/* Group tell counter *\/  $/;"	m	struct:mob_proto_data
guard	emlen.h	/^  int guard;			\/* Guards this direction, this mob vnum, or$/;"	m	struct:mob_proto_data
guildflag1	emlen.h	/^  char *guildflag1;$/;"	m	struct:spell_data
guildflag2	emlen.h	/^  char *guildflag2;$/;"	m	struct:spell_data
guildflag3	emlen.h	/^  char *guildflag3;$/;"	m	struct:spell_data
guildflag4	emlen.h	/^  char *guildflag4;$/;"	m	struct:spell_data
guilds	emlen.h	/^  int guilds;			\/* Guild flags *\/$/;"	m	struct:pc_data
guildstats	emlen.h	/^  int guildstats[4];            \/* Guild stat additions *\/$/;"	m	struct:pc_data
hand_empty	hnd.c	/^hand_empty (CHAR_DATA * ch)$/;"	f
handle_connecting	comm.c	/^handle_connecting (DESCRIPTOR_DATA * d, char *argy)$/;"	f
handle_gs	dam.c	/^handle_gs (CHAR_DATA * ch, char *argy)$/;"	f
handle_gs_d	dam.c	/^handle_gs_d (CHAR_DATA * ch, int x, int y)$/;"	f
handle_gs_da	dam.c	/^handle_gs_da (CHAR_DATA * ch, int x, int y)$/;"	f
handle_leave	script.h	/^  char handle_leave[10];	\/* Code label to jump to if char leaves (for ROOM AND MOB only) *\/$/;"	m	struct:single_trigger
handle_points	autoeq.c	/^		  void handle_points (MOB_PROTOTYPE * mobp, CHAR_DATA * mob)$/;"	f
hardcode_give_scripts	script2.c	/^hardcode_give_scripts (CHAR_DATA * ch, CHAR_DATA * mob, char *argy)$/;"	f
hardcode_interpret_scripts	script2.c	/^hardcode_interpret_scripts (CHAR_DATA * ch, CHAR_DATA * mob, char *argy)$/;"	f
hardcode_move_scripts	script2.c	/^hardcode_move_scripts (CHAR_DATA * ch, CHAR_DATA * mob)$/;"	f
hardcode_room_enter	script2.c	/^hardcode_room_enter (CHAR_DATA * ch, ROOM_DATA * room)$/;"	f
hardcode_saytell_scripts	script2.c	/^hardcode_saytell_scripts (CHAR_DATA * ch, CHAR_DATA * mob, char *argy)$/;"	f
has_boat_space	boat.c	/^has_boat_space (CHAR_DATA * ch, SINGLE_OBJECT * boat)$/;"	f
has_key	move.c	/^has_key (CHAR_DATA * ch, int key)$/;"	f
has_popped_this_reboot	emlen.h	/^  bool has_popped_this_reboot;	\/* Has repop'd this reboot *\/$/;"	m	struct:area_data
has_read_note	note.c	/^has_read_note (CHAR_DATA * ch, NOTE_DATA * note)$/;"	f
has_read_poll	poll.c	/^has_read_poll (CHAR_DATA * ch, POLL_DATA * poll)$/;"	f
has_scriptflag	skill.c	/^has_scriptflag (CHAR_DATA * ch,char * flag)$/;"	f
has_yelled	emlen.h	/^  bool has_yelled;		\/* TRUE if victim has yelled already *\/$/;"	m	struct:ced
head	emlen.h	/^  SCRIPT_DAT *head;		\/*Points to the begginning of the script code *\/$/;"	m	struct:triggy
head_butt	grnd.c	/^head_butt (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
head_m	emlen.h	/^  char *head_m[20][2];$/;"	m	struct:dammsg_data
head_m1	emlen.h	/^  char *head_m1[20][2];$/;"	m	struct:dammsg_data
head_m2	emlen.h	/^  char *head_m2[20][2];$/;"	m	struct:dammsg_data
head_percent	emlen.h	/^  short head_percent[20][2];$/;"	m	struct:dammsg_data
head_range	emlen.h	/^  short head_range[20][2];$/;"	m	struct:dammsg_data
headp	armor.c	/^int headp;$/;"	v
headw	int.c	/^  WRD * headw[256]; int max; void tally_stuff (char *s)$/;"	v
hedit	hedit.c	/^hedit (CHAR_DATA * ch, char *argy)$/;"	f
height	emlen.h	/^  short height;			\/* Height *\/$/;"	m	struct:char_data
height	emlen.h	/^  short height;			\/* The height of this mob, or 0 for$/;"	m	struct:mob_proto_data
height_max	emlen.h	/^  short height_max;		\/* Maximum height *\/$/;"	m	struct:race_data
height_min	emlen.h	/^  short height_min;		\/* Minimum height *\/$/;"	m	struct:race_data
help	emlen.h	/^  char *help;			\/* Help text on the command *\/$/;"	m	struct:cmd_type
help_data	emlen.h	/^struct help_data$/;"	s
help_first	db2.c	/^HELP_DATA *help_first;$/;"	v
help_greeting	db2.c	/^char *help_greeting;$/;"	v
help_greeting_a	db2.c	/^char *help_greeting_a;$/;"	v
help_index_free	hedit.c	/^HELP_DATA *help_index_free;$/;"	v
help_last	db2.c	/^HELP_DATA *help_last;$/;"	v
high_range	emlen.h	/^  short high_range[20];		\/* Range for learned *\/$/;"	m	struct:power_data
hit	emlen.h	/^  short hit;			\/* Hit points now *\/$/;"	m	struct:char_data
hit	emlen.h	/^  short hit;$/;"	m	struct:con_apply_type
hit_gain	upd.c	/^hit_gain (CHAR_DATA * ch)$/;"	f
hit_suck_disarm	fgt.c	/^hit_suck_disarm (CHAR_DATA * ch, CHAR_DATA * victim, int hit, int dam)$/;"	f
hit_type	emlen.h	/^  int hit_type;$/;"	m	struct:attack_type
hit_vorpal	fgt.c	/^hit_vorpal (CHAR_DATA * ch, CHAR_DATA * victim, int hit, int dam)$/;"	f
hitgain	emlen.h	/^  short hitgain[10][5];		\/* Hit gains in a given level range *\/$/;"	m	struct:power_data
hitop	fgt.c	/^bool hitop = FALSE;$/;"	v
hitroll	emlen.h	/^  short hitroll;		\/* Hitroll *\/$/;"	m	struct:char_data
hitroll	emlen.h	/^  unsigned char hitroll;	\/* Extra hitroll. *\/$/;"	m	struct:mob_proto_data
host	emlen.h	/^  char host[30];		\/* Hostname this player comes from *\/$/;"	m	struct:descriptor_data
hostname	emlen.h	/^  char *hostname;		\/* Hostname.  Unused due to slow dns lookups *\/$/;"	m	struct:descriptor_data
hosttwo	emlen.h	/^  char hosttwo[30];		\/* Host prefix for extra checking *\/$/;"	m	struct:descriptor_data
hour	emlen.h	/^  short hour;$/;"	m	struct:time_info_data
hours	emlen.h	/^  int hours;      \/* for fading *\/$/;"	m	struct:track_data
hours	emlen.h	/^  signed char hours;		\/* v0 *\/$/;"	m	struct:item_food
hours_expired	emlen.h	/^  bool hours_expired;		\/* Hours expired? *\/$/;"	m	struct:pc_data
hours_purchased	emlen.h	/^  int hours_purchased;		\/* Total Hours purchased *\/$/;"	m	struct:pc_data
hours_up	upd.c	/^static int hours_up = 0;$/;"	v	file:
how_good	skill.c	/^how_good (int percent)$/;"	f
how_it_appears	emlen.h	/^  char how_it_appears[50];	\/* How the flag display appears *\/$/;"	m	struct:flag_data
how_many	emlen.h	/^  short how_many;		\/* How many can exist at once *\/$/;"	m	struct:obj_proto_data
how_many	int.c	/^  int how_many;$/;"	m	struct:wrd	file:
hp_bonus_resting	emlen.h	/^  short hp_bonus_resting;	\/* Hp regen bonus for resting *\/$/;"	m	struct:power_data
hp_bonus_sleeping	emlen.h	/^  short hp_bonus_sleeping;	\/* Hp regen bonus for sleeping *\/$/;"	m	struct:power_data
hp_mort	emlen.h	/^  short hp_mort;                \/*Stuff for resetting mana on level?*\/$/;"	m	struct:pc_data
hpmult	emlen.h	/^  short hpmult;			\/* Hit point and experience multiplier. *\/$/;"	m	struct:mob_proto_data
hugebuf_o	db2.c	/^char hugebuf_o[30000];$/;"	v
hunt_victim	ar.c	/^hunt_victim (CHAR_DATA * ch)$/;"	f
hunting	emlen.h	/^  char *hunting;		\/* Hunting for\/tracking *\/$/;"	m	struct:fight_data
ignore	channels.c	/^ignore (CHAR_DATA * victim, CHAR_DATA * ch)	\/*Is the character ignored? *\/$/;"	f
ignore	emlen.h	/^  char *ignore[10];		\/* Ignored character list *\/$/;"	m	struct:pc_data
iir	move.c	/^ROOM_DATA *iir = NULL;$/;"	v
img	emlen.h	/^  char img[2];			\/* Image code, 2 ascii chars *\/$/;"	m	struct:room_data
implants_1	emlen.h	/^  char implants_1;		\/* Implants for aliens *\/$/;"	m	struct:pc_data
implants_2	emlen.h	/^  char implants_2;		\/* Implants for aliens *\/$/;"	m	struct:pc_data
in_battle	emlen.h	/^  bool in_battle;		\/* Is this guy in the battleground? *\/$/;"	m	struct:fight_data
in_boat	emlen.h	/^  CHAR_DATA *in_boat[8];$/;"	m	struct:obj_boat
in_boat	emlen.h	/^  SINGLE_OBJECT *in_boat;	\/* In an OLD format boat? *\/$/;"	m	struct:ced
in_obj	emlen.h	/^  SINGLE_OBJECT *in_obj;	\/* Inside of object reference *\/$/;"	m	struct:obj_data
in_progress	emlen.h	/^  bool in_progress[1000];	\/* Temp flags for OLD quest method *\/$/;"	m	struct:pc_data
in_room	emlen.h	/^  ROOM_DATA *in_room;		\/* Current room character is in *\/$/;"	m	struct:char_data
in_room	emlen.h	/^  ROOM_DATA *in_room;		\/* On the ground in this room? *\/$/;"	m	struct:obj_data
in_set	comm.c	/^static fd_set in_set;$/;"	v	file:
inbuf	emlen.h	/^  char inbuf[2002];		\/* Input buffer *\/$/;"	m	struct:descriptor_data
incomm	emlen.h	/^  char incomm[2004];		\/* Input command buffer *\/$/;"	m	struct:descriptor_data
info	db2.c	/^char *info = NULL;$/;"	v
info_list	db2.c	/^SCRIPT_INFO *info_list;$/;"	v
info_mem	dam.c	/^info_mem (int i)$/;"	f
init_mm	db2.c	/^  static int rgiState[2 + 55]; void init_mm ()$/;"	f
init_socket	comm.c	/^init_socket (int port)$/;"	f
initflags	emlen.h	/^  int initflags;$/;"	m	struct:material_data
initial	comm.c	/^initial (const char *str)$/;"	f
initial_hp	emlen.h	/^  short initial_hp[2];		\/* Initial hit points for newbies *\/$/;"	m	struct:power_data
initial_mv	emlen.h	/^  short initial_mv[2];		\/* Initial move points for newbies *\/$/;"	m	struct:power_data
inlast	emlen.h	/^  char inlast[2004];		\/* Last Input buffer contents *\/$/;"	m	struct:descriptor_data
insert	emlen.h	/^  bool insert;			\/* In insert mode in fullscreen *\/$/;"	m	struct:descriptor_data
int_app	prse.c	/^struct int_apply_type int_app[36];$/;"	v	typeref:struct:int_apply_type
int_apply_type	emlen.h	/^struct int_apply_type$/;"	s
int_name	comm.c	/^int_name (int inte)$/;"	f
internal	emlen.h	/^  char *internal;               \/* pointer for internal new functions *\/$/;"	m	struct:char_data
interpret	int.c	/^void interpret (CHAR_DATA * ch, char *argy)$/;"	f
interpret_line	prse.c	/^interpret_line (char *inlne, CHAR_DATA * ch)$/;"	f
interrupted	script.h	/^  char interrupted;		\/* Will the trigger reset if it is interrupted? *\/$/;"	m	struct:single_trigger
inventory	look.c	/^bool inventory = FALSE;$/;"	v
invoke_who_window	dam.c	/^invoke_who_window (CHAR_DATA * ch)$/;"	f
ioctl	shell.c	27;"	d	file:
is_affected	hnd.c	/^is_affected (CHAR_DATA * ch, int sn)$/;"	f
is_affectedt	hnd.c	/^is_affectedt (CHAR_DATA * ch, int bits)$/;"	f
is_approx_name	hnd.c	/^is_approx_name (const char *str, char *namelist)$/;"	f
is_are	hnd.c	/^is_are (char *text)$/;"	f
is_boat_empty	boat.c	/^is_boat_empty (SINGLE_OBJECT * boat)$/;"	f
is_digit	sedit.c	/^is_digit (char test)$/;"	f
is_equipwipe	comm.c	/^bool is_equipwipe = FALSE;$/;"	v
is_fighting_near	combat.c	/^is_fighting_near (CHAR_DATA * ch, CHAR_DATA * target)$/;"	f
is_in_same_boat	boat.c	/^is_in_same_boat (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
is_member	guild.c	/^is_member (CHAR_DATA * ch, int guildflag)$/;"	f
is_name	hnd.c	/^is_name (const char *str, char *namelist)$/;"	f
is_note_to	note.c	/^is_note_to (CHAR_DATA * ch, NOTE_DATA * pnote)$/;"	f
is_number	int.c	/^bool is_number (char *arg)$/;"	f
is_poll_to	poll.c	/^is_poll_to (CHAR_DATA * ch, POLL_DATA * poll)$/;"	f
is_safe	fgt.c	/^is_safe (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
is_undead	emlen.h	/^  bool is_undead;$/;"	m	struct:char_data
is_using_sword	fgt.c	/^is_using_sword (CHAR_DATA * ch)$/;"	f
item_armor	emlen.h	/^struct item_armor$/;"	s
item_blood	emlen.h	/^struct item_blood$/;"	s
item_book	emlen.h	/^struct item_book$/;"	s
item_climbable	emlen.h	/^struct item_climbable$/;"	s
item_container	emlen.h	/^struct item_container$/;"	s
item_drink_container	emlen.h	/^struct item_drink_container$/;"	s
item_food	emlen.h	/^struct item_food$/;"	s
item_fountain	emlen.h	/^struct item_fountain$/;"	s
item_furniture	emlen.h	/^struct item_furniture$/;"	s
item_gem	emlen.h	/^struct item_gem$/;"	s
item_light	emlen.h	/^struct item_light$/;"	s
item_name_type	hnd.c	/^item_name_type (char *name)$/;"	f
item_potion	emlen.h	/^struct item_potion$/;"	s
item_spray	emlen.h	/^struct item_spray$/;"	s
item_tool	emlen.h	/^struct item_tool$/;"	s
item_type	emlen.h	/^  int item_type;		\/* The item type *\/$/;"	m	struct:obj_proto_data
item_type_name	hnd.c	/^item_type_name (int item_type)$/;"	f
item_vehicle	emlen.h	/^struct item_vehicle$/;"	s
item_wand	emlen.h	/^struct item_wand$/;"	s
item_weapon	emlen.h	/^struct item_weapon$/;"	s
items_until_decrease	emlen.h	/^  short items_until_decrease;	\/* Decrease percent after this many items *\/$/;"	m	struct:shop_data
itoa	script.c	/^itoa (int n)$/;"	f
iwillecho	edit.c	/^char iwillecho[] = { 255, 251, 1, '\\0' };$/;"	v
iwontecho	edit.c	/^char iwontecho[] = { 255, 252, 1, '\\0' };$/;"	v
jail	emlen.h	/^  int jail;			\/* Jail vnum (unused) *\/$/;"	m	struct:area_data
jail_served	emlen.h	/^  int jail_served;		\/* Jail hours served. *\/$/;"	m	struct:pc_data
java	emlen.h	/^  bool java;			\/* Using the java interface? *\/$/;"	m	struct:descriptor_data
java	emlen.h	/^  char java[2];			\/* 2 java code bytes for picture *\/$/;"	m	struct:mob_proto_data
java	emlen.h	/^  char java[2];			\/* 2 java code bytes for picture *\/$/;"	m	struct:obj_proto_data
java_add_mob_window	dam.c	/^java_add_mob_window (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
java_add_obj_inv_window	dam.c	/^java_add_obj_inv_window (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
java_add_obj_window	dam.c	/^java_add_obj_window (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
java_add_to_field	dam.c	/^java_add_to_field (COMBAT_FIELD * cfld, CHAR_DATA * victim, int x, int y)$/;"	f
java_cc	dam.c	/^java_cc (CHAR_DATA * ch, char col)$/;"	f
java_clear_inv_window	dam.c	/^java_clear_inv_window (CHAR_DATA * ch)$/;"	f
java_clear_mob_window	dam.c	/^java_clear_mob_window (CHAR_DATA * ch)$/;"	f
java_cnc	dam.c	/^java_cnc (CHAR_DATA * ch, char *nc)$/;"	f
java_color	channels.c	/^java_color (char *c)$/;"	f
java_exits	dam.c	/^java_exits (CHAR_DATA * ch, char *s)$/;"	f
java_hit_field	dam.c	/^java_hit_field (COMBAT_FIELD * cfld, CHAR_DATA * ch, int oldx, int oldy,$/;"	f
java_hits	dam.c	/^java_hits (CHAR_DATA * ch)$/;"	f
java_make_splat	dam.c	/^java_make_splat (COMBAT_FIELD * cfld, int x, int y)$/;"	f
java_mana	dam.c	/^java_mana (CHAR_DATA * ch)$/;"	f
java_medit	oc.c	/^java_medit (CHAR_DATA * ch, MOB_PROTOTYPE * mob)$/;"	f
java_mob_window	dam.c	/^java_mob_window (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
java_moves	dam.c	/^java_moves (CHAR_DATA * ch)$/;"	f
java_nc	dam.c	/^java_nc (CHAR_DATA * ch, char *nc)$/;"	f
java_nomore_inv_window	dam.c	/^java_nomore_inv_window (CHAR_DATA * ch)$/;"	f
java_obj_window	dam.c	/^java_obj_window (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
java_oedit	oc.c	/^java_oedit (CHAR_DATA * ch, OBJ_PROTOTYPE * obj)$/;"	f
java_package	dam.c	/^java_package (CHAR_DATA * ch)$/;"	f
java_position	dam.c	/^java_position (CHAR_DATA * ch)$/;"	f
java_remove_from_combat_field	dam.c	/^java_remove_from_combat_field (COMBAT_FIELD * cfld, CHAR_DATA * ch, int x,$/;"	f
java_remove_mob_stuff	dam.c	/^java_remove_mob_stuff (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
java_remove_obj_inv	dam.c	/^java_remove_obj_inv (CHAR_DATA * ch, SINGLE_OBJECT * victim)$/;"	f
java_remove_obj_stuff	dam.c	/^java_remove_obj_stuff (CHAR_DATA * ch, SINGLE_OBJECT * victim)$/;"	f
java_send_field	dam.c	/^java_send_field (COMBAT_FIELD * cfld, CHAR_DATA * ch)$/;"	f
java_send_profile	dam.c	/^java_send_profile (CHAR_DATA * ch)$/;"	f
java_show_mob_window	dam.c	/^java_show_mob_window (CHAR_DATA * ch)$/;"	f
java_show_mob_window_pic	dam.c	/^java_show_mob_window_pic (CHAR_DATA * ch)$/;"	f
java_timeup	dam.c	/^java_timeup (CHAR_DATA * ch)$/;"	f
java_update_field	dam.c	/^java_update_field (COMBAT_FIELD * cfld, CHAR_DATA * ch, int oldx, int oldy,$/;"	f
javaspecfun	oc.c	/^javaspecfun (MOB_PROTOTYPE * mob)$/;"	f
juji_gatame	grnd.c	/^juji_gatame (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
jumble	crsh.c	/^jumble (char *name)$/;"	f
jumble_name	crsh.c	/^jumble_name (char *st, bool unjumb)$/;"	f
just_investigated	emlen.h	/^  bool just_investigated;	\/* Just investigated a corpse recently? *\/$/;"	m	struct:pc_data
keeper	emlen.h	/^  int keeper;			\/* Vnum of shopkeeper *\/$/;"	m	struct:shop_data
key	emlen.h	/^  short key;			\/* Key required to open the door *\/$/;"	m	struct:door_data
key_vnum	emlen.h	/^  int key_vnum;			\/* v2 *\/$/;"	m	struct:item_container
keyword	emlen.h	/^  char *keyword;		\/* Keyword list to get this helpfile *\/$/;"	m	struct:help_data
keyword	emlen.h	/^  char *keyword;		\/* Keyword list to see this desc *\/$/;"	m	struct:extra_descr_data
keyword	emlen.h	/^  char *keyword;		\/* keyword for exit description *\/$/;"	m	struct:door_data
keywords	script.h	/^  char *keywords;		\/* General keywords *\/$/;"	m	struct:single_trigger
kick_dam	emlen.h	/^  char *kick_dam;$/;"	m	struct:damages_struct
kick_dam2	emlen.h	/^  char *kick_dam2;$/;"	m	struct:damages_struct
kickable	fgt.c	/^kickable (CHAR_DATA * ch)$/;"	f
kicks	emlen.h	/^  bool kicks;			\/* Mob randomly kicks *\/$/;"	m	struct:optional_data
killed	emlen.h	/^  short killed;			\/* How many times has this mob been killed since reboot? *\/$/;"	m	struct:mob_proto_data
killed_mobs	emlen.h	/^  unsigned short killed_mobs[MAX_MOB_TRO];	\/* Mob trophies *\/$/;"	m	struct:pc_data
killpoints	emlen.h	/^  int killpoints;		\/* Kill points *\/$/;"	m	struct:pc_data
kk	draw.c	/^bool kk = FALSE;		\/* Internal use *\/$/;"	v
kk	emlen.h	/^  bool kk;			\/* Show descripted rooms on maps *\/$/;"	m	struct:pc_data
knee_stomach	grnd.c	/^knee_stomach (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
label	emlen.h	/^  int label;			\/*Line label, for "if's" "goto's" etc... *\/$/;"	m	struct:script_dat
label	script.h	/^  char label[10];$/;"	m	struct:code_segment
language_table	def.c	/^char *const language_table[12] = {$/;"	v
last_col	draw.c	/^char last_col;$/;"	v
last_gtells	emlen.h	/^  char *last_gtells[15];      \/* Circular list of last group tells *\/$/;"	m	struct:mob_proto_data
last_tells	emlen.h	/^  char *last_tells[15];		\/* Circular list of last tells *\/$/;"	m	struct:pc_data
last_time	upd.c	/^long last_time[MT];$/;"	v
leader	emlen.h	/^  CHAR_DATA *leader;		\/* Leader, for following *\/$/;"	m	struct:fight_data
leader	emlen.h	/^  char leader[20];		\/* Name of Clan's Leader\/Owner *\/$/;"	m	struct:clan_data
learn	emlen.h	/^  short learn;			\/* Learn points left. *\/$/;"	m	struct:pc_data
learn	emlen.h	/^  short learn;$/;"	m	struct:int_apply_type
learned	emlen.h	/^  char *learned[20];		\/* Description of how well you know spells\/skills *\/$/;"	m	struct:power_data
learned	emlen.h	/^  signed char learned[SKILL_COUNT];	\/* Learned level for skills and spells *\/$/;"	m	struct:pc_data
leaves_room	script.h	/^  char leaves_room;		\/* Will the script stop if the player leaves the room? *\/$/;"	m	struct:single_trigger
leg_m	emlen.h	/^  char *leg_m[20][2];$/;"	m	struct:dammsg_data
leg_m1	emlen.h	/^  char *leg_m1[20][2];$/;"	m	struct:dammsg_data
leg_m2	emlen.h	/^  char *leg_m2[20][2];$/;"	m	struct:dammsg_data
leg_percent	emlen.h	/^  short leg_percent[20][2];$/;"	m	struct:dammsg_data
leg_range	emlen.h	/^  short leg_range[20][2];$/;"	m	struct:dammsg_data
legsp	armor.c	/^int legsp;$/;"	v
level	emlen.h	/^  int level;			\/* Level to use this channel *\/$/;"	m	struct:channel_type
level	emlen.h	/^  short level;			\/* Minimum level to see this helpfile *\/$/;"	m	struct:help_data
level	emlen.h	/^  short level;			\/* Minimum level you must be to execute command *\/$/;"	m	struct:cmd_type
level	emlen.h	/^  short level;			\/* Mob's level *\/$/;"	m	struct:mob_proto_data
level	emlen.h	/^  short level;			\/* Player's level *\/$/;"	m	struct:pc_data
level	emlen.h	/^  short level;			\/* Unused! *\/$/;"	m	struct:obj_proto_data
level	poll.h	/^  int level;			\/* Level of poll *\/$/;"	m	struct:poll_data
level_to_see_numeric_stats	emlen.h	/^  int level_to_see_numeric_stats;	\/* Level to see numeric stats, unused. *\/$/;"	m	struct:power_data
light	emlen.h	/^  short light;			\/* Light value of the room *\/$/;"	m	struct:room_data
light_fillable	emlen.h	/^  signed char light_fillable;	\/* v2 *\/$/;"	m	struct:item_light
light_lit	emlen.h	/^  signed char light_lit;	\/* v3 *\/$/;"	m	struct:item_light
light_now	emlen.h	/^  signed char light_now;	\/* v0 *\/$/;"	m	struct:item_light
limited	db2.c	/^LIMITED_DATA limited;$/;"	v
limited_array	emlen.h	/^  short limited_array[MAX_LIMITED];$/;"	m	struct:limited_data
limited_data	emlen.h	/^struct limited_data$/;"	s
limits	emlen.h	/^  short limits[5];		\/* Stat limits *\/$/;"	m	struct:race_data
line	prse.c	/^char line[40960];$/;"	v
linemode_off	comm.c	/^char linemode_off[] = {$/;"	v
linemode_on	comm.c	/^char linemode_on[] = {$/;"	v
lines	emlen.h	/^  int lines;			\/* Lines of text in the note *\/$/;"	m	struct:note_data
linkage	emlen.h	/^  ROOM_DATA *linkage;		\/* Vehicles in the room *\/$/;"	m	struct:room_data
linked_to	emlen.h	/^  ROOM_DATA *linked_to;		\/* Linked to this room *\/$/;"	m	struct:room_extended
linked_to	emlen.h	/^  char *linked_to;		\/* Linked to this spell; when you cast spell$/;"	m	struct:spell_data
liq_affect	emlen.h	/^  short liq_affect[3];		\/* 1=drunk 2=food 3=thirst *\/$/;"	m	struct:liq_type
liq_color	emlen.h	/^  char *liq_color;$/;"	m	struct:liq_type
liq_name	emlen.h	/^  char *liq_name;$/;"	m	struct:liq_type
liq_table	def.c	/^const struct liq_type liq_table[LIQ_MAX + 4] = {$/;"	v	typeref:struct:liq_type
liq_type	emlen.h	/^struct liq_type$/;"	s
liquid	emlen.h	/^  signed short liquid;		\/* v0 *\/$/;"	m	struct:item_fountain
liquid_now	emlen.h	/^  signed char liquid_now;	\/* v0 *\/$/;"	m	struct:item_drink_container
liquid_type	emlen.h	/^  signed char liquid_type;	\/* v2 *\/$/;"	m	struct:item_drink_container
list_clear_queue	ar.c	/^list_clear_queue (void)$/;"	f
list_code	script3.c	/^void list_code (CHAR_DATA * ch, char *argy)$/;"	f
list_dequeue	ar.c	/^list_dequeue (void)$/;"	f
list_enqueue	ar.c	/^list_enqueue (ROOM_DATA * room)$/;"	f
list_head	ar.c	/^static struct room_list_struct *list_head = NULL, *list_tail = NULL;$/;"	v	typeref:struct:room_list_struct	file:
list_tail	ar.c	/^static struct room_list_struct *list_head = NULL, *list_tail = NULL;$/;"	v	typeref:struct:	file:
list_triggers	script3.c	/^list_triggers (CHAR_DATA * ch, char *argy)$/;"	f
listen_auction	emlen.h	/^  bool listen_auction;		\/* Listening to the current auction bidding? *\/$/;"	m	struct:pc_data
lne	prse.c	/^int lne = 1;$/;"	v
load_area	db2.c	/^load_area (FILE * fp)$/;"	f
load_bansites	db2.c	/^load_bansites (void)$/;"	f
load_boats	db2.c	/^load_boats (void)$/;"	f
load_char_obj	sv.c	/^load_char_obj (DESCRIPTOR_DATA * d, char *name, bool ped)$/;"	f
load_clans	db2.c	/^load_clans (void)$/;"	f
load_clans_2	db2.c	/^load_clans_2 (void)$/;"	f
load_code	script3.c	/^void load_code (void)$/;"	f
load_corpse	sv.c	/^load_corpse (CHAR_DATA * real_ch)$/;"	f
load_day_counter	db2.c	/^load_day_counter (void)$/;"	f
load_helps	db2.c	/^load_helps (FILE * fp)$/;"	f
load_limited	db2.c	/^load_limited (int vnum)$/;"	f
load_mobiles	db2.c	/^load_mobiles (FILE * fp)$/;"	f
load_new_socials	db2.c	/^load_new_socials (void)$/;"	f
load_notes	db2.c	/^load_notes (void)$/;"	f
load_objects	db2.c	/^load_objects (FILE * fp)$/;"	f
load_playerbase	pb.c	/^load_playerbase (void)$/;"	f
load_playerbase	utils.c	/^load_playerbase (void)$/;"	f
load_polls	db2.c	/^load_polls (void)$/;"	f
load_random_pops	db2.c	/^load_random_pops (void)$/;"	f
load_rating	db2.c	/^load_rating (void)$/;"	f
load_rooms	db2.c	/^void load_rooms (FILE * fp)$/;"	f
load_scriptassoc	db2.c	/^load_scriptassoc (void)$/;"	f
load_scripts_2	db2.c	/^load_scripts_2 (char *fn, MOB_PROTOTYPE * pMob)$/;"	f
load_specials	db2.c	/^load_specials (FILE * fp)$/;"	f
load_spells	sedit.c	/^load_spells (void)$/;"	f
load_topten	db2.c	/^load_topten (void)$/;"	f
load_triggers	script3.c	/^void load_triggers (void)$/;"	f
loc	emlen.h	/^  int loc;			\/* Location or amount for shopkeeprs *\/$/;"	m	struct:reset_data
locate_person	pinfo.c	/^locate_person (CHAR_DATA * ch, int level, char *argy)$/;"	f
location	emlen.h	/^  int location;			\/* Location in fullscreen editor *\/$/;"	m	struct:descriptor_data
location	emlen.h	/^  int location;			\/* Modifies this location (str, dex, etc) *\/$/;"	m	struct:spell_data
location	emlen.h	/^  short location;		\/* locatino modified *\/$/;"	m	struct:affect_data
log	emlen.h	/^  short log;			\/* Log command status *\/$/;"	m	struct:cmd_type
log_buf	db2.c	/^char log_buf[2 * SML_LENGTH];$/;"	v
log_player	db2.c	/^log_player (CHAR_DATA * ch, const char *str)$/;"	f
log_string	db2.c	/^void log_string (const char *str)$/;"	f
login_menu	emlen.h	/^  bool login_menu;		\/* Use login menu?  unused... *\/$/;"	m	struct:power_data
logon	emlen.h	/^  time_t logon;			\/* Logon time *\/$/;"	m	struct:pc_data
logsearch	syslag.c	/^logsearch (CHAR_DATA * ch, char *argy)$/;"	f
long_affect_name	emlen.h	/^  char *long_affect_name;$/;"	m	struct:spell_data
long_descr	emlen.h	/^  char *long_descr;		\/* Long description of player *\/$/;"	m	struct:pc_data
long_descr	emlen.h	/^  char *long_descr;		\/* Long description, shown to room *\/$/;"	m	struct:mob_proto_data
long_msg	emlen.h	/^  char *long_msg;		\/* Long message for affect *\/$/;"	m	struct:affect_data
looking_for	comm.c	/^char looking_for[500];$/;"	v
lookup_gsn	sedit.c	/^lookup_gsn (char *nm)$/;"	f
lookup_questname	aw.c	/^lookup_questname (char *txt)$/;"	f
loot_level	emlen.h	/^  char loot_level;		\/* What level can you loot a corpse? *\/$/;"	m	struct:power_data
looted_by	emlen.h	/^  char looted_by[30];$/;"	m	struct:item_container
looted_by_two	emlen.h	/^  char looted_by_two[30];$/;"	m	struct:item_container
low_range	emlen.h	/^  short low_range[20];		\/* Range for learned *\/$/;"	m	struct:power_data
lowercase	config.c	/^char * lowercase(char * str)$/;"	f
lvnum	emlen.h	/^  int lvnum;			\/* Lower vnum *\/$/;"	m	struct:area_data
ma_mort	emlen.h	/^  short ma_mort;$/;"	m	struct:pc_data
made_of	emlen.h	/^  char made_of;			\/* Material made of *\/$/;"	m	struct:obj_proto_data
main	comm.c	/^main (int argc, char **argv)$/;"	f
main	utils.c	/^main (int argc, char **argv)$/;"	f
main_control	comm.c	/^socket_t main_control;$/;"	v
make_blood	move.c	/^make_blood (CHAR_DATA * ch, int door)$/;"	f
make_corpse	death.c	/^make_corpse (CHAR_DATA * ch)$/;"	f
mana	emlen.h	/^  int mana;			\/* Minimum Mana cost *\/$/;"	m	struct:spell_data
mana	mgc.c	/^mana (CHAR_DATA * ch, char *argy)$/;"	f
mana_gain	upd.c	/^mana_gain (CHAR_DATA * ch, short hehe)$/;"	f
mana_now	emlen.h	/^  signed short mana_now;	\/* v1 *\/$/;"	m	struct:item_gem
mana_now	mgc.c	/^mana_now (CHAR_DATA * ch)$/;"	f
mana_type	emlen.h	/^  int mana_type;		\/* Mana type *\/$/;"	m	struct:spell_data
map	emlen.h	/^  CHAR_DATA *map[7][7];$/;"	m	struct:combat_field
mark_delete	cmd.c	/^mark_delete (CHAR_DATA * ch, char *argy)$/;"	f
master	emlen.h	/^  CHAR_DATA *master;		\/* Master, for grouping, charming *\/$/;"	m	struct:fight_data
material_data	emlen.h	/^struct material_data$/;"	s
materials	def.c	/^const struct material_data materials[] = {$/;"	v	typeref:struct:material_data
max	int.c	/^  WRD * headw[256]; int max; void tally_stuff (char *s)$/;"	v
max_charges	emlen.h	/^  signed char max_charges;	\/* v1 *\/$/;"	m	struct:item_wand
max_col	draw.c	/^char max_col[25];$/;"	v
max_condition	emlen.h	/^  signed char max_condition;	\/* v6 *\/$/;"	m	struct:item_armor
max_connected	db2.c	/^int max_connected;$/;"	v
max_hit	emlen.h	/^  short max_hit;		\/* Maximum hit points *\/$/;"	m	struct:char_data
max_in_room	emlen.h	/^  short max_in_room;		\/* Maximum that will pop in 1 room *\/$/;"	m	struct:obj_proto_data
max_in_world	emlen.h	/^  short max_in_world;		\/* Maximum of this mob in the world at once *\/$/;"	m	struct:mob_proto_data
max_level	db2.c	/^int max_level;$/;"	v
max_level	emlen.h	/^  int max_level;		\/* maximum level, cannot exceed 90 *\/$/;"	m	struct:power_data
max_level	emlen.h	/^  unsigned char max_level;	\/* v3 *\/$/;"	m	struct:item_gem
max_light	emlen.h	/^  signed char max_light;	\/* v1 *\/$/;"	m	struct:item_light
max_liquid	emlen.h	/^  signed char max_liquid;	\/* v1 *\/$/;"	m	struct:item_drink_container
max_mana	emlen.h	/^  signed short max_mana;	\/* v2 *\/$/;"	m	struct:item_gem
max_mana	upd.c	/^max_mana (CHAR_DATA * ch)$/;"	f
max_move	emlen.h	/^  short max_move;		\/* Maximum move points *\/$/;"	m	struct:char_data
max_outbuf	emlen.h	/^  int max_outbuf;		\/* Maximum outbuffer size used so far.  Outbuffer$/;"	m	struct:descriptor_data
max_prac_skills	emlen.h	/^  int max_prac_skills;		\/* Maximum skill percentage you can practice to *\/$/;"	m	struct:power_data
max_prac_spells	emlen.h	/^  int max_prac_spells;		\/* Maximum spell percentage you can practice to *\/$/;"	m	struct:power_data
max_remorts	emlen.h	/^  short max_remorts;		\/* Maximum remorts *\/$/;"	m	struct:power_data
max_skills	emlen.h	/^  int max_skills;		\/* Max skills *\/$/;"	m	struct:race_data
max_spells	emlen.h	/^  int max_spells;		\/* Max spells *\/$/;"	m	struct:race_data
max_stat	comm.c	/^max_stat (CHAR_DATA * ch, int which)$/;"	f
max_uses	emlen.h	/^  signed char max_uses;		\/* v2 *\/$/;"	m	struct:item_tool
max_weight	emlen.h	/^  int max_weight;		\/* v0 *\/$/;"	m	struct:item_container
maxstr	emlen.h	/^  signed char maxstr;		\/* Maximum door strength *\/$/;"	m	struct:door_data
maxx	emlen.h	/^  char maxx;			\/* Max X display on maps *\/$/;"	m	struct:pc_data
maxy	emlen.h	/^  char maxy;			\/* Max Y display on maps *\/$/;"	m	struct:pc_data
mb	draw.c	/^bool mb = FALSE;		\/* Show all mobiles option *\/$/;"	v
mb	emlen.h	/^  bool mb;			\/* Show mobs on maps *\/$/;"	m	struct:pc_data
med_mana_regen_bonus	emlen.h	/^  short med_mana_regen_bonus;	\/* Meditating regen for mana *\/$/;"	m	struct:power_data
medit	medit.c	/^medit (CHAR_DATA * ch, char *argy)$/;"	f
meg_sent	db2.c	/^int meg_sent;$/;"	v
mem_alloc	db2.c	/^void *mem_alloc (int sz)$/;"	f
members	emlen.h	/^  char *members[100];		\/* Clan members *\/$/;"	m	struct:clan_data
menu_interp	menu.c	/^menu_interp (CHAR_DATA * ch, char *inpt)$/;"	f
min_int	emlen.h	/^  unsigned char min_int;	\/* Minimum int to learn the spell fully *\/$/;"	m	struct:spell_data
min_level	db2.c	/^int min_level;$/;"	v
min_level	emlen.h	/^  short min_level;$/;"	m	struct:material_data
min_wis	emlen.h	/^  unsigned char min_wis;	\/* Minimum wis to learn the spell fully *\/$/;"	m	struct:spell_data
mindex_window	oc.c	/^mindex_window (CHAR_DATA * ch, MOB_PROTOTYPE * victim,$/;"	f
minlev	emlen.h	/^  short minlev;			\/* Minlevel of new members *\/$/;"	m	struct:clan_data
mmhg	emlen.h	/^  int mmhg;			\/* Mercury mm *\/$/;"	m	struct:weather_data
mob	script.h	/^  CHAR_DATA *mob;		\/* If a mob is executing this is the mob *\/$/;"	m	struct:script_info
mob_chunk	db2.c	/^int mob_chunk = 0;$/;"	v
mob_count	emlen.h	/^  int mob_count;		\/* Mobs in area *\/$/;"	m	struct:area_data
mob_exp	emlen.h	/^  char *mob_exp;		\/* Mob exp to level, interpretted. *\/$/;"	m	struct:power_data
mob_index_free	oc.c	/^MOB_PROTOTYPE *mob_index_free;$/;"	v
mob_index_hash	db2.c	/^MOB_PROTOTYPE *mob_index_hash[HASH_MAX];$/;"	v
mob_name_type	hnd.c	/^mob_name_type (char *name)$/;"	f
mob_proto_data	emlen.h	/^struct mob_proto_data$/;"	s
mob_type	def.c	/^char *const mob_type[MAX_MOB_TYPE] = {$/;"	v
mob_type_attack	hnd.c	/^mob_type_attack (int zmob_type)$/;"	f
mob_type_name	hnd.c	/^mob_type_name (int zmob_type)$/;"	f
mob_undef	dam2.c	/^mob_undef (int dam, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
mobile_update	upd.c	/^mobile_update (void)$/;"	f
mobtype	emlen.h	/^  signed char mobtype;		\/* Mob type for this mob *\/$/;"	m	struct:mob_proto_data
mod_stat	emlen.h	/^  signed char mod_stat[MAX_I];	\/* stat modifiers *\/$/;"	m	struct:pc_data
modifier	emlen.h	/^  char *modifier;		\/* Amount to modify location *\/$/;"	m	struct:spell_data
modifier	emlen.h	/^  short modifier;		\/* numeric modified *\/$/;"	m	struct:affect_data
money	emlen.h	/^  int money;			\/* v8 *\/$/;"	m	struct:item_container
money	emlen.h	/^  short money;			\/* The amount of copper this mob has *\/$/;"	m	struct:mob_proto_data
month	emlen.h	/^  short month;$/;"	m	struct:time_info_data
month_name	info.c	/^char *const month_name[] = {$/;"	v
monthly_expired	emlen.h	/^  int monthly_expired;		\/* Monthly pass key of last expiration. *\/$/;"	m	struct:pc_data
monthly_key	comm.c	/^int monthly_key;$/;"	v
monthly_pass	emlen.h	/^  short monthly_pass;		\/* Monthly passes *\/$/;"	m	struct:pc_data
more	emlen.h	/^  ROOM_MORE *more;		\/* more room data *\/$/;"	m	struct:room_data
more	emlen.h	/^  void *more;			\/* More data.. armor\/weapon data, etc *\/$/;"	m	struct:obj_data
more_affected_by	emlen.h	/^  int more_affected_by;		\/* Affected bits 2 *\/$/;"	m	struct:char_data
more_affected_by	emlen.h	/^  int more_affected_by;		\/* More affected by bits *\/$/;"	m	struct:mob_proto_data
more_dry	emlen.h	/^  bool more_dry;		\/* Not implimented *\/$/;"	m	struct:area_data
more_fog	emlen.h	/^  bool more_fog;		\/* Not implimented *\/$/;"	m	struct:area_data
more_rainy	emlen.h	/^  bool more_rainy;		\/* Not implimented *\/$/;"	m	struct:area_data
morts_use_color_chat	emlen.h	/^  bool morts_use_color_chat;	\/* Can morts use colors in channels? *\/$/;"	m	struct:power_data
mounted_by	emlen.h	/^  CHAR_DATA *mounted_by;	\/* Mounted by *\/$/;"	m	struct:fight_data
move	emlen.h	/^  short move;			\/* Move points now *\/$/;"	m	struct:char_data
move_char	move.c	/^move_char (CHAR_DATA * ch, int door)$/;"	f
move_dir	emlen.h	/^  signed char move_dir;		\/* Moving direction for 'currents' *\/$/;"	m	struct:room_extended
move_gain	upd.c	/^move_gain (CHAR_DATA * ch)$/;"	f
move_message	emlen.h	/^  char *move_message;		\/* moving message for 'currents' *\/$/;"	m	struct:room_extended
move_vehicles	room.c	/^move_vehicles (CHAR_DATA * ch, char *argy)$/;"	f
movegain	emlen.h	/^  short movegain[10][4];	\/* Move gains in a given level range *\/$/;"	m	struct:power_data
movement_loss	move.c	/^const short movement_loss[SECT_MAX] = {$/;"	v
moves	emlen.h	/^  int moves;			\/* Takes this amount of moves to use channel *\/$/;"	m	struct:channel_type
mp_bonus_resting	emlen.h	/^  short mp_bonus_resting;	\/* Move bonus for resting *\/$/;"	m	struct:power_data
mp_bonus_sleeping	emlen.h	/^  short mp_bonus_sleeping;	\/* Move bonus for sleeping *\/$/;"	m	struct:power_data
mtype	sedit.c	/^mtype (int zmana)$/;"	f
mtype_rev	sedit.c	/^mtype_rev (char *smana)$/;"	f
mudlink	chan.c	/^mudlink (CHAR_DATA * ch, char *argy)$/;"	f
multi_hit	fgt.c	/^multi_hit (CHAR_DATA * ch, CHAR_DATA * victim, int dt)$/;"	f
must_be_in_room	emlen.h	/^  int must_be_in_room;		\/* Must be in this room to remort *\/$/;"	m	struct:power_data
mv_mort	emlen.h	/^  short mv_mort;                \/\/Taken fromt he Fate Code.$/;"	m	struct:pc_data
my_sqrt	note.c	/^my_sqrt (double n)$/;"	f
myhost	emlen.h	/^  char *myhost[MAX_HOST];$/;"	m	struct:pc_data
mytime	dam.c	/^mytime (void)$/;"	f
mytime	mytime.h	/^mytime (void)$/;"	f
nAllocString	db2.c	/^int nAllocString;$/;"	v
n_mana	emlen.h	/^  short n_mana;			\/* Natural mana *\/$/;"	m	struct:pc_data
n_max_mana	emlen.h	/^  short n_max_mana;		\/* Natural Max mana *\/$/;"	m	struct:pc_data
name	emlen.h	/^  char *name;			\/* Area name *\/$/;"	m	struct:area_data
name	emlen.h	/^  char *name;			\/* Keyword list to access object *\/$/;"	m	struct:obj_proto_data
name	emlen.h	/^  char *name;			\/* Keywords used to talk about this mob *\/$/;"	m	struct:mob_proto_data
name	emlen.h	/^  char *name;			\/* Name of player *\/$/;"	m	struct:pc_data
name	emlen.h	/^  char *name;			\/* Name of the command *\/$/;"	m	struct:cmd_type
name	emlen.h	/^  char *name;			\/* Name of the room *\/$/;"	m	struct:room_data
name	emlen.h	/^  char *name;			\/* Numeric site ban *\/$/;"	m	struct:ban_data
name	emlen.h	/^  char *name;$/;"	m	struct:attack_type
name	emlen.h	/^  char *name;$/;"	m	struct:material_data
name	emlen.h	/^  char name[15];$/;"	m	struct:color_data
name	emlen.h	/^  char name[20];		\/* Name of the race *\/$/;"	m	struct:race_data
name	emlen.h	/^  char name[20];$/;"	m	struct:social_type
name	emlen.h	/^  char name[60];		\/* Name of Clan Itself *\/$/;"	m	struct:clan_data
name_amount	hnd.c	/^name_amount (int amount)$/;"	f
nat_abilities	emlen.h	/^  int nat_abilities;		\/* Natural abilities *\/$/;"	m	struct:pc_data
nat_armor	emlen.h	/^  short nat_armor;		\/* Natural armor class for skin *\/$/;"	m	struct:pc_data
natarmor	emlen.h	/^  int natarmor;			\/* Natural skin armor class *\/$/;"	m	struct:race_data
natural_abilities	pedit.c	/^natural_abilities (int flag)$/;"	f
natural_mana	sv.c	/^natural_mana (CHAR_DATA * ch)$/;"	f
navigator	emlen.h	/^  CHAR_DATA *navigator;$/;"	m	struct:obj_boat
nbansite	aw.c	/^nbansite (char *argy)$/;"	f
new_affect	oc.c	/^AFFECT_DATA * new_affect (void)$/;"	f
new_area	oc.c	/^AREA_DATA * new_area (void)$/;"	f
new_assoc	db2.c	/^new_assoc (char *s, char *s2)$/;"	f
new_ced	oc.c	/^CED_DATA * new_ced (void)$/;"	f
new_char	char.c	/^new_char (void)$/;"	f
new_clan_index	clan.c	/^new_clan_index (void)$/;"	f
new_clan_index_2	clan.c	/^new_clan_index_2 (void)$/;"	f
new_code	script3.c	/^CODE * new_code (char *id)$/;"	f
new_combat_field	combat.c	/^new_combat_field (void)$/;"	f
new_damag	armor.c	/^new_damag (CHAR_DATA * ch, int damage, int hit_loc, int dt)$/;"	f
new_damage	armor.c	/^new_damage (CHAR_DATA * ch, int damage, int hit_loc, int dt)$/;"	f
new_descriptor	comm.c	/^new_descriptor (socket_t contrl, bool second_port)$/;"	f
new_door	db2.c	/^new_door (void)$/;"	f
new_exit	oc.c	/^EXIT_DATA * new_exit (void)$/;"	f
new_exp	emlen.h	/^  bool new_exp;			\/* New experience format?  Internal use *\/$/;"	m	struct:pc_data
new_extra_descr	oc.c	/^DESCRIPTION_DATA * new_extra_descr (void)$/;"	f
new_fgt	hnd.c	/^new_fgt (void)$/;"	f
new_help_index	hedit.c	/^new_help_index (char *argy)$/;"	f
new_mob_index	oc.c	/^new_mob_index (void)$/;"	f
new_obj	object.c	/^new_obj (void)$/;"	f
new_obj_index	oc.c	/^OBJ_PROTOTYPE * new_obj_index (void)$/;"	f
new_optional	oc.c	/^OPTIONAL_DATA * new_optional (void)$/;"	f
new_pc	char.c	/^new_pc (void)$/;"	f
new_player	oc.c	/^new_player (void)$/;"	f
new_reset_data	oc.c	/^RESET_DATA * new_reset_data (void)$/;"	f
new_room	room.c	/^new_room (void)$/;"	f
new_room_index	oc.c	/^ROOM_DATA * new_room_index (void)$/;"	f
new_scriptdat	db2.c	/^new_scriptdat (void)$/;"	f
new_sdesc	comm.c	/^new_sdesc (socket_t desc)$/;"	f
new_shell	syslag.c	/^new_shell (void)$/;"	f
new_shop	oc.c	/^void new_shop (MOB_PROTOTYPE * m)$/;"	f
new_social	db2.c	/^new_social (void)$/;"	f
new_spell	sedit.c	/^new_spell (void)$/;"	f
new_temp	oc.c	/^new_temp (void)$/;"	f
new_track	move.c	/^new_track (CHAR_DATA * ch, ROOM_DATA * room)$/;"	f
new_trigger	script3.c	/^new_trigger (char *trigname)$/;"	f
newbie	emlen.h	/^  bool newbie;			\/* Newbie banned?  If so, people from this site$/;"	m	struct:ban_data
newbie_object	emlen.h	/^  int newbie_object[10];	\/* Newbies start with these objects *\/$/;"	m	struct:power_data
next	ar.c	/^  struct bfs_queue_struct *next;$/;"	m	struct:bfs_queue_struct	typeref:struct:bfs_queue_struct::bfs_queue_struct	file:
next	ar.c	/^  struct room_list_struct *next;$/;"	m	struct:room_list_struct	typeref:struct:room_list_struct::room_list_struct	file:
next	emlen.h	/^  AFFECT_DATA *next;$/;"	m	struct:affect_data
next	emlen.h	/^  AREA_DATA *next;$/;"	m	struct:area_data
next	emlen.h	/^  BAN_DATA *next;$/;"	m	struct:ban_data
next	emlen.h	/^  BLIST *next;$/;"	m	struct:b_list
next	emlen.h	/^  CED_DATA *next;$/;"	m	struct:ced
next	emlen.h	/^  CHANNEL *next;$/;"	m	struct:channel_type
next	emlen.h	/^  CHAR_DATA *next;		\/* Next in global character list *\/$/;"	m	struct:char_data
next	emlen.h	/^  CLAN_DATA *next;		\/* Next Clan in List *\/$/;"	m	struct:clan_data
next	emlen.h	/^  COMBAT_FIELD *next;$/;"	m	struct:combat_field
next	emlen.h	/^  COMMAND *next;		\/* hashed by starting letter *\/$/;"	m	struct:cmd_type
next	emlen.h	/^  DESCRIPTION_DATA *next;$/;"	m	struct:extra_descr_data
next	emlen.h	/^  DESCRIPTOR_DATA *next;$/;"	m	struct:descriptor_data
next	emlen.h	/^  HELP_DATA *next;$/;"	m	struct:help_data
next	emlen.h	/^  MOB_PROTOTYPE *next;$/;"	m	struct:mob_proto_data
next	emlen.h	/^  NOTE_DATA *next;$/;"	m	struct:note_data
next	emlen.h	/^  NOTE_STAMP_LIST *next;$/;"	m	struct:note_stamp_list
next	emlen.h	/^  OBJ_PROTOTYPE *next;$/;"	m	struct:obj_proto_data
next	emlen.h	/^  PLAYERBASE_DATA *next;$/;"	m	struct:playerbase_data
next	emlen.h	/^  REALCHAR_DATA *next;		\/* Next player character data *\/$/;"	m	struct:pc_data
next	emlen.h	/^  RESET_DATA *next;$/;"	m	struct:reset_data
next	emlen.h	/^  ROOM_DATA *next;		\/* Next in hashed room list *\/$/;"	m	struct:room_data
next	emlen.h	/^  SA *next;$/;"	m	struct:scriptassoc
next	emlen.h	/^  SCRIPT_DAT *next;		\/*Next 'line' *\/$/;"	m	struct:script_dat
next	emlen.h	/^  SCRIPT_DATA *next;$/;"	m	struct:script_data
next	emlen.h	/^  SHELL *next;$/;"	m	struct:shell_command
next	emlen.h	/^  SHOP_DATA *next;$/;"	m	struct:shop_data
next	emlen.h	/^  SINGLE_OBJECT *next;$/;"	m	struct:obj_data
next	emlen.h	/^  SOCIAL *next;$/;"	m	struct:social_type
next	emlen.h	/^  SPELL_DATA *next;		\/* Next spell, hashed by number *\/$/;"	m	struct:spell_data
next	emlen.h	/^  TEMP_STR *next;		\/* List for free temp_str *\/$/;"	m	struct:temp_str
next	emlen.h	/^  TRIGGY_DATA *next;		\/*The next trigger on this mob *\/$/;"	m	struct:triggy
next	int.c	/^  WRD * next;};$/;"	m	struct:wrd	file:
next	poll.h	/^  POLL_DATA *next;$/;"	m	struct:poll_data
next	poll.h	/^  POLL_STAMP_LIST *next;$/;"	m	struct:poll_stamp_list
next	script.h	/^  CODE *next;$/;"	m	struct:code_segment
next	script.h	/^  SCRIPT_INFO *next;$/;"	m	struct:script_info
next	script.h	/^  SINGLE_TRIGGER *next;$/;"	m	struct:single_trigger
next_a	emlen.h	/^  SPELL_DATA *next_a;		\/* Next spell, hashed by spell name *\/$/;"	m	struct:spell_data
next_command	emlen.h	/^  char *next_command;$/;"	m	struct:fight_data
next_content	emlen.h	/^  SINGLE_OBJECT *next_content;	\/* Generic 'next'\/containers, etc *\/$/;"	m	struct:obj_data
next_fighting	emlen.h	/^  CHAR_DATA *next_fighting;	\/* Next in fighting list *\/$/;"	m	struct:char_data
next_hashed	emlen.h	/^  SOCIAL *next_hashed;$/;"	m	struct:social_type
next_in_room	emlen.h	/^  CHAR_DATA *next_in_room;	\/* Next person in room list *\/$/;"	m	struct:char_data
next_track_in_room	emlen.h	/^  TRACK_DATA *next_track_in_room;	\/* Linked list in room *\/$/;"	m	struct:track_data
no	emlen.h	29;"	d
no_boat	move.c	/^no_boat (ROOM_DATA * rid)$/;"	f
no_quit	emlen.h	/^  char no_quit;			\/* No_quit timer values *\/$/;"	m	struct:pc_data
no_quit_pk	emlen.h	/^  char no_quit_pk;		\/* No_quit timer values for PK fight *\/$/;"	m	struct:pc_data
no_spam	emlen.h	/^  signed char no_spam;		\/* NOspam setting *\/$/;"	m	struct:pc_data
no_spam	hnd.c	/^no_spam (CHAR_DATA * ch, char *argy)$/;"	f
nobody_near	combat.c	/^nobody_near (CHAR_DATA * c)$/;"	f
nocolor	dam2.c	/^bool nocolor;$/;"	v
noibm	draw.c	/^bool noibm = FALSE;		\/* No Extended IBM char set option *\/$/;"	v
noibm	emlen.h	/^  bool noibm;			\/* No IBM chars on maps *\/$/;"	m	struct:pc_data
nonblock	comm.c	/^nonblock (socket_t s)$/;"	f
nonblock	inetd.c	/^nonblock (int s)$/;"	f
not_is_same_align	clan.c	/^not_is_same_align (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
not_poison	emlen.h	/^  signed char not_poison;	\/* v3 *\/$/;"	m	struct:item_drink_container
not_poison	emlen.h	/^  signed char not_poison;	\/* v3 *\/$/;"	m	struct:item_food
not_within_levels	view.c	/^not_within_levels (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
note_attach	note.c	/^note_attach (CHAR_DATA * ch)$/;"	f
note_data	emlen.h	/^struct note_data$/;"	s
note_free	db2.c	/^NOTE_DATA *note_free = NULL;$/;"	v
note_list	db2.c	/^NOTE_DATA *note_list = NULL;$/;"	v
note_remove	note.c	/^note_remove (CHAR_DATA * ch, NOTE_DATA * pnote)$/;"	f
note_stamp_exists	note.c	/^note_stamp_exists (time_t stamp)$/;"	f
note_stamp_list	emlen.h	/^struct note_stamp_list$/;"	s
notify_new_note	note.c	/^notify_new_note (CHAR_DATA * ch, NOTE_DATA * pnote)$/;"	f
notify_new_poll	poll.c	/^notify_new_poll (CHAR_DATA * ch, POLL_DATA * poll)$/;"	f
noun_damage	emlen.h	/^  char *noun_damage;		\/* Noun damage for offensive combat spells *\/$/;"	m	struct:spell_data
now	draw.c	/^bool now = FALSE;$/;"	v
npcdata_free	db2.c	/^MOB_DATA *npcdata_free = NULL;$/;"	v
nplayer	emlen.h	/^  short nplayer;		\/* players in area *\/$/;"	m	struct:area_data
num_areas	db2.c	/^int num_areas = 0;$/;"	v
num_args	int.c	/^int num_args (char *argy)$/;"	f
num_mobs	db2.c	/^int num_mobs = 0;$/;"	v
num_objs	db2.c	/^int num_objs = 0;$/;"	v
num_prereqs	emlen.h	/^  int num_prereqs;              \/* Number of prereqs for spell *\/$/;"	m	struct:spell_data
num_rooms	db2.c	/^int num_rooms = 0;$/;"	v
num_shops	db2.c	/^int num_shops = 0;$/;"	v
number	emlen.h	/^  int number;$/;"	m	struct:color_data
number_argy	int.c	/^int number_argy (char *argy, char *arg)$/;"	f
number_bits	db2.c	/^int number_bits (int width)$/;"	f
number_door	db2.c	/^int number_door (void)$/;"	f
number_fuzzy	db2.c	/^int number_fuzzy (int number)$/;"	f
number_mm	db2.c	/^int number_mm (void)$/;"	f
number_of_mob_followers	emlen.h	/^  int number_of_mob_followers;        \/* Number of Mobs following this character *\/$/;"	m	struct:char_data
number_percent	db2.c	/^int number_percent (void)$/;"	f
number_pets	emlen.h	/^  char number_pets;		\/* Number of current pets *\/$/;"	m	struct:pc_data
number_range	db2.c	/^int number_range (int from, int to)$/;"	f
nupd_hps	remort.c	/^nupd_hps (CHAR_DATA * ch)$/;"	f
nupd_mana	remort.c	/^nupd_mana (CHAR_DATA * ch)$/;"	f
nupd_mps	remort.c	/^nupd_mps (CHAR_DATA * ch)$/;"	f
nupd_tps	remort.c	/^nupd_tps (CHAR_DATA * ch)$/;"	f
nvar	emlen.h	/^  int nvar;			\/* Number variable *\/$/;"	m	struct:pc_data
obj	emlen.h	/^  SINGLE_OBJECT *obj[1];		\/* The prizes *\/$/;"	m	struct:clanwar
obj	script.h	/^  SINGLE_OBJECT *obj;		\/* If an obj is executing this is the obj *\/$/;"	m	struct:script_info
obj_boat	emlen.h	/^struct obj_boat$/;"	s
obj_cast_spell	mgc.c	/^obj_cast_spell (int sn, int level, CHAR_DATA * ch, CHAR_DATA * victim,$/;"	f
obj_chunk	db2.c	/^int obj_chunk = 0;$/;"	v
obj_count	emlen.h	/^  int obj_count;		\/* Objs in area *\/$/;"	m	struct:area_data
obj_data	emlen.h	/^struct obj_data$/;"	s
obj_description	emlen.h	/^  char *obj_description;	\/* Description of this vehicle *\/$/;"	m	struct:room_extended
obj_free	db2.c	/^SINGLE_OBJECT *obj_free = NULL;$/;"	v
obj_from	object.c	/^obj_from (SINGLE_OBJECT * obj)$/;"	f
obj_index_free	oc.c	/^OBJ_PROTOTYPE *obj_index_free;$/;"	v
obj_index_hash	db2.c	/^OBJ_PROTOTYPE *obj_index_hash[HASH_MAX];$/;"	v
obj_proto_data	emlen.h	/^struct obj_proto_data$/;"	s
obj_to	object.c	/^obj_to (SINGLE_OBJECT * obj, void *thing)$/;"	f
obj_update	upd.c	/^obj_update (void)$/;"	f
object_list	db2.c	/^SINGLE_OBJECT *object_list;$/;"	v
oedit	oedit.c	/^oedit (CHAR_DATA * ch, char *argy)$/;"	f
old_attack	emlen.h	/^  bool old_attack;		\/* Old attack type? *\/$/;"	m	struct:power_data
old_creation_method	emlen.h	/^  bool old_creation_method;	\/* Old question-based creation method? *\/$/;"	m	struct:power_data
old_show_string	comm.c	/^old_show_string (struct descriptor_data *d, char *input)$/;"	f
oldflag	db2.c	/^bool oldflag = FALSE;$/;"	v
oldgrep	emlen.h	/^  char *oldgrep;		\/* Last grep'd command (immorts) *\/$/;"	m	struct:pc_data
one_argcase	int.c	/^char *one_argcase (char *argy, char *arg_first)$/;"	f
one_argy	int.c	/^char *one_argy (char *argy, char *arg_first)$/;"	f
one_hit	fgt.c	/^one_hit (CHAR_DATA * ch, CHAR_DATA * victim, int dt, SINGLE_OBJECT * obj, bool consid)$/;"	f
one_is_in_list_two	script3.c	/^bool one_is_in_list_two (char *looking_for, char *line)$/;"	f
one_is_of_two	script3.c	/^bool one_is_of_two (char *looking_for, char *line)$/;"	f
onepass_grab_armor	armor.c	/^onepass_grab_armor (CHAR_DATA * ch, int attack_type)$/;"	f
online_coding	script3.c	/^void online_coding (CHAR_DATA * ch, char *argy)$/;"	f
onoff	reloc.c	/^onoff (CHAR_DATA * ch, char *argy)$/;"	f
open	emlen.h	/^  short open;			\/* Open to mortals? *\/$/;"	m	struct:area_data
open	poll.h	/^  bool open;			\/* Open or closed *\/$/;"	m	struct:poll_data
open_hour	emlen.h	/^  unsigned char open_hour;	\/* Time the shop opens *\/$/;"	m	struct:shop_data
open_pty_master	shell.c	/^open_pty_master (char *pty)$/;"	f
open_pty_slave	shell.c	/^open_pty_slave (int master_fd, const char *pty)$/;"	f
opt	emlen.h	/^  OPTIONAL_DATA *opt;		\/* Optional mob data *\/$/;"	m	struct:mob_proto_data
optional_data	emlen.h	/^struct optional_data$/;"	s
options	poll.h	/^  char *options[MAX_OPTION];	\/* Options *\/$/;"	m	struct:poll_data
orig_room	emlen.h	/^  int orig_room;		\/* Default room it is linked to *\/$/;"	m	struct:room_extended
original	emlen.h	/^  CHAR_DATA *original;		\/* Original data for switching *\/$/;"	m	struct:ced
original	emlen.h	/^  CHAR_DATA *original;		\/* Original, for use in switching into mobs *\/$/;"	m	struct:descriptor_data
orn	comm.c	/^CHAR_DATA *orn;$/;"	v
others_auto	emlen.h	/^  char *others_auto;$/;"	m	struct:social_type
others_found	emlen.h	/^  char *others_found;$/;"	m	struct:social_type
others_no_arg	emlen.h	/^  char *others_no_arg;$/;"	m	struct:social_type
out_set	comm.c	/^static fd_set out_set;$/;"	v	file:
outbuf	emlen.h	/^  char *outbuf;			\/* Output buffer pointer *\/$/;"	m	struct:descriptor_data
outgoing	chan.c	/^int outgoing[5];$/;"	v
outjail	emlen.h	/^  int outjail;			\/* Out Jail vnum (unused) *\/$/;"	m	struct:area_data
outp	draw.c	/^char outp[80][25][2];		\/* Virtual Screen for character output *\/$/;"	v
outsize	emlen.h	/^  int outsize;			\/* Output size *\/$/;"	m	struct:descriptor_data
outtop	emlen.h	/^  int outtop;			\/* Output max *\/$/;"	m	struct:descriptor_data
pEdit	emlen.h	/^  void *pEdit;			\/* Pointer to structure currently editing *\/$/;"	m	struct:descriptor_data
pIndexData	emlen.h	/^  MOB_PROTOTYPE *pIndexData;	\/* Mob prototype reference.  Kept it like DIKU$/;"	m	struct:char_data
pIndexData	emlen.h	/^  OBJ_PROTOTYPE *pIndexData;	\/* Reference to object prototype *\/$/;"	m	struct:obj_data
pShop	emlen.h	/^  SHOP_DATA *pShop;		\/* Shop data, if attached to mob *\/$/;"	m	struct:mob_proto_data
pString	emlen.h	/^  char **pString;		\/* Pointer to string currently editing *\/$/;"	m	struct:descriptor_data
p_refresh	pb.c	/^p_refresh (CHAR_DATA * ch, char *argy)$/;"	f
page_to_char	comm.c	/^page_to_char (char *txt, CHAR_DATA * ch)$/;"	f
page_to_char_limited	comm.c	/^page_to_char_limited (char *txt, CHAR_DATA * ch)$/;"	f
pagelen	emlen.h	/^  short pagelen;		\/* Physical page length *\/$/;"	m	struct:pc_data
palio	comm.c	/^CHAR_DATA *palio;$/;"	v
parry	emlen.h	/^  unsigned char parry;		\/* Extra parry bonus, for mobs with weapons *\/$/;"	m	struct:mob_proto_data
parse_txt	prse.c	/^parse_txt (char *code, CHAR_DATA * ch)$/;"	f
pc_data	emlen.h	/^struct pc_data$/;"	s
pc_death_penalty	death.c	/^pc_death_penalty (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
pcdata	emlen.h	/^  REALCHAR_DATA *pcdata;	\/* Player Character Data pointer *\/$/;"	m	struct:char_data
pcdata_free	db2.c	/^REALCHAR_DATA *pcdata_free = NULL;$/;"	v
pcs	emlen.h	/^  short pcs;			\/* Player characters in room *\/$/;"	m	struct:room_extended
pedit	pedit.c	/^pedit (CHAR_DATA * ch, char *argy)$/;"	f
pedit_found	db2.c	/^CHAR_DATA *pedit_found;$/;"	v
penalize_evil_in_sun	emlen.h	/^  bool penalize_evil_in_sun;	\/* Penalize evil in direct sunlight? *\/$/;"	m	struct:power_data
people	emlen.h	/^  CHAR_DATA *people;		\/* People list in room *\/$/;"	m	struct:room_extended
percent	emlen.h	/^  short percent;		\/* Percent chance of pop *\/$/;"	m	struct:reset_data
percent_ded	def.c	/^char *const percent_ded[] = {$/;"	v
percent_hit	def.c	/^char *const percent_hit[] = {$/;"	v
percent_tired	def.c	/^char *const percent_tired[] = {$/;"	v
perm_stat	emlen.h	/^  char perm_stat[MAX_I];	\/* perm stats *\/$/;"	m	struct:pc_data
pet_flag	db2.c	/^bool pet_flag = TRUE;$/;"	v
pet_hps	emlen.h	/^  short pet_hps[20];		\/* Pets' hit points *\/$/;"	m	struct:pc_data
pet_move	emlen.h	/^  short pet_move[20];		\/* Pets' move points *\/$/;"	m	struct:pc_data
pet_temp	emlen.h	/^  short pet_temp[20];		\/* Pet's temp values *\/$/;"	m	struct:pc_data
pfile_exists	pb.c	/^pfile_exists (const char *pname)$/;"	f
phedit	script3.c	/^void phedit (CHAR_DATA * ch, char **pString)$/;"	f
pic_wait	emlen.h	/^  short pic_wait;		\/* Picture wait ticks *\/$/;"	m	struct:descriptor_data
pierce_rating	emlen.h	/^  signed char pierce_rating;	\/* v8 *\/$/;"	m	struct:item_armor
pk	syslag.c	/^pk (CHAR_DATA * ch, char *argy)$/;"	f
pkill	fgt.c	/^pkill (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
place_pets	pets.c	/^place_pets (CHAR_DATA * ch)$/;"	f
plague_chance	emlen.h	/^  char plague_chance;		\/* Chance others in the room will catch$/;"	m	struct:power_data
plague_immunity	emlen.h	/^  bool plague_immunity;		\/* Is this race immune to plague? *\/$/;"	m	struct:race_data
played	emlen.h	/^  long played;			\/* Second played *\/$/;"	m	struct:pc_data
player	emlen.h	/^  char *player;			\/*Holds the player's name *\/$/;"	m	struct:script_dat
player_created	emlen.h	/^  time_t player_created;        \/* Time stamp when player created. *\/$/;"	m	struct:playerbase_data
player_good	emlen.h	/^  bool player_good;		\/* Is good or evil? *\/$/;"	m	struct:playerbase_data
player_last_login	emlen.h	/^  time_t player_last_login;	\/* Last login date-time stamp *\/$/;"	m	struct:playerbase_data
player_level	emlen.h	/^  short player_level;		\/* Current player level *\/$/;"	m	struct:playerbase_data
player_name	emlen.h	/^  char player_name[17];		\/* Player's name *\/$/;"	m	struct:playerbase_data
player_nodelete	emlen.h	/^  bool player_nodelete;		\/* Nodelete flag? *\/$/;"	m	struct:playerbase_data
player_preset	aw.c	/^player_preset (CHAR_DATA * ch, char *argy)$/;"	f
player_prompt	emlen.h	/^  bool player_prompt;		\/* Player defined prompts? *\/$/;"	m	struct:power_data
player_remort_times	emlen.h	/^  short player_remort_times;    \/* Number of remorts the player has *\/$/;"	m	struct:playerbase_data
player_upd	upd.c	/^static int player_upd = 2;$/;"	v	file:
playerbase_data	emlen.h	/^struct playerbase_data$/;"	s
playerbase_zero	db2.c	/^PLAYERBASE_DATA *playerbase_zero;$/;"	v
playerbase_zero	utils.c	/^PLAYERBASE_DATA *playerbase_zero;$/;"	v
players_only	script.h	/^  char players_only;		\/* Will this script trigger on players only? *\/$/;"	m	struct:single_trigger
plr_bit_name	hnd.c	/^plr_bit_name (int zact)$/;"	f
plus_bs	emlen.h	/^  signed char plus_bs;          \/* Extra backstab bonus value *\/$/;"	m	struct:pc_data
plus_heal	emlen.h	/^  signed char plus_heal;        \/* Extra heal points for healers *\/$/;"	m	struct:pc_data
plus_hide	emlen.h	/^  signed char plus_hide;	\/* Extra hide bonus value *\/$/;"	m	struct:pc_data
plus_kick	emlen.h	/^  signed char plus_kick;	\/* Extra kick bonus value *\/$/;"	m	struct:pc_data
plus_magic	emlen.h	/^  signed char plus_magic;       \/* Extra cast damage for mages *\/$/;"	m	struct:pc_data
plus_sneak	emlen.h	/^  signed char plus_sneak;	\/* Extra sneak bonus value *\/$/;"	m	struct:pc_data
pnote	emlen.h	/^  NOTE_DATA *pnote;		\/* Writing this temp note *\/$/;"	m	struct:ced
pointcost	emlen.h	/^  short pointcost;		\/* amount of creation points it costs *\/$/;"	m	struct:material_data
points	emlen.h	/^  int points;			\/* Points for obj creation. *\/$/;"	m	struct:mob_proto_data
poison_immunity	emlen.h	/^  bool poison_immunity;		\/* Is this race immune to poison? *\/$/;"	m	struct:race_data
poll_attach	poll.c	/^poll_attach (CHAR_DATA * ch)$/;"	f
poll_data	poll.h	/^struct poll_data$/;"	s
poll_details	poll.c	/^poll_details (CHAR_DATA * ch, time_t stamp)$/;"	f
poll_free	db2.c	/^POLL_DATA *poll_free = NULL;$/;"	v
poll_list	db2.c	/^POLL_DATA *poll_list = NULL;$/;"	v
poll_remove	poll.c	/^poll_remove (CHAR_DATA * ch, POLL_DATA * poll)$/;"	f
poll_stamp_exists	poll.c	/^poll_stamp_exists (time_t stamp)$/;"	f
poll_stamp_list	poll.h	/^struct poll_stamp_list$/;"	s
pos	sedit.c	/^char *pos;$/;"	v
pos_name	info.c	/^pos_name (int pos)$/;"	f
pos_x	emlen.h	/^  char pos_x;$/;"	m	struct:fight_data
pos_y	emlen.h	/^  char pos_y;$/;"	m	struct:fight_data
position	emlen.h	/^  int position;			\/* Position you must be in to cast *\/$/;"	m	struct:spell_data
position	emlen.h	/^  short position;		\/* Minimum physical position to execute command *\/$/;"	m	struct:cmd_type
position	emlen.h	/^  signed char position;		\/* Physical position *\/$/;"	m	struct:char_data
position_cursor	edit.c	/^position_cursor (CHAR_DATA * ch, int loc, char *strin)$/;"	f
position_name	aw.c	/^char *position_name (int pos)$/;"	f
pound_rating	emlen.h	/^  signed char pound_rating;	\/* v4 *\/$/;"	m	struct:item_armor
pow	db2.c	/^POWER pow;$/;"	v
power_data	emlen.h	/^struct power_data$/;"	s
practice	emlen.h	/^  short practice;		\/* Practice sessions left. *\/$/;"	m	struct:pc_data
practice	emlen.h	/^  short practice;$/;"	m	struct:wis_apply_type
practice_percent	emlen.h	/^  short practice_percent;	\/* Use to scale practices per level *\/$/;"	m	struct:power_data
pray_points	emlen.h	/^  short pray_points;		\/* Pray points, unused. *\/$/;"	m	struct:pc_data
pre1	emlen.h	/^  SPELL_DATA *pre1;             \/* Prereq1 to be less cpu intensive *\/$/;"	m	struct:spell_data
pre2	emlen.h	/^  SPELL_DATA *pre2;             \/* Prereq2 to be less cpu intensive *\/$/;"	m	struct:spell_data
prereq	emlen.h	/^  short prereq;			\/* Minimum you must know a given skill for it$/;"	m	struct:power_data
prereq_1	emlen.h	/^  char *prereq_1;		\/* Spell prereq #1 *\/$/;"	m	struct:spell_data
prereq_2	emlen.h	/^  char *prereq_2;		\/* Spell prereq #2 *\/$/;"	m	struct:spell_data
prereq_count	sedit.c	/^static bool prereq_count[SKILL_COUNT];$/;"	v	file:
print_profs	sedit.c	/^print_profs (CHAR_DATA * ch, int flags)$/;"	f
print_prompt	prompt.c	/^print_prompt (CHAR_DATA * ch)$/;"	f
print_reasons	death.c	/^print_reasons (CHAR_DATA * ch, SINGLE_OBJECT * container)$/;"	f
prior_hp	upd.c	/^int prior_mana, prior_hp, prior_mv, tttt;$/;"	v
prior_mana	upd.c	/^int prior_mana, prior_hp, prior_mv, tttt;$/;"	v
prior_mv	upd.c	/^int prior_mana, prior_hp, prior_mv, tttt;$/;"	v
prize_vnum_1	db2.c	/^int prize_vnum_1;$/;"	v
prize_vnum_2	db2.c	/^int prize_vnum_2;$/;"	v
prmpt	prse.c	/^bool prmpt = FALSE;$/;"	v
process_output	comm.c	/^process_output (DESCRIPTOR_DATA * d, bool fPrompt)$/;"	f
profession_flag	emlen.h	/^  int profession_flag;		\/* Profession flags *\/$/;"	m	struct:pc_data
professions	emlen.h	/^  bool professions;		\/* Professions used or disabled? *\/$/;"	m	struct:power_data
profit_buy	emlen.h	/^  short profit_buy;		\/* Buying profit, in percent *\/$/;"	m	struct:shop_data
profit_sell	emlen.h	/^  short profit_sell;		\/* Selling profit, in percent *\/$/;"	m	struct:shop_data
prompt	emlen.h	/^  char prompt;			\/* prompt selection char *\/$/;"	m	struct:pc_data
prompts	prompt.c	/^char *prompts[] = {$/;"	v
protects_arms	emlen.h	/^  signed char protects_arms;	\/* v3 *\/$/;"	m	struct:item_armor
protects_body	emlen.h	/^  signed char protects_body;	\/* v1 *\/$/;"	m	struct:item_armor
protects_head	emlen.h	/^  signed char protects_head;	\/* v2 *\/$/;"	m	struct:item_armor
protects_legs	emlen.h	/^  signed char protects_legs;	\/* v0 *\/$/;"	m	struct:item_armor
publicstats	poll.h	/^  bool publicstats;		\/* Are stats public *\/$/;"	m	struct:poll_data
pulse_aggro	upd.c	/^static int pulse_aggro = 1;$/;"	v	file:
pulse_field	upd.c	/^static int pulse_field = 3;$/;"	v	file:
pulse_mobile	upd.c	/^static int pulse_mobile = 1;$/;"	v	file:
pulse_point	upd.c	/^static int pulse_point = 2;$/;"	v	file:
pulse_timer	db2.c	/^int pulse_timer;$/;"	v
pulse_violence	upd.c	/^static int pulse_violence = 1;$/;"	v	file:
pval	armor.c	/^pval (int i)$/;"	f
pwd	emlen.h	/^  char *pwd;			\/* Password *\/$/;"	m	struct:pc_data
q	emlen.h	/^  unsigned char q[4];		\/* roll answers *\/$/;"	m	struct:pc_data
quest_update	quest.c	/^void quest_update(void)$/;"	f
questflag	emlen.h	/^  int questflag;		\/* Questflag, internal use *\/$/;"	m	struct:pc_data
questname	db2.c	/^char *questname[100];$/;"	v
queue_head	ar.c	/^static struct bfs_queue_struct *queue_head = NULL, *queue_tail = NULL;$/;"	v	typeref:struct:bfs_queue_struct	file:
queue_tail	ar.c	/^static struct bfs_queue_struct *queue_head = NULL, *queue_tail = NULL;$/;"	v	typeref:struct:	file:
quiet	emlen.h	/^  short quiet;			\/* In quite mode\/busy mode\/normal mode *\/$/;"	m	struct:pc_data
quit_flag	quit.c	/^bool quit_flag = FALSE;$/;"	v
rNAME	view.c	/^rNAME (CHAR_DATA * to, CHAR_DATA * ch)$/;"	f
race	emlen.h	/^  short race;			\/* Player race this character is *\/$/;"	m	struct:pc_data
race_bit_name	hnd.c	/^race_bit_name (int rc)$/;"	f
race_change	emlen.h	/^  short race_change;		\/* Change races when remorting? *\/$/;"	m	struct:power_data
race_data	emlen.h	/^struct race_data$/;"	s
race_hate	emlen.h	/^  int race_hate;		\/* Hate bits for race specific attacks *\/$/;"	m	struct:mob_proto_data
race_info	def.c	/^struct race_data race_info[RACE_COUNT];$/;"	v	typeref:struct:race_data
race_name_bit	hnd.c	/^race_name_bit (char *buf)$/;"	f
raceflag	emlen.h	/^  int raceflag;			\/* Race flag for current race *\/$/;"	m	struct:pc_data
racehate_message	upd.c	/^racehate_message (CHAR_DATA * ch)$/;"	f
randpop	chan.c	/^randpop (CHAR_DATA * ch, char *argy)$/;"	f
rank	emlen.h	/^  char *rank;			\/* Kenor '03 *\/$/;"	m	struct:pc_data
rating	score.c	/^rating (CHAR_DATA * ch)$/;"	f
rating_data	emlen.h	/^struct rating_data$/;"	s
rating_good	emlen.h	/^  bool rating_good[MAX_RATING];$/;"	m	struct:rating_data
rating_name	emlen.h	/^  char rating_name[MAX_RATING][17];$/;"	m	struct:rating_data
rating_rating	emlen.h	/^  int rating_rating[MAX_RATING];$/;"	m	struct:rating_data
ratingd	db2.c	/^RATING_DATA ratingd;$/;"	v
raw_kill	death.c	/^raw_kill (CHAR_DATA * victim, bool used_sword)$/;"	f
raw_purge	aw.c	/^void raw_purge (ROOM_DATA * rid)$/;"	f
read_auth	inetd.c	/^read_auth (struct descriptor_data *d)$/;"	f
read_channel_data	chan.c	/^read_channel_data (void)$/;"	f
read_command_levels	power.c	/^read_command_levels (void)$/;"	f
read_conflict_data	conflict.c	/^read_conflict_data (void)$/;"	f
read_damages	dam.c	/^read_damages (void)$/;"	f
read_from_buffer	comm.c	/^read_from_buffer (DESCRIPTOR_DATA * d)$/;"	f
read_from_descriptor	rfd.c	/^read_from_descriptor (DESCRIPTOR_DATA * d)$/;"	f
read_monthly_key	comm.c	/^read_monthly_key (void)$/;"	f
read_notes	emlen.h	/^  NOTE_STAMP_LIST *read_notes;	\/* List of read notes (stamps) *\/$/;"	m	struct:pc_data
read_power_dat	power.c	/^read_power_dat (void)$/;"	f
read_race_info	power.c	/^read_race_info (void)$/;"	f
read_read_notes	note.c	/^read_read_notes (CHAR_DATA * ch)$/;"	f
read_read_polls	poll.c	/^read_read_polls (CHAR_DATA * ch)$/;"	f
read_score	score.c	/^read_score (CHAR_DATA * ch, char *argy)$/;"	f
reason_for_death	emlen.h	/^  char reason_for_death[30];$/;"	m	struct:item_container
reasonfd	fgt.c	/^char reasonfd[30];$/;"	v
reasonone	db2.c	/^char reasonone[30];$/;"	v
recent_port	int.c	/^int recent_port = 5458;$/;"	v
redit	redit.c	/^void redit (CHAR_DATA * ch, char *argy)$/;"	f
refresh_oldchars	db2.c	/^bool refresh_oldchars = FALSE;$/;"	v
regen_hit_percent	emlen.h	/^  int regen_hit_percent;	\/* Hit point regeneration percent *\/$/;"	m	struct:race_data
regen_move_percent	emlen.h	/^  int regen_move_percent;	\/* Move point regenration percent *\/$/;"	m	struct:race_data
reload_pbase	pb.c	/^reload_pbase (CHAR_DATA * ch, char *argy)$/;"	f
reload_power_dat	power.c	/^reload_power_dat (CHAR_DATA * ch, char *argy)$/;"	f
relocate_mobs	reloc.c	/^     void relocate_mobs (CHAR_DATA * ch, char *argy)$/;"	f
relocate_objs	reloc.c	/^      void relocate_objs (CHAR_DATA * ch, char *argy)$/;"	f
relocate_rooms	reloc.c	/^relocate_rooms (CHAR_DATA * ch, char *argy)$/;"	f
rem_hitgain	emlen.h	/^  short rem_hitgain[10][5];	\/* Remort hit gains in a given level range *\/$/;"	m	struct:power_data
rem_movegain	emlen.h	/^  short rem_movegain[10][4];	\/* Remort move gains in a given level range *\/$/;"	m	struct:power_data
rembitvector	emlen.h	/^  int rembitvector;		\/\/ the old ones are still in though, for$/;"	m	struct:spell_data
rembitvector2	emlen.h	/^  int rembitvector2;		\/\/ compatibility...$/;"	m	struct:spell_data
remort	emlen.h	/^  char remort[MAX_REMORT_OPTIONS];	\/* Remort choices *\/$/;"	m	struct:pc_data
remort_hp	emlen.h	/^  short remort_hp[2];		\/* Remort initial hit points *\/$/;"	m	struct:power_data
remort_level	emlen.h	/^  short remort_level;		\/* Level you must be to remort *\/$/;"	m	struct:power_data
remort_mv	emlen.h	/^  short remort_mv[2];		\/* Remort initial move points *\/$/;"	m	struct:power_data
remort_times	emlen.h	/^  char remort_times;		\/* Remort times.. *\/$/;"	m	struct:pc_data
remove_all_objs	alien.c	/^remove_all_objs (CHAR_DATA * ch)$/;"	f
remove_from_aggro_list	hnd.c	/^remove_from_aggro_list (CHAR_DATA * ch)$/;"	f
remove_from_combat_field	combat.c	/^remove_from_combat_field (CHAR_DATA * ch)$/;"	f
remove_from_combat_field_yes	combat.c	/^remove_from_combat_field_yes (CHAR_DATA * ch)$/;"	f
remove_from_fighting_list	hnd.c	/^remove_from_fighting_list (CHAR_DATA * ch)$/;"	f
remove_obj	give.c	/^remove_obj (CHAR_DATA * ch, int iWear, bool fReplace)$/;"	f
remove_sa	spl.c	/^remove_sa (SPELL_DATA * spell, int level, CHAR_DATA * ch, void *vo)$/;"	f
remove_trigger_from_list	script3.c	/^void remove_trigger_from_list (SINGLE_TRIGGER * tr)$/;"	f
remove_while_fighting	emlen.h	/^  bool remove_while_fighting;	\/* Remove armor while fighting? *\/$/;"	m	struct:power_data
renew_affect	mgc.c	/^renew_affect (CHAR_DATA * ch, AFFECT_DATA * aff)$/;"	f
repair_armors	emlen.h	/^  short repair_armors;		\/* Costs to repair armor *\/$/;"	m	struct:power_data
repair_weapons	emlen.h	/^  short repair_weapons[3];	\/* Costs to repair weapons *\/$/;"	m	struct:power_data
repeat	emlen.h	/^  int repeat;			\/* Repeat count; catch spammers *\/$/;"	m	struct:descriptor_data
repels	emlen.h	/^  int repels[9];		\/* Repels mobs of these vnums *\/$/;"	m	struct:item_spray
replace	view.c	/^replace (CHAR_DATA * ch, char *argy)$/;"	f
replace_string	script3.c	/^char *replace_string (char *orig, char *old, char *new)$/;"	f
reply	emlen.h	/^  CHAR_DATA *reply;		\/* Last person who sent him\/her a tell *\/$/;"	m	struct:ced
repop	emlen.h	/^  char *repop;			\/* Repop message *\/$/;"	m	struct:area_data
repop_counter	emlen.h	/^  int repop_counter;		\/* Current repop counter *\/$/;"	m	struct:area_data
repop_rate	emlen.h	/^  int repop_rate;		\/* Repop rate in hours *\/$/;"	m	struct:area_data
reset_data	draw.c	/^reset_data (void)$/;"	f
reset_data	emlen.h	/^struct reset_data$/;"	s
reset_first	emlen.h	/^  RESET_DATA *reset_first;	\/* First reset in room *\/$/;"	m	struct:room_extended
reset_first	emlen.h	/^  RESET_DATA *reset_first;	\/* First reset in this area *\/$/;"	m	struct:area_data
reset_free	hnd.c	/^RESET_DATA *reset_free = NULL;$/;"	v
reset_free	oc.c	/^RESET_DATA *reset_free;$/;"	v
reset_last	emlen.h	/^  RESET_DATA *reset_last;	\/* Last reset in room *\/$/;"	m	struct:room_extended
reset_last	emlen.h	/^  RESET_DATA *reset_last;	\/* Last reset in this area *\/$/;"	m	struct:area_data
reset_room	upd.c	/^reset_room (ROOM_DATA * pRoom)$/;"	f
reset_world	db2.c	/^reset_world (void)$/;"	f
resist_summon	emlen.h	/^  signed char resist_summon;	\/* Resistance to summon value *\/$/;"	m	struct:pc_data
resize_divisor	emlen.h	/^  short resize_divisor;		\/* Resize divisor for resize cost *\/$/;"	m	struct:power_data
restore_when_level	emlen.h	/^  bool restore_when_level;	\/* Free restore when you level? *\/$/;"	m	struct:power_data
rev_dir	move.c	/^const short rev_dir[] = {$/;"	v
revdir	move.c	/^const short revdir[] = {$/;"	v
rgObjNest	sv.c	/^static SINGLE_OBJECT *rgObjNest[MAX_NESTING];$/;"	v	file:
rgiState	db2.c	/^  static int rgiState[2 + 55]; void init_mm ()$/;"	v	file:
riding	emlen.h	/^  CHAR_DATA *riding;		\/* Riding for mounts *\/$/;"	m	struct:fight_data
rip_ears	grnd.c	/^rip_ears (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
rnd	dam2.c	/^int rnd;$/;"	v
roll_new_stats	comm.c	/^roll_new_stats (CHAR_DATA * ch)$/;"	f
room	ar.c	/^  ROOM_DATA *room;$/;"	m	struct:bfs_queue_struct	file:
room	ar.c	/^  ROOM_DATA *room;$/;"	m	struct:room_list_struct	file:
room	script.h	/^  ROOM_DATA *room;		\/* If a room is executing this is the room *\/$/;"	m	struct:script_info
room_bit_name	hnd.c	/^room_bit_name (int room_flags)$/;"	f
room_chunk	db2.c	/^int room_chunk = 0;$/;"	v
room_count	emlen.h	/^  int room_count;		\/* Rooms in area *\/$/;"	m	struct:area_data
room_data	emlen.h	/^struct room_data$/;"	s
room_extended	emlen.h	/^struct room_extended$/;"	s
room_flags	emlen.h	/^  int room_flags;		\/* Room flags *\/$/;"	m	struct:room_data
room_flags_2	emlen.h	/^  int room_flags_2;		\/* More Room flags and dynamic desc flags *\/$/;"	m	struct:room_data
room_flagss	def.c	/^const struct flag_data room_flagss[] = {$/;"	v	typeref:struct:flag_data
room_from_room	room.c	/^room_from_room (ROOM_DATA * vehicle)$/;"	f
room_hash	db2.c	/^ROOM_DATA *room_hash[HASH_MAX];$/;"	v
room_index_free	oc.c	/^ROOM_DATA *room_index_free;$/;"	v
room_is_dark	hnd.c	/^room_is_dark (ROOM_DATA * oneroom)$/;"	f
room_list_struct	ar.c	/^struct room_list_struct$/;"	s	file:
room_name_bit	hnd.c	/^room_name_bit (char *buf)$/;"	f
room_to_room	room.c	/^room_to_room (ROOM_DATA * vehicle, ROOM_DATA * room, bool boat)$/;"	f
room_update	upd.c	/^room_update (void)$/;"	f
route_io	shell.c	/^route_io (int fd1, int fd2)$/;"	f
rprompt	emlen.h	/^  char *rprompt;		\/* Real string prompt *\/$/;"	m	struct:pc_data
rpwd	emlen.h	/^  char *rpwd;			\/* Internal use *\/$/;"	m	struct:pc_data
rs_flags	emlen.h	/^  int rs_flags;			\/* Reset Flags for doors, etc *\/$/;"	m	struct:door_data
rs_vnum	emlen.h	/^  int rs_vnum;			\/* Reset vnum *\/$/;"	m	struct:reset_data
running_char_function	emlen.h	/^  CHR_FUNCTION *running_char_function;$/;"	m	struct:fight_data
running_info	script.h	/^  SCRIPT_INFO *running_info;$/;"	m	struct:single_trigger
sAllocString	db2.c	/^int sAllocString;$/;"	v
s_bplate_etc	emlen.h	/^  bool s_bplate_etc;$/;"	m	struct:material_data
sa_head	db2.c	/^SA *sa_head[27];$/;"	v
sac_points	db2.c	/^int sac_points[30];$/;"	v
sac_vnums	db2.c	/^int sac_vnums[30];$/;"	v
save_area	oc.c	/^void save_area (AREA_DATA * pArea)$/;"	f
save_area_list	oc.c	/^void save_area_list ()$/;"	f
save_banlist	oc.c	/^void save_banlist (void)$/;"	f
save_boats	db2.c	/^save_boats (void)$/;"	f
save_char_obj	sv.c	/^save_char_obj (CHAR_DATA * ch)$/;"	f
save_char_tro	sv.c	/^save_char_tro (CHAR_DATA * ch)$/;"	f
save_clans	oc.c	/^void save_clans (void)$/;"	f
save_clans_2	oc.c	/^void save_clans_2 (void)$/;"	f
save_code	script3.c	/^void save_code (void)$/;"	f
save_corpse	sv.c	/^save_corpse (CHAR_DATA * ch)$/;"	f
save_day_counter	db2.c	/^save_day_counter (void)$/;"	f
save_helps	hedit.c	/^save_helps ()$/;"	f
save_limited	oc.c	/^void save_limited (int vnum)$/;"	f
save_limited	oc.c	/^void save_limited (void)$/;"	f
save_mobiles	oc.c	/^void save_mobiles (FILE * fp, AREA_DATA * pArea)$/;"	f
save_monthly_key	comm.c	/^save_monthly_key (void)$/;"	f
save_new_socials	db2.c	/^save_new_socials (void)$/;"	f
save_notes	note.c	/^save_notes (void)$/;"	f
save_objects	oc.c	/^void save_objects (FILE * fp, AREA_DATA * pArea)$/;"	f
save_playerbase	oc.c	/^void save_playerbase (void)$/;"	f
save_playerbase	utils.c	/^save_playerbase (void)$/;"	f
save_polls	poll.c	/^save_polls (void)		\/\/ save polls to disk$/;"	f
save_random_pops	db2.c	/^save_random_pops (void)$/;"	f
save_rating	oc.c	/^void save_rating (void)$/;"	f
save_read_notes	note.c	/^save_read_notes (CHAR_DATA * ch)$/;"	f
save_read_polls	poll.c	/^save_read_polls (CHAR_DATA * ch)$/;"	f
save_rooms	oc.c	/^void save_rooms (FILE * fp, AREA_DATA * pArea)$/;"	f
save_topten	oc.c	/^void save_topten (void)$/;"	f
save_triggers	script3.c	/^void save_triggers (void)$/;"	f
saves_spell	mgc.c	/^saves_spell (int level, CHAR_DATA * victim)$/;"	f
saving	db2.c	/^AREA_DATA *saving = NULL;$/;"	v
saving_throw	emlen.h	/^  short saving_throw;		\/* Saving throw for spells *\/$/;"	m	struct:pc_data
say_spell	mgc.c	/^say_spell (CHAR_DATA * ch, int sn)$/;"	f
scan_clan	clan.c	/^scan_clan (char *arg)$/;"	f
scan_clan_2	clan.c	/^scan_clan_2 (char *arg)$/;"	f
scan_direction	look.c	/^scan_direction (CHAR_DATA * ch, int dir)$/;"	f
scan_room_for_people	yell.c	/^scan_room_for_people (CHAR_DATA * ch, ROOM_DATA * rid)$/;"	f
scanning	emlen.h	/^  bool scanning;		\/* Internal use with scan function *\/$/;"	m	struct:ced
scanthru_commands	cmd.c	/^scanthru_commands (void)$/;"	f
scatter_mob	spl.c	/^scatter_mob (CHAR_DATA * mob)$/;"	f
score	db2.c	/^char *score = NULL;$/;"	v
score_while_fighting	emlen.h	/^  bool score_while_fighting;	\/* Use score while fighting? *\/$/;"	m	struct:power_data
scr_wait	emlen.h	/^  short scr_wait;		\/*Wait for the script to continue *\/$/;"	m	struct:ced
script_dat	emlen.h	/^struct script_dat$/;"	s
script_data	emlen.h	/^struct script_data$/;"	s
script_delay	emlen.h	/^  short script_delay;$/;"	m	struct:fight_data
script_editor	script3.c	/^script_editor (CHAR_DATA * ch, char *argy)$/;"	f
script_flags	emlen.h	/^  char *script_flags[3000];	\/* Actual new script language flags. *\/$/;"	m	struct:pc_data
script_fn	emlen.h	/^  char *script_fn;		\/* Script function, old format scripts *\/$/;"	m	struct:mob_proto_data
script_free	hnd.c	/^SCRIPT_DATA *script_free = NULL;$/;"	v
script_info	script.h	/^struct script_info$/;"	s
scriptassoc	emlen.h	/^struct scriptassoc$/;"	s
scriptedit	script3.c	/^void scriptedit (CHAR_DATA * ch, char *argy)$/;"	f
scriptline	emlen.h	/^  char *scriptline;		\/*The actual "if" line *\/$/;"	m	struct:triggy
scrn_upd	remort.c	/^scrn_upd (CHAR_DATA * ch)$/;"	f
scrnn	draw.c	/^char scrnn[80][25][15];		\/* Virtual Screen - holds ANSI color values *\/$/;"	v
scry	pinfo.c	/^scry (CHAR_DATA * ch, int level, char *argy)$/;"	f
seconddice	emlen.h	/^  signed char seconddice;	\/* v8 *\/$/;"	m	struct:item_weapon
sector_fname	redit.c	/^char * sector_fname (int flag)$/;"	f
sector_toggle	redit.c	/^int sector_toggle (char *inpt)$/;"	f
sector_type	emlen.h	/^  short sector_type;		\/* The type of sector this room is *\/$/;"	m	struct:room_data
sector_use	emlen.h	/^  signed char sector_use;	\/* v0 *\/$/;"	m	struct:item_vehicle
security	emlen.h	/^  short security;		\/* Security level.. UNUSED *\/$/;"	m	struct:pc_data
security	emlen.h	/^  short security;		\/* Security, unused *\/$/;"	m	struct:area_data
sedit	sedit.c	/^sedit (CHAR_DATA * ch, char *argy)$/;"	f
seg_count	db2.c	/^int seg_count = 0;$/;"	v
segfault_handler	db2.c	/^segfault_handler ()$/;"	f
segfault_save_handler	sv.c	/^segfault_save_handler ()$/;"	f	file:
send_auth	inetd.c	/^send_auth (struct descriptor_data *d)$/;"	f
send_edit_char	oc.c	/^send_edit_char (char *st, CHAR_DATA * ch)$/;"	f
send_java_info	dam.c	/^send_java_info (DESCRIPTOR_DATA * d)$/;"	f
send_pic_to_medit	oc.c	/^send_pic_to_medit (CHAR_DATA * ch, MOB_PROTOTYPE * mob)$/;"	f
send_pic_to_oedit	oc.c	/^send_pic_to_oedit (CHAR_DATA * ch, OBJ_PROTOTYPE * obj)$/;"	f
send_to_boat	boat.c	/^send_to_boat (CHAR_DATA * ch, SINGLE_OBJECT * boat, char *to_send)$/;"	f
send_to_char	comm.c	/^send_to_char (const char *txt, CHAR_DATA * ch)$/;"	f
sender	emlen.h	/^  char *sender;			\/* Note's sender *\/$/;"	m	struct:note_data
sender	poll.h	/^  char *sender;			\/* Who set it up *\/$/;"	m	struct:poll_data
serv	channels.c	/^serv (DESCRIPTOR_DATA * d, char *input)$/;"	f
set_default_prompt	prompt.c	/^set_default_prompt (CHAR_DATA * ch, char option)$/;"	f
set_fighting	fgt.c	/^set_fighting (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
set_initial_hp	power.c	/^set_initial_hp (CHAR_DATA * ch)$/;"	f
set_it_up	remort.c	/^set_it_up (CHAR_DATA * ch)$/;"	f
set_mob_xp	db2.c	/^set_mob_xp (CHAR_DATA * mob)$/;"	f
set_monthly_key	comm.c	/^set_monthly_key (CHAR_DATA * ch, char *argy)$/;"	f
set_rank	config.c	/^set_rank (CHAR_DATA * ch, char *rank)$/;"	f
set_title	config.c	/^set_title (CHAR_DATA * ch, char *title)$/;"	f
setnext	move.c	/^setnext (CHAR_DATA * ch, char *c)$/;"	f
setup_skills	sedit.c	/^setup_skills (void)$/;"	f
sex	emlen.h	/^  char sex;			\/* Male\/female *\/$/;"	m	struct:pc_data
sex	emlen.h	/^  unsigned char sex;		\/* Mob's sex *\/$/;"	m	struct:mob_proto_data
sh_score	db2.c	/^char *sh_score = NULL;$/;"	v
shade	emlen.h	/^  bool shade;			\/* Is this room shaded? *\/$/;"	m	struct:room_data
sheath_obj	give.c	/^sheath_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
shell_command	emlen.h	/^struct shell_command$/;"	s
shell_first	syslag.c	/^SHELL *shell_first = NULL;$/;"	v
shield_rush	pal.c	/^shield_rush (CHAR_DATA * ch, char * argy) $/;"	f
shop_data	emlen.h	/^struct shop_data$/;"	s
shop_first	db2.c	/^SHOP_DATA *shop_first;$/;"	v
shop_free	oc.c	/^SHOP_DATA *shop_free;$/;"	v
shop_last	db2.c	/^SHOP_DATA *shop_last;$/;"	v
short_affect_name	emlen.h	/^  char *short_affect_name;$/;"	m	struct:spell_data
short_descr	emlen.h	/^  char *short_descr;		\/* Short description "a longsword" *\/$/;"	m	struct:obj_proto_data
short_descr	emlen.h	/^  char *short_descr;		\/* Short description of player *\/$/;"	m	struct:pc_data
short_descr	emlen.h	/^  char *short_descr;		\/* Short description of the object *\/$/;"	m	struct:obj_data
short_descr	emlen.h	/^  char *short_descr;		\/* short description "a giant cow", etc.. *\/$/;"	m	struct:mob_proto_data
short_msg	emlen.h	/^  char *short_msg;		\/* Short message for affect *\/$/;"	m	struct:affect_data
show_bash_skill	sedit.c	/^show_bash_skill (CHAR_DATA * ch, SPELL_DATA * spell)$/;"	f
show_char_to_char	look.c	/^show_char_to_char (CHAR_DATA * list, CHAR_DATA * ch)$/;"	f
show_char_to_char_0	look.c	/^show_char_to_char_0 (CHAR_DATA * victim, CHAR_DATA * ch)$/;"	f
show_char_to_char_1	look.c	/^show_char_to_char_1 (CHAR_DATA * victim, CHAR_DATA * ch)$/;"	f
show_extras	pedit.c	/^show_extras (CHAR_DATA * god, CHAR_DATA * victim)$/;"	f
show_gen_skill	sedit.c	/^show_gen_skill (CHAR_DATA * ch, SPELL_DATA * spell)$/;"	f
show_guilds	aw.c	/^void show_guilds (CHAR_DATA * ch, int bit)$/;"	f
show_hedit	hedit.c	/^show_hedit (HELP_DATA * pHelp, CHAR_DATA * ch)$/;"	f
show_hitdam	spl.c	/^show_hitdam (int gsn, char *noun, int dam, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
show_implants	pedit.c	/^show_implants (CHAR_DATA * ch, CHAR_DATA * looker)$/;"	f
show_lev	emlen.h	/^  bool show_lev;		\/* Show level in 'who' list? *\/$/;"	m	struct:pc_data
show_list_to_char	look.c	/^show_list_to_char (SINGLE_OBJECT * list, CHAR_DATA * ch, bool fShort,$/;"	f
show_player	pedit.c	/^show_player (CHAR_DATA * god, CHAR_DATA * victim)$/;"	f
show_profs	alien.c	/^show_profs (CHAR_DATA * ch)$/;"	f
show_profs_available	alien.c	/^show_profs_available (CHAR_DATA * ch)$/;"	f
show_questflags	aw.c	/^show_questflags (CHAR_DATA * ch, char *argy)$/;"	f
show_race_select_info	emlen.h	/^  bool show_race_select_info;	\/* Shows race stats to newbies? *\/$/;"	m	struct:power_data
show_remort	remort.c	/^show_remort (CHAR_DATA * ch)$/;"	f
show_results	int.c	/^void show_results (void)$/;"	f
show_room_name	reloc.c	/^     char *show_room_name (CHAR_DATA * ch, char *roomname)$/;"	f
show_social	chan.c	/^show_social (SOCIAL * s, CHAR_DATA * ch)$/;"	f
show_spell	sedit.c	/^show_spell (CHAR_DATA * ch, SPELL_DATA * spell, int row)$/;"	f
show_string	comm.c	/^show_string (struct descriptor_data *d, char *input)$/;"	f
show_this_trigger	script3.c	/^void show_this_trigger (CHAR_DATA * ch, char *trig)$/;"	f
show_weap_skill	sedit.c	/^show_weap_skill (CHAR_DATA * ch, SPELL_DATA * spell)$/;"	f
show_who_window	dam.c	/^show_who_window (CHAR_DATA * ch)$/;"	f
shown_in_help	emlen.h	/^  bool shown_in_help;		\/* Should this flag be available in helpfiles? *\/$/;"	m	struct:flag_data
showstr_head	emlen.h	/^  char *showstr_head;		\/* Head of string pausing *\/$/;"	m	struct:descriptor_data
showstr_point	emlen.h	/^  char *showstr_point;		\/* Pointer to showstring string pausing *\/$/;"	m	struct:descriptor_data
single_trigger	script.h	/^struct single_trigger$/;"	s
size	emlen.h	/^  unsigned char size;		\/* Default Size of the object *\/$/;"	m	struct:obj_proto_data
size	emlen.h	/^  unsigned char size;		\/* Size of this specific object *\/$/;"	m	struct:obj_data
skill_gain	fgt.c	/^skill_gain (CHAR_DATA * ch, short gsn, bool report)$/;"	f
skill_lookup	sedit.c	/^skill_lookup (char *txt, int sn)$/;"	f
skill_loss_on_mob_death	emlen.h	/^  bool skill_loss_on_mob_death;	\/* skills lost on mob death? *\/$/;"	m	struct:power_data
skill_loss_on_pk_death	emlen.h	/^  bool skill_loss_on_pk_death;	\/* skills lost on pk death? *\/$/;"	m	struct:power_data
skltaught	emlen.h	/^  short skltaught[30];		\/* Skills this mob teaches *\/$/;"	m	struct:optional_data
sky	emlen.h	/^  short sky;			\/* Sky value *\/$/;"	m	struct:weather_data
slash_rating	emlen.h	/^  signed char slash_rating;	\/* v5 *\/$/;"	m	struct:item_armor
slc_names	telnet.h	/^char *slc_names[] = {$/;"	v
sleepy_time	db2.c	/^sleepy_time (void)$/;"	f
slot	emlen.h	/^  int slot;			\/* Slot, unused! *\/$/;"	m	struct:spell_data
slot_lookup	mgc.c	/^slot_lookup (int slot)$/;"	f
smack	comm.c	/^CHAR_DATA *smack;$/;"	v
smash_dollarn	db2.c	/^void smash_dollarn (char *str)$/;"	f
smash_tilde	db2.c	/^void smash_tilde (char *str)$/;"	f
snoop_by	emlen.h	/^  DESCRIPTOR_DATA *snoop_by;	\/* Snooping by another descriptor *\/$/;"	m	struct:descriptor_data
soc_edit	aedit.c	/^soc_edit (CHAR_DATA * ch, char *argy)$/;"	f
social_hashed	db2.c	/^SOCIAL *social_hashed[255];$/;"	v
social_list	db2.c	/^SOCIAL *social_list;$/;"	v
social_type	emlen.h	/^struct social_type$/;"	s
social_update_hash	db2.c	/^social_update_hash (void)$/;"	f
socket_t	comm.c	/^typedef SOCKET socket_t;$/;"	t	file:
socket_t	emlen.h	/^typedef SOCKET socket_t;$/;"	t
socket_t	emlen.h	/^typedef int socket_t;$/;"	t
sorted_eqlist	def.c	/^short const sorted_eqlist[MAX_WEAR] =$/;"	v
space_needed	emlen.h	/^  int space_needed;		\/* Shared string space needed on bootup. *\/$/;"	m	struct:power_data
spam	hnd.c	/^spam (CHAR_DATA * ch, char *argy)$/;"	f
spec_barbarian	spec.c	/^spec_barbarian (CHAR_DATA * ch)$/;"	f
spec_breath_acid	spec.c	/^spec_breath_acid (CHAR_DATA * ch)$/;"	f
spec_breath_any	spec.c	/^spec_breath_any (CHAR_DATA * ch)$/;"	f
spec_breath_fire	spec.c	/^spec_breath_fire (CHAR_DATA * ch)$/;"	f
spec_breath_frost	spec.c	/^spec_breath_frost (CHAR_DATA * ch)$/;"	f
spec_breath_gas	spec.c	/^spec_breath_gas (CHAR_DATA * ch)$/;"	f
spec_breath_lightning	spec.c	/^spec_breath_lightning (CHAR_DATA * ch)$/;"	f
spec_eatcorpse	spec.c	/^spec_eatcorpse (CHAR_DATA * ch)$/;"	f
spec_executioner	spec.c	/^spec_executioner (CHAR_DATA * ch)$/;"	f
spec_fun	emlen.h	/^  SPEC_FUNCTION *spec_fun;	\/* Special function pointer, compat with diku *\/$/;"	m	struct:mob_proto_data
spec_guard	spec.c	/^spec_guard (CHAR_DATA * ch)$/;"	f
spec_janitor	spec.c	/^spec_janitor (CHAR_DATA * ch)$/;"	f
spec_lookup	spec.c	/^spec_lookup (const char *name)$/;"	f
spec_name	emlen.h	/^  char *spec_name;		\/* Special function name *\/$/;"	m	struct:mob_proto_data
spec_poison	spec.c	/^spec_poison (CHAR_DATA * ch)$/;"	f
spec_thief	spec.c	/^spec_thief (CHAR_DATA * ch)$/;"	f
spec_warrior	spec.c	/^spec_warrior (CHAR_DATA * ch)$/;"	f
special	emlen.h	/^  char special;			\/* Contains ismob, is_in_fighting_list, etc *\/$/;"	m	struct:char_data
spell_acid_breath	spl.c	/^spell_acid_breath (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_bits	emlen.h	/^  int spell_bits;		\/* SPELL_SUMMON, etc.. *\/$/;"	m	struct:spell_data
spell_charm_person	spl.c	/^spell_charm_person (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_create_object	spl.c	/^spell_create_object (SPELL_DATA * spell, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_data	emlen.h	/^struct spell_data$/;"	s
spell_dispel_magic	spl.c	/^spell_dispel_magic (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_extra_bits	sedit.c	/^spell_extra_bits (int bits)$/;"	f
spell_extra_bits_rev	sedit.c	/^spell_extra_bits_rev (char *wrd)$/;"	f
spell_fire_breath	spl.c	/^spell_fire_breath (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_funky_name	emlen.h	/^  char *spell_funky_name;	\/* Should match spell_name.  Basically unused. *\/$/;"	m	struct:spell_data
spell_identify	spl.c	/^spell_identify (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_level	emlen.h	/^  int spell_level;		\/* Minimum level to cast this spell *\/$/;"	m	struct:spell_data
spell_level	emlen.h	/^  unsigned char spell_level;	\/* v0 *\/$/;"	m	struct:item_potion
spell_level	emlen.h	/^  unsigned char spell_level;	\/* v0 *\/$/;"	m	struct:item_wand
spell_list	db2.c	/^SPELL_DATA *spell_list[SPELL_HASH];$/;"	v
spell_list_2	db2.c	/^SPELL_DATA *spell_list_2[SPELL_HASH];$/;"	v
spell_locate_object	spl.c	/^spell_locate_object (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_locate_person	spl.c	/^spell_locate_person (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_message	spl.c	/^spell_message (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_name	emlen.h	/^  char *spell_name;		\/* The spell's name *\/$/;"	m	struct:spell_data
spell_raise_undead	spl.c	/^spell_raise_undead (SPELL_DATA * spell, int level, CHAR_DATA * ch, void *vo) {$/;"	f
spell_scry	spl.c	/^spell_scry (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_summon	spl.c	/^spell_summon (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_teleport	spl.c	/^spell_teleport (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spell_type	emlen.h	/^  int spell_type;		\/* Offensive, defensive, etc... *\/$/;"	m	struct:spell_data
spell_word_of_recall	spl.c	/^spell_word_of_recall (int sn, int level, CHAR_DATA * ch, void *vo)$/;"	f
spells	emlen.h	/^  signed short spells[3];	\/* v1-> *\/$/;"	m	struct:item_fountain
spells	emlen.h	/^  signed short spells[3];	\/* v1-> *\/$/;"	m	struct:item_potion
spells	emlen.h	/^  signed short spells[3];	\/* v3-> *\/$/;"	m	struct:item_wand
sprays	emlen.h	/^  signed char sprays;		\/* How many charges left *\/$/;"	m	struct:item_spray
ssc	comm.c	/^char *ssc = "5454a11fkk43kt34ds8xzall";$/;"	v
sscc	comm.c	/^char *sscc = "32lloidjskjkrhserteruren541+2ans11dm0";$/;"	v
stamp	emlen.h	/^  time_t stamp;$/;"	m	struct:note_stamp_list
stamp	poll.h	/^  time_t stamp;			\/* Defines the poll *\/$/;"	m	struct:poll_stamp_list
star_a	dam.c	/^star_a (int dam, int maxhit)$/;"	f
star_b	dam.c	/^star_b (int dam, int maxhit)$/;"	f
startShell	pc_wiz.c	/^startShell (CHAR_DATA * ch, char *arg1, char *arg2)$/;"	f
start_auth	inetd.c	/^start_auth (struct descriptor_data *d)$/;"	f
start_room	emlen.h	/^  int start_room;		\/* Starting room, 99 or 100.. 99=evil 100=good *\/$/;"	m	struct:race_data
start_vnum	emlen.h	/^  int start_vnum;		\/* Starting vnum of where clanhouse begins *\/$/;"	m	struct:clan_data
state_name	comm.c	/^state_name (const short s)$/;"	f
state_var_1	db2.c	/^bool state_var_1;$/;"	v
stop_fighting	fgt.c	/^stop_fighting (CHAR_DATA * ch, bool fBoth)$/;"	f
stop_idling	comm.c	/^stop_idling (CHAR_DATA * ch)$/;"	f
storage	emlen.h	/^  SINGLE_OBJECT *storage[MAXST];	\/* Storage objects in the bank *\/$/;"	m	struct:pc_data
storage	emlen.h	/^  SINGLE_OBJECT *storage[MAX_CLAN_STORAGE];	\/* Clan storage *\/$/;"	m	struct:clan_data
stpos	sedit.c	/^stpos (int pos)$/;"	f
stpos_rev	sedit.c	/^stpos_rev (char *pos)$/;"	f
str	emlen.h	/^  signed char str;		\/* Door strength *\/$/;"	m	struct:door_data
strArea	db2.c	/^char strArea[SML_LENGTH];$/;"	v
str_app	def.c	/^const struct str_apply_type str_app[36] = {$/;"	v	typeref:struct:str_apply_type
str_apply_type	emlen.h	/^struct str_apply_type$/;"	s
str_boot_time	comm.c	/^char str_boot_time[SML_LENGTH];			\/**\/$/;"	v
str_cmp	db2.c	/^bool str_cmp (const char *astr, const char *bstr)$/;"	f
str_dup	db2.c	/^char *str_dup (const char *str)$/;"	f
str_empty	db2.c	/^char str_empty[1];$/;"	v
str_infix	db2.c	/^bool str_infix (const char *astr, const char *bstr)$/;"	f
str_name	comm.c	/^str_name (int str)$/;"	f
str_prefix	db2.c	/^bool str_prefix (const char *astr, const char *bstr)$/;"	f
str_prefix2	db2.c	/^bool str_prefix2 (char *astr, char *bstr)$/;"	f
str_suffix	db2.c	/^bool str_suffix (const char *astr, const char *bstr)$/;"	f
strangle	grnd.c	/^strangle (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
strength	emlen.h	/^  char strength;		\/* the armor durability\/hp value *\/$/;"	m	struct:material_data
strength	emlen.h	/^  signed char strength;		\/* v1 *\/$/;"	m	struct:item_weapon
strike_arms	dam2.c	/^strike_arms (int dam, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
strike_body	dam2.c	/^strike_body (int dam, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
strike_head	dam2.c	/^strike_head (int dam, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
strike_legs	dam2.c	/^strike_legs (int dam, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
string_add	script3.c	/^void string_add (CHAR_DATA * ch, char *argy)$/;"	f
string_append	script3.c	/^void string_append (CHAR_DATA * ch, char **pString)$/;"	f
string_edit	script3.c	/^void string_edit (CHAR_DATA * ch, char **pString)$/;"	f
string_hash	db2.c	/^char *string_hash[HASH_MAX];$/;"	v
string_mana	score.c	/^string_mana (int zmana)$/;"	f
string_mana_p	score.c	/^string_mana_p (int zmana)$/;"	f
string_proper	script3.c	/^char *string_proper (char *argy)$/;"	f
string_replace	script3.c	/^char *string_replace (char *orig, char *old, char *new)$/;"	f
string_space	db2.c	/^char *string_space;$/;"	v
string_unpad	script3.c	/^char *string_unpad (char *argy)$/;"	f
strip_all_affects	hnd.c	/^strip_all_affects (CHAR_DATA * ch)$/;"	f
strip_ansi_codes	ansi_out.c	/^strip_ansi_codes (char *txty)$/;"	f
strip_enters	oc.c	/^strip_enters (char *s)$/;"	f
strip_nonworn	alien.c	/^strip_nonworn (CHAR_DATA * ch)$/;"	f
strip_possessions	emlen.h	/^  signed char strip_possessions;	\/* v5 *\/$/;"	m	struct:item_furniture
strrepl	misc.c	/^strrepl (char *s, char new, char old)$/;"	f
strsub	misc.c	/^strsub (char *s, char *old, char *new)$/;"	f
strtoint	misc.c	/^strtoint (char *string)$/;"	f
styp	sedit.c	/^styp (int stype)$/;"	f
styp_rev	sedit.c	/^styp_rev (char *stype)$/;"	f
sub_coins	hnd.c	/^sub_coins (int amount, CHAR_DATA * ch)$/;"	f
subject	emlen.h	/^  char *subject;		\/* Subject of the note *\/$/;"	m	struct:note_data
subject	poll.h	/^  char *subject;		\/* Subject of the poll *\/$/;"	m	struct:poll_data
substitue_vars	script3.c	/^char *substitue_vars (SCRIPT_INFO * scr, char *ln)$/;"	f
sunlight	emlen.h	/^  short sunlight;		\/* Sunlight value *\/$/;"	m	struct:weather_data
super_channel_function	channels.c	/^super_channel_function (char *name, int align, int level, char *argy,$/;"	f
super_interpret	int.c	/^void super_interpret (CHAR_DATA * ch, char *argy)$/;"	f
switch_aligns	emlen.h	/^  bool switch_aligns;		\/* Can this race switch alignment? *\/$/;"	m	struct:race_data
syslag	syslag.c	/^syslag (CHAR_DATA * ch, char *argy)$/;"	f
tackle_person_with_weapon	emlen.h	/^  bool tackle_person_with_weapon;	\/* Allow tackling a person with a weapon? *\/$/;"	m	struct:power_data
tackle_with_weapon	emlen.h	/^  bool tackle_with_weapon;	\/* Allow tackling with a weapon? *\/$/;"	m	struct:power_data
tackles	emlen.h	/^  bool tackles;			\/* Mob attempts to tackle *\/$/;"	m	struct:optional_data
tag	emlen.h	/^  char tag;$/;"	m	struct:item_armor
tag	emlen.h	/^  char tag;$/;"	m	struct:item_blood
tag	emlen.h	/^  char tag;$/;"	m	struct:item_book
tag	emlen.h	/^  char tag;$/;"	m	struct:item_climbable
tag	emlen.h	/^  char tag;$/;"	m	struct:item_container
tag	emlen.h	/^  char tag;$/;"	m	struct:item_drink_container
tag	emlen.h	/^  char tag;$/;"	m	struct:item_food
tag	emlen.h	/^  char tag;$/;"	m	struct:item_fountain
tag	emlen.h	/^  char tag;$/;"	m	struct:item_furniture
tag	emlen.h	/^  char tag;$/;"	m	struct:item_gem
tag	emlen.h	/^  char tag;$/;"	m	struct:item_light
tag	emlen.h	/^  char tag;$/;"	m	struct:item_potion
tag	emlen.h	/^  char tag;$/;"	m	struct:item_spray
tag	emlen.h	/^  char tag;$/;"	m	struct:item_tool
tag	emlen.h	/^  char tag;$/;"	m	struct:item_vehicle
tag	emlen.h	/^  char tag;$/;"	m	struct:item_wand
tag	emlen.h	/^  char tag;$/;"	m	struct:item_weapon
tag_in_proc	emlen.h	/^  short tag_in_proc;$/;"	m	struct:fight_data
take_mana_char	mgc.c	/^take_mana_char (CHAR_DATA * ch, int zmana, int bit)$/;"	f
taking_bids	emlen.h	/^  bool taking_bids;		\/*Are we still up for bidding or has the fight begun? *\/$/;"	m	struct:bid_data
tally_coins	hnd.c	/^tally_coins (CHAR_DATA * mob)$/;"	f
tally_skills	sedit.c	/^tally_skills (CHAR_DATA * ch)$/;"	f
tally_spells	sedit.c	/^tally_spells (CHAR_DATA * ch)$/;"	f
tally_stuff	int.c	/^  WRD * headw[256]; int max; void tally_stuff (char *s)$/;"	f
target_name	mgc.c	/^char *target_name;$/;"	v
teaches	emlen.h	/^  signed short teaches;		\/* v0 *\/$/;"	m	struct:item_book
telcmds	telnet.h	/^char *telcmds[] = {$/;"	v
tell_counter	emlen.h	/^  short tell_counter;		\/* Tell counter "head" *\/$/;"	m	struct:pc_data
telopts	telnet.h	/^char *telopts[NTELOPTS + 1] = {$/;"	v
temp	emlen.h	/^  TEMP_STR *temp;		\/* Temp string for delay command use *\/$/;"	m	struct:pc_data
temp	upd.c	/^bool temp = FALSE;$/;"	v
temp_first	db2.c	/^TEMP_STR *temp_first = NULL;$/;"	v
temp_flag	emlen.h	/^  bool temp_flag[200];		\/* Temp flags for OLD quest method *\/$/;"	m	struct:pc_data
temp_free	db2.c	/^TEMP_STR *temp_free = NULL;$/;"	v
temp_room	emlen.h	/^  ROOM_DATA *temp_room;		\/* Temporary room, internal use *\/$/;"	m	struct:pc_data
temp_str	emlen.h	/^struct temp_str$/;"	s
temp_string	emlen.h	/^  char temp_string[1024];	\/* The actual string *\/$/;"	m	struct:temp_str
temp_time	upd.c	/^long temp_time[MT];$/;"	v
temperature	emlen.h	/^  short temperature;		\/* Farenheight temp *\/$/;"	m	struct:weather_data
text	emlen.h	/^  char *text;			\/* Actual help text *\/$/;"	m	struct:help_data
text	emlen.h	/^  char *text;			\/* The actual note text *\/$/;"	m	struct:note_data
text	poll.h	/^  char *text;			\/* The actual text *\/$/;"	m	struct:poll_data
this_time	upd.c	/^long this_time[MT];$/;"	v
ti	db2.c	/^int ti = 5;$/;"	v
tick_type	script.h	/^  char tick_type;		\/* 1=quick, 2=heartbeat, 3=hour, 4=superquick *\/$/;"	m	struct:script_info
tickcounts	emlen.h	/^  short tickcounts;		\/* Spell delay, internal use *\/$/;"	m	struct:pc_data
ticks_to_battlefield	db2.c	/^int ticks_to_battlefield;$/;"	v
ticks_to_reboot	db2.c	/^int ticks_to_reboot;$/;"	v
time_info	db2.c	/^TIME_INFO_DATA time_info;$/;"	v
time_info_data	emlen.h	/^struct time_info_data$/;"	s
timeout_counter	emlen.h	/^  int timeout_counter;		\/* Login screen timeout counter *\/$/;"	m	struct:descriptor_data
timer	emlen.h	/^  short timer;			\/* Mob's timer.  Disappears after this many ticks *\/$/;"	m	struct:mob_proto_data
timer	emlen.h	/^  short timer;			\/* Object timer for disappearing objs *\/$/;"	m	struct:obj_proto_data
timer	emlen.h	/^  short timer;			\/* Timer on this specific object *\/$/;"	m	struct:obj_data
timer	emlen.h	/^  short timer;			\/* Timer, AFK for players, destroy for mobs *\/$/;"	m	struct:char_data
times_through	upd.c	/^long times_through[MT];$/;"	v
tinker_discount	emlen.h	/^  short tinker_discount;	\/* Discount for tinker guild members *\/$/;"	m	struct:power_data
title	emlen.h	/^  char *title;			\/* Character's title *\/$/;"	m	struct:pc_data
tmp_stat	emlen.h	/^  signed char tmp_stat[MAX_I];	\/* temp stats *\/$/;"	m	struct:pc_data
tmphost	emlen.h	/^  char *tmphost;$/;"	m	struct:pc_data
tmpt	db2.c	/^char tmpt[2048];$/;"	v
to_align	emlen.h	/^  char to_align;		\/* 1 = same align as you  2 = good  3 = evil$/;"	m	struct:channel_type
to_do	emlen.h	/^  char *to_do;			\/*Text to be interpretted *\/$/;"	m	struct:script_dat
to_level	emlen.h	/^  int to_level;			\/* Channel is seen by all higher than this level *\/$/;"	m	struct:channel_type
to_list	emlen.h	/^  char *to_list;		\/* List of people it is to *\/$/;"	m	struct:note_data
to_list	poll.h	/^  char *to_list;		\/* List of people it is to *\/$/;"	m	struct:poll_data
to_room	emlen.h	/^  ROOM_DATA *to_room;		\/* Room data this exit leads to *\/$/;"	m	struct:exit_data
to_room_vnum	emlen.h	/^  int to_room_vnum;		\/* v1 *\/$/;"	m	struct:item_furniture
too_cold	warmth.c	/^too_cold (int warmth, CHAR_DATA * ch)$/;"	f
too_warm	warmth.c	/^too_warm (int warmth, CHAR_DATA * ch)$/;"	f
tool_type	emlen.h	/^  signed char tool_type;	\/* v0 *\/$/;"	m	struct:item_tool
top_affect	db2.c	/^int top_affect = 0;$/;"	v
top_area	db2.c	/^int top_area = 0;$/;"	v
top_ced	db2.c	/^short top_ced = 0;$/;"	v
top_clan	db2.c	/^int top_clan = 0;$/;"	v
top_clan_2	db2.c	/^int top_clan_2 = 0;$/;"	v
top_ed	db2.c	/^int top_ed = 0;$/;"	v
top_exit	db2.c	/^int top_exit = 0;$/;"	v
top_help	db2.c	/^int top_help = 0;$/;"	v
top_mob_index	db2.c	/^int top_mob_index = 0;$/;"	v
top_obj_index	db2.c	/^int top_obj_index = 0;$/;"	v
top_reset	db2.c	/^int top_reset = 0;$/;"	v
top_room	db2.c	/^int top_room = 0;$/;"	v
top_shop	db2.c	/^int top_shop = 0;$/;"	v
top_spell	db2.c	/^int top_spell;$/;"	v
top_string	db2.c	/^char *top_string;$/;"	v
top_temp	db2.c	/^short top_temp = 0;$/;"	v
top_vnum_mob	db2.c	/^int top_vnum_mob = 0;$/;"	v
top_vnum_obj	db2.c	/^int top_vnum_obj = 0;$/;"	v
top_vnum_room	db2.c	/^int top_vnum_room = 0;$/;"	v
topten	db2.c	/^TOPTEN_DATA topten;$/;"	v
topten_data	emlen.h	/^struct topten_data$/;"	s
topten_good	emlen.h	/^  bool topten_good[MAX_TOPTEN];$/;"	m	struct:topten_data
topten_name	emlen.h	/^  char topten_name[MAX_TOPTEN][17];$/;"	m	struct:topten_data
topten_warpoints	emlen.h	/^  int topten_warpoints[MAX_TOPTEN];$/;"	m	struct:topten_data
total_fgt	hnd.c	/^int total_fgt = 0;$/;"	v
total_time	upd.c	/^long total_time[MT];$/;"	v
totalkills	emlen.h	/^  int totalkills;		\/* Total kills *\/$/;"	m	struct:pc_data
tpcommand	emlen.h	/^  bool tpcommand;		\/* Command typed in? *\/$/;"	m	struct:descriptor_data
tps	emlen.h	/^  bool tps;			\/* Use travel point system? *\/$/;"	m	struct:power_data
tps	emlen.h	/^  int tps;			\/* Travel points *\/$/;"	m	struct:pc_data
tps	emlen.h	/^  short tps;			\/* Travel points in this room *\/$/;"	m	struct:room_data
tps_table	int.c	/^int tps_table[100] = {$/;"	v
track_data	emlen.h	/^struct track_data$/;"	s
tracks	emlen.h	/^  TRACK_DATA *tracks;		\/* Tracks in this room *\/$/;"	m	struct:room_data
translate	sedit.c	/^translate (char *line, int level, CHAR_DATA * ch)$/;"	f
transport_quest	emlen.h	/^  int transport_quest;		\/* Unused!!  Used internally *\/$/;"	m	struct:pc_data
transport_upd	upd.c	/^static int transport_upd = 1;$/;"	v	file:
transport_update	upd.c	/^transport_update (void)$/;"	f
trig_list	emlen.h	/^  TRIGGY_DATA *trig_list;	\/* for OLD scripts *\/$/;"	m	struct:mob_proto_data
trigger_id	script.h	/^  char trigger_id[20];$/;"	m	struct:single_trigger
trigger_it	comm.c	/^trigger_it (DESCRIPTOR_DATA * d, char *invar, char *inword, char *todo)$/;"	f
trigger_list	db2.c	/^SINGLE_TRIGGER *trigger_list[TMAX_TRIGGERS];$/;"	v
trigger_name	script3.c	/^trigger_name (char *trig)$/;"	f
trigger_type	script.h	/^  int trigger_type;		\/* Trigger type *\/$/;"	m	struct:single_trigger
trigger_type	script3.c	/^trigger_type (int trig)$/;"	f
triggers	emlen.h	/^  TRIGGER_DATA *triggers;	\/* for OLD scripts *\/$/;"	m	struct:mob_proto_data
triggy	emlen.h	/^struct triggy$/;"	s
triggy_new	db2.c	/^triggy_new (void)$/;"	f
trip	fgt.c	/^trip (CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
trophy_level	emlen.h	/^  unsigned char trophy_level[MAX_TROPHY];	\/* Level at which you last pk'd them *\/$/;"	m	struct:pc_data
trophy_name	emlen.h	/^  char trophy_name[MAX_TROPHY][18];	\/* PKill trophy storage *\/$/;"	m	struct:pc_data
trophy_times	emlen.h	/^  short trophy_times[MAX_TROPHY];	\/* Times PKilled these people *\/$/;"	m	struct:pc_data
true	emlen.h	13;"	d
try_prompt	prompt.c	/^try_prompt (char *tx, CHAR_DATA * ch)$/;"	f
tttt	upd.c	/^int prior_mana, prior_hp, prior_mv, tttt;$/;"	v
tx	dam.c	/^int tx, ty;$/;"	v
ty	dam.c	/^int tx, ty;$/;"	v
type	emlen.h	/^  int type;			\/*When this trigger is checked.. see list *\/$/;"	m	struct:triggy
type	emlen.h	/^  short type;			\/* Affect type (gsn) *\/$/;"	m	struct:affect_data
type	emlen.h	/^  signed char type;		\/* v0 *\/$/;"	m	struct:item_furniture
u_char_to_room	hnd.c	/^u_char_to_room (CHAR_DATA * ch, ROOM_DATA * oneroom)$/;"	f
unequip_char	hnd.c	/^unequip_char (CHAR_DATA * ch, SINGLE_OBJECT * obj)$/;"	f
unjumble	crsh.c	/^unjumble (char *name, bool convert)$/;"	f
unsorted_eqlist	def.c	/^short const unsorted_eqlist[MAX_WEAR] = $/;"	v
up_down	emlen.h	/^  signed char up_down;		\/* v0 *\/$/;"	m	struct:item_climbable
upd	emlen.h	/^  bool upd;			\/* Internal use *\/$/;"	m	struct:fight_data
upd_hps	remort.c	/^upd_hps (CHAR_DATA * ch)$/;"	f
upd_hunger	remort.c	/^upd_hunger (CHAR_DATA * ch)$/;"	f
upd_hungert	remort.c	/^upd_hungert (CHAR_DATA * ch)$/;"	f
upd_mana	remort.c	/^upd_mana (CHAR_DATA * ch)$/;"	f
upd_mps	remort.c	/^upd_mps (CHAR_DATA * ch)$/;"	f
upd_thirst	remort.c	/^upd_thirst (CHAR_DATA * ch)$/;"	f
upd_xp	remort.c	/^upd_xp (CHAR_DATA * ch)$/;"	f
update_char	remort.c	/^char update_char[400];$/;"	v
update_gsn_hash	sedit.c	/^update_gsn_hash (void)$/;"	f
update_handler	upd.c	/^update_handler (void)$/;"	f
update_myhost	comm.c	/^update_myhost (CHAR_DATA * ch)$/;"	f
update_name_hash	sedit.c	/^update_name_hash (void)$/;"	f
update_pbase	pb.c	/^update_pbase (CHAR_DATA * ch)$/;"	f
update_pos	fgt.c	/^update_pos (CHAR_DATA * victim)$/;"	f
update_prereq	sedit.c	/^update_prereq (void)$/;"	f
update_weight_num	move.c	/^update_weight_num (CHAR_DATA * ch)$/;"	f
uppercase	config.c	/^char * uppercase(char * str)$/;"	f
use_tool	hnd.c	/^use_tool (SINGLE_OBJECT * obj, int bit)$/;"	f
used_spell	skill.c	/^static bool used_spell[SKILL_COUNT];$/;"	v	file:
username	emlen.h	/^  char *username;		\/* Username result from ident *\/$/;"	m	struct:descriptor_data
uses	emlen.h	/^  signed char uses;		\/* v1 *\/$/;"	m	struct:item_tool
using_shield	fgt.c	/^bool using_shield = FALSE;$/;"	v
using_weapon	fgt.c	/^bool using_weapon = FALSE;$/;"	v
uvnum	emlen.h	/^  int uvnum;			\/* Upper vnum *\/$/;"	m	struct:area_data
validation	emlen.h	/^  bool validation;		\/* Validation system on\/off *\/$/;"	m	struct:power_data
value	emlen.h	/^  int value[10];		\/* If trash, then v0 = north$/;"	m	struct:obj_proto_data
values	emlen.h	/^  int values[10];		\/* Uses these values on creates_obj... UNUSED! *\/$/;"	m	struct:spell_data
values_2	emlen.h	/^  short values_2[10];$/;"	m	struct:obj_proto_data
vaporize_all	emlen.h	/^  bool vaporize_all;		\/* Vaporize everything when remorting? *\/$/;"	m	struct:power_data
vaporize_inv	emlen.h	/^  bool vaporize_inv;		\/* Vaporize inventory when remorting? *\/$/;"	m	struct:power_data
variable_free	hnd.c	/^VARIABLE_DATA *variable_free = NULL;$/;"	v
verify_room_name	redit.c	/^char * verify_room_name (char *rn)$/;"	f
vert_line	skill.c	/^static bool vert_line[100];$/;"	v	file:
vict_found	emlen.h	/^  char *vict_found;$/;"	m	struct:social_type
victismob	emlen.h	/^  bool victismob;$/;"	m	struct:track_data
victname	emlen.h	/^  char *victname; \/* victim's name *\/$/;"	m	struct:track_data
view_scriptassoc	db2.c	/^view_scriptassoc (CHAR_DATA * ch, char *argy)$/;"	f
violence_update	fgt.c	/^violence_update (bool flaggy)$/;"	f
vnum	emlen.h	/^  int vnum;			\/* Object vnum *\/$/;"	m	struct:obj_proto_data
vnum	emlen.h	/^  int vnum;			\/* The room's vnum *\/$/;"	m	struct:room_data
vnum	emlen.h	/^  int vnum;			\/* The vnum of this mob *\/$/;"	m	struct:mob_proto_data
vnum	emlen.h	/^  int vnum;			\/* Vnum it pops *\/$/;"	m	struct:reset_data
vnum	emlen.h	/^  int vnum;			\/* Vnum of area *\/$/;"	m	struct:area_data
vnum	emlen.h	/^  int vnum;			\/* Vnum this exit leads to *\/$/;"	m	struct:exit_data
vnum	emlen.h	/^  int vnum;$/;"	m	struct:b_list
vnum	emlen.h	/^  short vnum;			\/* Clan vnum *\/$/;"	m	struct:clan_data
votes	poll.h	/^  int votes[MAX_OPTION];	\/* Votes for each option *\/$/;"	m	struct:poll_data
voting_on	emlen.h	/^  int voting_on;		\/* Unused.. internal use *\/$/;"	m	struct:pc_data
vp	dam2.c	/^char vp[STD_LENGTH];		\/* ... hit ... *\/$/;"	v
vs	dam2.c	/^char vs[STD_LENGTH];		\/* You hit ... *\/$/;"	v
vy	dam2.c	/^char vy[STD_LENGTH];		\/* ... hit YOU. *\/$/;"	v
w	int.c	/^  unsigned char w[50];$/;"	m	struct:wrd	file:
wait	emlen.h	/^  int wait;$/;"	m	struct:shell_command
wait	emlen.h	/^  short wait;			\/* Wait state *\/$/;"	m	struct:char_data
wait_type	emlen.h	/^  signed char wait_type;	\/*How "wait" is counted down *\/$/;"	m	struct:ced
waitticks	emlen.h	/^  int waitticks;$/;"	m	struct:bid_data
waitticks	emlen.h	/^  int waitticks;$/;"	m	struct:clanwar
warmth	emlen.h	/^  signed char warmth;		\/* v9 *\/$/;"	m	struct:item_armor
warned	emlen.h	/^  short warned;			\/* Warned, for old style JAIL *\/$/;"	m	struct:pc_data
warpoints	emlen.h	/^  unsigned short warpoints;	\/* War points *\/$/;"	m	struct:pc_data
warrior_percent	emlen.h	/^  signed char warrior_percent;	\/* Percent the mob will try a kick\/tackle\/flurry *\/$/;"	m	struct:optional_data
was_in_room	emlen.h	/^  ROOM_DATA *was_in_room;	\/* Was in this room before battleground *\/$/;"	m	struct:ced
wasroom	emlen.h	/^  int wasroom;			\/* Was in room before arena *\/$/;"	m	struct:ced
wasroomtwo	emlen.h	/^  int wasroomtwo;		\/* Internal use *\/$/;"	m	struct:fight_data
wear_bit_name	hnd.c	/^wear_bit_name (int wear)$/;"	f
wear_flags	emlen.h	/^  int wear_flags;		\/* Where can this be worn? *\/$/;"	m	struct:obj_proto_data
wear_loc	emlen.h	/^  int wear_loc;			\/* Location object is being worn *\/$/;"	m	struct:obj_data
wear_loc_name	hnd.c	/^wear_loc_name (int wearloc)$/;"	f
wear_name_bit	hnd.c	/^wear_name_bit (char *buf)$/;"	f
wear_name_loc	hnd.c	/^wear_name_loc (char *buf)$/;"	f
wear_obj	give.c	/^wear_obj (CHAR_DATA * ch, SINGLE_OBJECT * obj, bool fReplace, int loc)$/;"	f
wear_off_msg	emlen.h	/^  char *wear_off_msg;		\/* When the spell wears off, this msg is disp'd *\/$/;"	m	struct:spell_data
weather	emlen.h	/^  bool weather;			\/* Weather effects on\/off *\/$/;"	m	struct:power_data
weather_change	emlen.h	/^  short weather_change;		\/* Weather change.  unused *\/$/;"	m	struct:area_data
weather_data	emlen.h	/^struct weather_data$/;"	s
weather_info	db2.c	/^WEATHER_DATA weather_info;$/;"	v
weather_update	upd.c	/^weather_update (void)$/;"	f
weight	emlen.h	/^  short weight;			\/* Weight of the object *\/$/;"	m	struct:obj_proto_data
weight	emlen.h	/^  short weight;			\/* \/4 for body, \/5 for legs, \/6 for arms, \/7 for head,$/;"	m	struct:material_data
what_it_does	emlen.h	/^  char what_it_does[255];	\/* Help for what it does. *\/$/;"	m	struct:flag_data
what_you_type	emlen.h	/^  char what_you_type[50];	\/* What you type to get the flag toggled *\/$/;"	m	struct:flag_data
where_name	def.c	/^char *const where_name[] = $/;"	v
will_echo	comm.c	/^char will_echo[] = {$/;"	v
will_help	emlen.h	/^  char will_help;		\/*Will this mob set it's hunting$/;"	m	struct:mob_proto_data
will_suppress_ga	comm.c	/^char will_suppress_ga[] = {$/;"	v
wimpy	emlen.h	/^  short wimpy;			\/* Flee at this many hit points *\/$/;"	m	struct:ced
winddir	emlen.h	/^  short winddir;		\/* Wind direction *\/$/;"	m	struct:weather_data
windspeed	emlen.h	/^  short windspeed;		\/* Wind speed *\/$/;"	m	struct:weather_data
wis_app	prse.c	/^struct wis_apply_type wis_app[36];$/;"	v	typeref:struct:wis_apply_type
wis_apply_type	emlen.h	/^struct wis_apply_type$/;"	s
wis_name	comm.c	/^wis_name (int wis)$/;"	f
wizinvis	emlen.h	/^  short wizinvis;		\/* WizInvis level *\/$/;"	m	struct:pc_data
wizlock	comm.c	/^bool wizlock;			                \/* Game is wizlocked *\/$/;"	v
wont_echo	comm.c	/^char wont_echo[] = {$/;"	v
wont_suppress_ga	comm.c	/^char wont_suppress_ga[] = {$/;"	v
word	misc.c	/^word (int wd, char *s)$/;"	f
wordies	int.c	/^char *wordies[WORDS] =$/;"	v
wordkey	int.c	/^int wordkey[WORDS] =$/;"	v
words	misc.c	/^words (char *s)$/;"	f
wordwrap	channels.c	/^wordwrap (char *txt, int wrapamount)$/;"	f
wrd	int.c	/^            typedef struct wrd WRD; struct wrd$/;"	s	file:
write_damages	db2.c	/^write_damages ()$/;"	f
write_fixed_values	sv.c	/^write_fixed_values (SINGLE_OBJECT * obj, FILE * fp)$/;"	f
write_playerbase_to_file	remort.c	/^write_playerbase_to_file (void)$/;"	f
write_spells	sedit.c	/^write_spells (void)$/;"	f
write_stat_stuff	comm.c	/^write_stat_stuff (CHAR_DATA * ch)$/;"	f
write_stuff	spl.c	/^write_stuff (SPELL_DATA * spell, CHAR_DATA * ch, CHAR_DATA * victim)$/;"	f
write_to_buffer	comm.c	/^write_to_buffer (DESCRIPTOR_DATA * d, const char *txt, int length)$/;"	f
write_to_descriptor	comm.c	/^write_to_descriptor (socket_t desc, char *txt, int length)$/;"	f
write_to_descriptor2	comm.c	/^write_to_descriptor2 (DESCRIPTOR_DATA * d, char *txt, int length)$/;"	f
wrong_pw	emlen.h	/^  bool wrong_pw;		\/* Wrong password attempt last time! *\/$/;"	m	struct:descriptor_data
wsaData	comm.c	/^WSADATA wsaData;$/;"	v
wvar	emlen.h	/^  char *wvar;			\/* Word variable *\/$/;"	m	struct:pc_data
wwrap	score.c	/^bool wwrap = TRUE;$/;"	v
x	emlen.h	/^  signed short x;		\/* X coordinate of room *\/$/;"	m	struct:room_data
xEOF	telnet.h	61;"	d
xp_compute	fgt.c	/^xp_compute (CHAR_DATA * gch, CHAR_DATA * victim)$/;"	f
xprereq	skill.c	/^void xprereq (CHAR_DATA *ch, SPELL_DATA *spell)$/;"	f
y	emlen.h	/^  signed short y;		\/* Y coordinate of room *\/$/;"	m	struct:room_data
year	emlen.h	/^  short year;$/;"	m	struct:time_info_data
yeller_number	emlen.h	/^  int yeller_number;		\/*This is a unique number that$/;"	m	struct:mob_proto_data
yes	emlen.h	28;"	d
yes_log_all	reloc.c	/^bool yes_log_all = FALSE;$/;"	v
z	emlen.h	/^  signed char z;		\/* Z coordinate of room *\/$/;"	m	struct:room_data
z_areachange	room.c	/^z_areachange (CHAR_DATA * ch, char *argy)$/;"	f
